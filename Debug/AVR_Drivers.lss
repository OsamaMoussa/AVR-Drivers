
AVR_Drivers.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007bb4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000012a  00800060  00007bb4  00007c48  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006d7  0080018a  0080018a  00007d72  2**0
                  ALLOC
  3 .stab         00009978  00000000  00000000  00007d74  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000043d9  00000000  00000000  000116ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001e0  00000000  00000000  00015ac5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000235  00000000  00000000  00015ca5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000269b  00000000  00000000  00015eda  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001512  00000000  00000000  00018575  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001394  00000000  00000000  00019a87  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000200  00000000  00000000  0001ae1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000350  00000000  00000000  0001b01c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000afa  00000000  00000000  0001b36c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001be66  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 fe 10 	jmp	0x21fc	; 0x21fc <__vector_1>
       8:	0c 94 2b 11 	jmp	0x2256	; 0x2256 <__vector_2>
       c:	0c 94 58 11 	jmp	0x22b0	; 0x22b0 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 75 2d 	jmp	0x5aea	; 0x5aea <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 3a 0b 	jmp	0x1674	; 0x1674 <__vector_10>
      2c:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 9d 15 	jmp	0x2b3a	; 0x2b3a <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 eb       	ldi	r30, 0xB4	; 180
      68:	fb e7       	ldi	r31, 0x7B	; 123
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 38       	cpi	r26, 0x8A	; 138
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	aa e8       	ldi	r26, 0x8A	; 138
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 36       	cpi	r26, 0x61	; 97
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 83 3a 	call	0x7506	; 0x7506 <main>
      8a:	0c 94 d8 3d 	jmp	0x7bb0	; 0x7bb0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 9d 04 	call	0x93a	; 0x93a <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 69 02 	call	0x4d2	; 0x4d2 <__subsf3>
      be:	0e 94 fd 04 	call	0x9fa	; 0x9fa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 fd 04 	call	0x9fa	; 0x9fa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <__fixunssfdi>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 e1 3a 	jmp	0x75c2	; 0x75c2 <__prologue_saves__>
      f6:	7b 01       	movw	r14, r22
      f8:	8c 01       	movw	r16, r24
      fa:	20 e0       	ldi	r18, 0x00	; 0
      fc:	30 e0       	ldi	r19, 0x00	; 0
      fe:	40 e8       	ldi	r20, 0x80	; 128
     100:	5f e3       	ldi	r21, 0x3F	; 63
     102:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
     106:	88 23       	and	r24, r24
     108:	4c f4       	brge	.+18     	; 0x11c <__fixunssfdi+0x32>
     10a:	aa 24       	eor	r10, r10
     10c:	bb 24       	eor	r11, r11
     10e:	cc 24       	eor	r12, r12
     110:	dd 24       	eor	r13, r13
     112:	ee 24       	eor	r14, r14
     114:	ff 24       	eor	r15, r15
     116:	00 e0       	ldi	r16, 0x00	; 0
     118:	10 e0       	ldi	r17, 0x00	; 0
     11a:	86 c0       	rjmp	.+268    	; 0x228 <__fixunssfdi+0x13e>
     11c:	c8 01       	movw	r24, r16
     11e:	b7 01       	movw	r22, r14
     120:	20 e0       	ldi	r18, 0x00	; 0
     122:	30 e0       	ldi	r19, 0x00	; 0
     124:	40 e8       	ldi	r20, 0x80	; 128
     126:	5f e4       	ldi	r21, 0x4F	; 79
     128:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
     12c:	88 23       	and	r24, r24
     12e:	54 f4       	brge	.+20     	; 0x144 <__fixunssfdi+0x5a>
     130:	c8 01       	movw	r24, r16
     132:	b7 01       	movw	r22, r14
     134:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     138:	5b 01       	movw	r10, r22
     13a:	6c 01       	movw	r12, r24
     13c:	ee 24       	eor	r14, r14
     13e:	ff 24       	eor	r15, r15
     140:	87 01       	movw	r16, r14
     142:	72 c0       	rjmp	.+228    	; 0x228 <__fixunssfdi+0x13e>
     144:	c8 01       	movw	r24, r16
     146:	b7 01       	movw	r22, r14
     148:	20 e0       	ldi	r18, 0x00	; 0
     14a:	30 e0       	ldi	r19, 0x00	; 0
     14c:	40 e8       	ldi	r20, 0x80	; 128
     14e:	5f e5       	ldi	r21, 0x5F	; 95
     150:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
     154:	87 fd       	sbrc	r24, 7
     156:	0f c0       	rjmp	.+30     	; 0x176 <__fixunssfdi+0x8c>
     158:	aa 24       	eor	r10, r10
     15a:	aa 94       	dec	r10
     15c:	bb 24       	eor	r11, r11
     15e:	ba 94       	dec	r11
     160:	cc 24       	eor	r12, r12
     162:	ca 94       	dec	r12
     164:	dd 24       	eor	r13, r13
     166:	da 94       	dec	r13
     168:	ee 24       	eor	r14, r14
     16a:	ea 94       	dec	r14
     16c:	ff 24       	eor	r15, r15
     16e:	fa 94       	dec	r15
     170:	0f ef       	ldi	r16, 0xFF	; 255
     172:	1f ef       	ldi	r17, 0xFF	; 255
     174:	59 c0       	rjmp	.+178    	; 0x228 <__fixunssfdi+0x13e>
     176:	c8 01       	movw	r24, r16
     178:	b7 01       	movw	r22, r14
     17a:	20 e0       	ldi	r18, 0x00	; 0
     17c:	30 e0       	ldi	r19, 0x00	; 0
     17e:	40 e8       	ldi	r20, 0x80	; 128
     180:	5f e2       	ldi	r21, 0x2F	; 47
     182:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
     186:	7b 01       	movw	r14, r22
     188:	8c 01       	movw	r16, r24
     18a:	22 24       	eor	r2, r2
     18c:	33 24       	eor	r3, r3
     18e:	21 01       	movw	r4, r2
     190:	90 e1       	ldi	r25, 0x10	; 16
     192:	a9 2e       	mov	r10, r25
     194:	b1 2c       	mov	r11, r1
     196:	c1 2c       	mov	r12, r1
     198:	d1 2c       	mov	r13, r1
     19a:	c0 e0       	ldi	r28, 0x00	; 0
     19c:	d0 e0       	ldi	r29, 0x00	; 0
     19e:	61 e0       	ldi	r22, 0x01	; 1
     1a0:	70 e0       	ldi	r23, 0x00	; 0
     1a2:	80 e0       	ldi	r24, 0x00	; 0
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	0a 2c       	mov	r0, r10
     1a8:	04 c0       	rjmp	.+8      	; 0x1b2 <__fixunssfdi+0xc8>
     1aa:	66 0f       	add	r22, r22
     1ac:	77 1f       	adc	r23, r23
     1ae:	88 1f       	adc	r24, r24
     1b0:	99 1f       	adc	r25, r25
     1b2:	0a 94       	dec	r0
     1b4:	d2 f7       	brpl	.-12     	; 0x1aa <__fixunssfdi+0xc0>
     1b6:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__floatunsisf>
     1ba:	3b 01       	movw	r6, r22
     1bc:	4c 01       	movw	r8, r24
     1be:	c8 01       	movw	r24, r16
     1c0:	b7 01       	movw	r22, r14
     1c2:	a4 01       	movw	r20, r8
     1c4:	93 01       	movw	r18, r6
     1c6:	0e 94 9d 04 	call	0x93a	; 0x93a <__gesf2>
     1ca:	88 23       	and	r24, r24
     1cc:	64 f0       	brlt	.+24     	; 0x1e6 <__fixunssfdi+0xfc>
     1ce:	2a 28       	or	r2, r10
     1d0:	3b 28       	or	r3, r11
     1d2:	4c 28       	or	r4, r12
     1d4:	5d 28       	or	r5, r13
     1d6:	c8 01       	movw	r24, r16
     1d8:	b7 01       	movw	r22, r14
     1da:	a4 01       	movw	r20, r8
     1dc:	93 01       	movw	r18, r6
     1de:	0e 94 c1 03 	call	0x782	; 0x782 <__divsf3>
     1e2:	7b 01       	movw	r14, r22
     1e4:	8c 01       	movw	r16, r24
     1e6:	d6 94       	lsr	r13
     1e8:	c7 94       	ror	r12
     1ea:	b7 94       	ror	r11
     1ec:	a7 94       	ror	r10
     1ee:	21 96       	adiw	r28, 0x01	; 1
     1f0:	c5 30       	cpi	r28, 0x05	; 5
     1f2:	d1 05       	cpc	r29, r1
     1f4:	a1 f6       	brne	.-88     	; 0x19e <__fixunssfdi+0xb4>
     1f6:	c8 01       	movw	r24, r16
     1f8:	b7 01       	movw	r22, r14
     1fa:	20 e0       	ldi	r18, 0x00	; 0
     1fc:	30 e0       	ldi	r19, 0x00	; 0
     1fe:	40 e8       	ldi	r20, 0x80	; 128
     200:	5f e4       	ldi	r21, 0x4F	; 79
     202:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
     206:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     20a:	5b 01       	movw	r10, r22
     20c:	6c 01       	movw	r12, r24
     20e:	9b 01       	movw	r18, r22
     210:	a6 01       	movw	r20, r12
     212:	60 e0       	ldi	r22, 0x00	; 0
     214:	70 e0       	ldi	r23, 0x00	; 0
     216:	80 e0       	ldi	r24, 0x00	; 0
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2d       	mov	r16, r2
     21c:	0e 94 ca 05 	call	0xb94	; 0xb94 <__ashldi3>
     220:	59 01       	movw	r10, r18
     222:	6a 01       	movw	r12, r20
     224:	7b 01       	movw	r14, r22
     226:	8c 01       	movw	r16, r24
     228:	95 01       	movw	r18, r10
     22a:	a6 01       	movw	r20, r12
     22c:	b7 01       	movw	r22, r14
     22e:	c8 01       	movw	r24, r16
     230:	cd b7       	in	r28, 0x3d	; 61
     232:	de b7       	in	r29, 0x3e	; 62
     234:	e2 e1       	ldi	r30, 0x12	; 18
     236:	0c 94 fd 3a 	jmp	0x75fa	; 0x75fa <__epilogue_restores__>

0000023a <_fpadd_parts>:
     23a:	a0 e0       	ldi	r26, 0x00	; 0
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e3 e2       	ldi	r30, 0x23	; 35
     240:	f1 e0       	ldi	r31, 0x01	; 1
     242:	0c 94 e1 3a 	jmp	0x75c2	; 0x75c2 <__prologue_saves__>
     246:	dc 01       	movw	r26, r24
     248:	2b 01       	movw	r4, r22
     24a:	fa 01       	movw	r30, r20
     24c:	9c 91       	ld	r25, X
     24e:	92 30       	cpi	r25, 0x02	; 2
     250:	08 f4       	brcc	.+2      	; 0x254 <_fpadd_parts+0x1a>
     252:	39 c1       	rjmp	.+626    	; 0x4c6 <_fpadd_parts+0x28c>
     254:	eb 01       	movw	r28, r22
     256:	88 81       	ld	r24, Y
     258:	82 30       	cpi	r24, 0x02	; 2
     25a:	08 f4       	brcc	.+2      	; 0x25e <_fpadd_parts+0x24>
     25c:	33 c1       	rjmp	.+614    	; 0x4c4 <_fpadd_parts+0x28a>
     25e:	94 30       	cpi	r25, 0x04	; 4
     260:	69 f4       	brne	.+26     	; 0x27c <_fpadd_parts+0x42>
     262:	84 30       	cpi	r24, 0x04	; 4
     264:	09 f0       	breq	.+2      	; 0x268 <_fpadd_parts+0x2e>
     266:	2f c1       	rjmp	.+606    	; 0x4c6 <_fpadd_parts+0x28c>
     268:	11 96       	adiw	r26, 0x01	; 1
     26a:	9c 91       	ld	r25, X
     26c:	11 97       	sbiw	r26, 0x01	; 1
     26e:	89 81       	ldd	r24, Y+1	; 0x01
     270:	98 17       	cp	r25, r24
     272:	09 f4       	brne	.+2      	; 0x276 <_fpadd_parts+0x3c>
     274:	28 c1       	rjmp	.+592    	; 0x4c6 <_fpadd_parts+0x28c>
     276:	a8 e6       	ldi	r26, 0x68	; 104
     278:	b0 e0       	ldi	r27, 0x00	; 0
     27a:	25 c1       	rjmp	.+586    	; 0x4c6 <_fpadd_parts+0x28c>
     27c:	84 30       	cpi	r24, 0x04	; 4
     27e:	09 f4       	brne	.+2      	; 0x282 <_fpadd_parts+0x48>
     280:	21 c1       	rjmp	.+578    	; 0x4c4 <_fpadd_parts+0x28a>
     282:	82 30       	cpi	r24, 0x02	; 2
     284:	a9 f4       	brne	.+42     	; 0x2b0 <_fpadd_parts+0x76>
     286:	92 30       	cpi	r25, 0x02	; 2
     288:	09 f0       	breq	.+2      	; 0x28c <_fpadd_parts+0x52>
     28a:	1d c1       	rjmp	.+570    	; 0x4c6 <_fpadd_parts+0x28c>
     28c:	9a 01       	movw	r18, r20
     28e:	ad 01       	movw	r20, r26
     290:	88 e0       	ldi	r24, 0x08	; 8
     292:	ea 01       	movw	r28, r20
     294:	09 90       	ld	r0, Y+
     296:	ae 01       	movw	r20, r28
     298:	e9 01       	movw	r28, r18
     29a:	09 92       	st	Y+, r0
     29c:	9e 01       	movw	r18, r28
     29e:	81 50       	subi	r24, 0x01	; 1
     2a0:	c1 f7       	brne	.-16     	; 0x292 <_fpadd_parts+0x58>
     2a2:	e2 01       	movw	r28, r4
     2a4:	89 81       	ldd	r24, Y+1	; 0x01
     2a6:	11 96       	adiw	r26, 0x01	; 1
     2a8:	9c 91       	ld	r25, X
     2aa:	89 23       	and	r24, r25
     2ac:	81 83       	std	Z+1, r24	; 0x01
     2ae:	08 c1       	rjmp	.+528    	; 0x4c0 <_fpadd_parts+0x286>
     2b0:	92 30       	cpi	r25, 0x02	; 2
     2b2:	09 f4       	brne	.+2      	; 0x2b6 <_fpadd_parts+0x7c>
     2b4:	07 c1       	rjmp	.+526    	; 0x4c4 <_fpadd_parts+0x28a>
     2b6:	12 96       	adiw	r26, 0x02	; 2
     2b8:	2d 90       	ld	r2, X+
     2ba:	3c 90       	ld	r3, X
     2bc:	13 97       	sbiw	r26, 0x03	; 3
     2be:	eb 01       	movw	r28, r22
     2c0:	8a 81       	ldd	r24, Y+2	; 0x02
     2c2:	9b 81       	ldd	r25, Y+3	; 0x03
     2c4:	14 96       	adiw	r26, 0x04	; 4
     2c6:	ad 90       	ld	r10, X+
     2c8:	bd 90       	ld	r11, X+
     2ca:	cd 90       	ld	r12, X+
     2cc:	dc 90       	ld	r13, X
     2ce:	17 97       	sbiw	r26, 0x07	; 7
     2d0:	ec 80       	ldd	r14, Y+4	; 0x04
     2d2:	fd 80       	ldd	r15, Y+5	; 0x05
     2d4:	0e 81       	ldd	r16, Y+6	; 0x06
     2d6:	1f 81       	ldd	r17, Y+7	; 0x07
     2d8:	91 01       	movw	r18, r2
     2da:	28 1b       	sub	r18, r24
     2dc:	39 0b       	sbc	r19, r25
     2de:	b9 01       	movw	r22, r18
     2e0:	37 ff       	sbrs	r19, 7
     2e2:	04 c0       	rjmp	.+8      	; 0x2ec <_fpadd_parts+0xb2>
     2e4:	66 27       	eor	r22, r22
     2e6:	77 27       	eor	r23, r23
     2e8:	62 1b       	sub	r22, r18
     2ea:	73 0b       	sbc	r23, r19
     2ec:	60 32       	cpi	r22, 0x20	; 32
     2ee:	71 05       	cpc	r23, r1
     2f0:	0c f0       	brlt	.+2      	; 0x2f4 <_fpadd_parts+0xba>
     2f2:	61 c0       	rjmp	.+194    	; 0x3b6 <_fpadd_parts+0x17c>
     2f4:	12 16       	cp	r1, r18
     2f6:	13 06       	cpc	r1, r19
     2f8:	6c f5       	brge	.+90     	; 0x354 <_fpadd_parts+0x11a>
     2fa:	37 01       	movw	r6, r14
     2fc:	48 01       	movw	r8, r16
     2fe:	06 2e       	mov	r0, r22
     300:	04 c0       	rjmp	.+8      	; 0x30a <_fpadd_parts+0xd0>
     302:	96 94       	lsr	r9
     304:	87 94       	ror	r8
     306:	77 94       	ror	r7
     308:	67 94       	ror	r6
     30a:	0a 94       	dec	r0
     30c:	d2 f7       	brpl	.-12     	; 0x302 <_fpadd_parts+0xc8>
     30e:	21 e0       	ldi	r18, 0x01	; 1
     310:	30 e0       	ldi	r19, 0x00	; 0
     312:	40 e0       	ldi	r20, 0x00	; 0
     314:	50 e0       	ldi	r21, 0x00	; 0
     316:	04 c0       	rjmp	.+8      	; 0x320 <_fpadd_parts+0xe6>
     318:	22 0f       	add	r18, r18
     31a:	33 1f       	adc	r19, r19
     31c:	44 1f       	adc	r20, r20
     31e:	55 1f       	adc	r21, r21
     320:	6a 95       	dec	r22
     322:	d2 f7       	brpl	.-12     	; 0x318 <_fpadd_parts+0xde>
     324:	21 50       	subi	r18, 0x01	; 1
     326:	30 40       	sbci	r19, 0x00	; 0
     328:	40 40       	sbci	r20, 0x00	; 0
     32a:	50 40       	sbci	r21, 0x00	; 0
     32c:	2e 21       	and	r18, r14
     32e:	3f 21       	and	r19, r15
     330:	40 23       	and	r20, r16
     332:	51 23       	and	r21, r17
     334:	21 15       	cp	r18, r1
     336:	31 05       	cpc	r19, r1
     338:	41 05       	cpc	r20, r1
     33a:	51 05       	cpc	r21, r1
     33c:	21 f0       	breq	.+8      	; 0x346 <_fpadd_parts+0x10c>
     33e:	21 e0       	ldi	r18, 0x01	; 1
     340:	30 e0       	ldi	r19, 0x00	; 0
     342:	40 e0       	ldi	r20, 0x00	; 0
     344:	50 e0       	ldi	r21, 0x00	; 0
     346:	79 01       	movw	r14, r18
     348:	8a 01       	movw	r16, r20
     34a:	e6 28       	or	r14, r6
     34c:	f7 28       	or	r15, r7
     34e:	08 29       	or	r16, r8
     350:	19 29       	or	r17, r9
     352:	3c c0       	rjmp	.+120    	; 0x3cc <_fpadd_parts+0x192>
     354:	23 2b       	or	r18, r19
     356:	d1 f1       	breq	.+116    	; 0x3cc <_fpadd_parts+0x192>
     358:	26 0e       	add	r2, r22
     35a:	37 1e       	adc	r3, r23
     35c:	35 01       	movw	r6, r10
     35e:	46 01       	movw	r8, r12
     360:	06 2e       	mov	r0, r22
     362:	04 c0       	rjmp	.+8      	; 0x36c <_fpadd_parts+0x132>
     364:	96 94       	lsr	r9
     366:	87 94       	ror	r8
     368:	77 94       	ror	r7
     36a:	67 94       	ror	r6
     36c:	0a 94       	dec	r0
     36e:	d2 f7       	brpl	.-12     	; 0x364 <_fpadd_parts+0x12a>
     370:	21 e0       	ldi	r18, 0x01	; 1
     372:	30 e0       	ldi	r19, 0x00	; 0
     374:	40 e0       	ldi	r20, 0x00	; 0
     376:	50 e0       	ldi	r21, 0x00	; 0
     378:	04 c0       	rjmp	.+8      	; 0x382 <_fpadd_parts+0x148>
     37a:	22 0f       	add	r18, r18
     37c:	33 1f       	adc	r19, r19
     37e:	44 1f       	adc	r20, r20
     380:	55 1f       	adc	r21, r21
     382:	6a 95       	dec	r22
     384:	d2 f7       	brpl	.-12     	; 0x37a <_fpadd_parts+0x140>
     386:	21 50       	subi	r18, 0x01	; 1
     388:	30 40       	sbci	r19, 0x00	; 0
     38a:	40 40       	sbci	r20, 0x00	; 0
     38c:	50 40       	sbci	r21, 0x00	; 0
     38e:	2a 21       	and	r18, r10
     390:	3b 21       	and	r19, r11
     392:	4c 21       	and	r20, r12
     394:	5d 21       	and	r21, r13
     396:	21 15       	cp	r18, r1
     398:	31 05       	cpc	r19, r1
     39a:	41 05       	cpc	r20, r1
     39c:	51 05       	cpc	r21, r1
     39e:	21 f0       	breq	.+8      	; 0x3a8 <_fpadd_parts+0x16e>
     3a0:	21 e0       	ldi	r18, 0x01	; 1
     3a2:	30 e0       	ldi	r19, 0x00	; 0
     3a4:	40 e0       	ldi	r20, 0x00	; 0
     3a6:	50 e0       	ldi	r21, 0x00	; 0
     3a8:	59 01       	movw	r10, r18
     3aa:	6a 01       	movw	r12, r20
     3ac:	a6 28       	or	r10, r6
     3ae:	b7 28       	or	r11, r7
     3b0:	c8 28       	or	r12, r8
     3b2:	d9 28       	or	r13, r9
     3b4:	0b c0       	rjmp	.+22     	; 0x3cc <_fpadd_parts+0x192>
     3b6:	82 15       	cp	r24, r2
     3b8:	93 05       	cpc	r25, r3
     3ba:	2c f0       	brlt	.+10     	; 0x3c6 <_fpadd_parts+0x18c>
     3bc:	1c 01       	movw	r2, r24
     3be:	aa 24       	eor	r10, r10
     3c0:	bb 24       	eor	r11, r11
     3c2:	65 01       	movw	r12, r10
     3c4:	03 c0       	rjmp	.+6      	; 0x3cc <_fpadd_parts+0x192>
     3c6:	ee 24       	eor	r14, r14
     3c8:	ff 24       	eor	r15, r15
     3ca:	87 01       	movw	r16, r14
     3cc:	11 96       	adiw	r26, 0x01	; 1
     3ce:	9c 91       	ld	r25, X
     3d0:	d2 01       	movw	r26, r4
     3d2:	11 96       	adiw	r26, 0x01	; 1
     3d4:	8c 91       	ld	r24, X
     3d6:	98 17       	cp	r25, r24
     3d8:	09 f4       	brne	.+2      	; 0x3dc <_fpadd_parts+0x1a2>
     3da:	45 c0       	rjmp	.+138    	; 0x466 <_fpadd_parts+0x22c>
     3dc:	99 23       	and	r25, r25
     3de:	39 f0       	breq	.+14     	; 0x3ee <_fpadd_parts+0x1b4>
     3e0:	a8 01       	movw	r20, r16
     3e2:	97 01       	movw	r18, r14
     3e4:	2a 19       	sub	r18, r10
     3e6:	3b 09       	sbc	r19, r11
     3e8:	4c 09       	sbc	r20, r12
     3ea:	5d 09       	sbc	r21, r13
     3ec:	06 c0       	rjmp	.+12     	; 0x3fa <_fpadd_parts+0x1c0>
     3ee:	a6 01       	movw	r20, r12
     3f0:	95 01       	movw	r18, r10
     3f2:	2e 19       	sub	r18, r14
     3f4:	3f 09       	sbc	r19, r15
     3f6:	40 0b       	sbc	r20, r16
     3f8:	51 0b       	sbc	r21, r17
     3fa:	57 fd       	sbrc	r21, 7
     3fc:	08 c0       	rjmp	.+16     	; 0x40e <_fpadd_parts+0x1d4>
     3fe:	11 82       	std	Z+1, r1	; 0x01
     400:	33 82       	std	Z+3, r3	; 0x03
     402:	22 82       	std	Z+2, r2	; 0x02
     404:	24 83       	std	Z+4, r18	; 0x04
     406:	35 83       	std	Z+5, r19	; 0x05
     408:	46 83       	std	Z+6, r20	; 0x06
     40a:	57 83       	std	Z+7, r21	; 0x07
     40c:	1d c0       	rjmp	.+58     	; 0x448 <_fpadd_parts+0x20e>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	81 83       	std	Z+1, r24	; 0x01
     412:	33 82       	std	Z+3, r3	; 0x03
     414:	22 82       	std	Z+2, r2	; 0x02
     416:	88 27       	eor	r24, r24
     418:	99 27       	eor	r25, r25
     41a:	dc 01       	movw	r26, r24
     41c:	82 1b       	sub	r24, r18
     41e:	93 0b       	sbc	r25, r19
     420:	a4 0b       	sbc	r26, r20
     422:	b5 0b       	sbc	r27, r21
     424:	84 83       	std	Z+4, r24	; 0x04
     426:	95 83       	std	Z+5, r25	; 0x05
     428:	a6 83       	std	Z+6, r26	; 0x06
     42a:	b7 83       	std	Z+7, r27	; 0x07
     42c:	0d c0       	rjmp	.+26     	; 0x448 <_fpadd_parts+0x20e>
     42e:	22 0f       	add	r18, r18
     430:	33 1f       	adc	r19, r19
     432:	44 1f       	adc	r20, r20
     434:	55 1f       	adc	r21, r21
     436:	24 83       	std	Z+4, r18	; 0x04
     438:	35 83       	std	Z+5, r19	; 0x05
     43a:	46 83       	std	Z+6, r20	; 0x06
     43c:	57 83       	std	Z+7, r21	; 0x07
     43e:	82 81       	ldd	r24, Z+2	; 0x02
     440:	93 81       	ldd	r25, Z+3	; 0x03
     442:	01 97       	sbiw	r24, 0x01	; 1
     444:	93 83       	std	Z+3, r25	; 0x03
     446:	82 83       	std	Z+2, r24	; 0x02
     448:	24 81       	ldd	r18, Z+4	; 0x04
     44a:	35 81       	ldd	r19, Z+5	; 0x05
     44c:	46 81       	ldd	r20, Z+6	; 0x06
     44e:	57 81       	ldd	r21, Z+7	; 0x07
     450:	da 01       	movw	r26, r20
     452:	c9 01       	movw	r24, r18
     454:	01 97       	sbiw	r24, 0x01	; 1
     456:	a1 09       	sbc	r26, r1
     458:	b1 09       	sbc	r27, r1
     45a:	8f 5f       	subi	r24, 0xFF	; 255
     45c:	9f 4f       	sbci	r25, 0xFF	; 255
     45e:	af 4f       	sbci	r26, 0xFF	; 255
     460:	bf 43       	sbci	r27, 0x3F	; 63
     462:	28 f3       	brcs	.-54     	; 0x42e <_fpadd_parts+0x1f4>
     464:	0b c0       	rjmp	.+22     	; 0x47c <_fpadd_parts+0x242>
     466:	91 83       	std	Z+1, r25	; 0x01
     468:	33 82       	std	Z+3, r3	; 0x03
     46a:	22 82       	std	Z+2, r2	; 0x02
     46c:	ea 0c       	add	r14, r10
     46e:	fb 1c       	adc	r15, r11
     470:	0c 1d       	adc	r16, r12
     472:	1d 1d       	adc	r17, r13
     474:	e4 82       	std	Z+4, r14	; 0x04
     476:	f5 82       	std	Z+5, r15	; 0x05
     478:	06 83       	std	Z+6, r16	; 0x06
     47a:	17 83       	std	Z+7, r17	; 0x07
     47c:	83 e0       	ldi	r24, 0x03	; 3
     47e:	80 83       	st	Z, r24
     480:	24 81       	ldd	r18, Z+4	; 0x04
     482:	35 81       	ldd	r19, Z+5	; 0x05
     484:	46 81       	ldd	r20, Z+6	; 0x06
     486:	57 81       	ldd	r21, Z+7	; 0x07
     488:	57 ff       	sbrs	r21, 7
     48a:	1a c0       	rjmp	.+52     	; 0x4c0 <_fpadd_parts+0x286>
     48c:	c9 01       	movw	r24, r18
     48e:	aa 27       	eor	r26, r26
     490:	97 fd       	sbrc	r25, 7
     492:	a0 95       	com	r26
     494:	ba 2f       	mov	r27, r26
     496:	81 70       	andi	r24, 0x01	; 1
     498:	90 70       	andi	r25, 0x00	; 0
     49a:	a0 70       	andi	r26, 0x00	; 0
     49c:	b0 70       	andi	r27, 0x00	; 0
     49e:	56 95       	lsr	r21
     4a0:	47 95       	ror	r20
     4a2:	37 95       	ror	r19
     4a4:	27 95       	ror	r18
     4a6:	82 2b       	or	r24, r18
     4a8:	93 2b       	or	r25, r19
     4aa:	a4 2b       	or	r26, r20
     4ac:	b5 2b       	or	r27, r21
     4ae:	84 83       	std	Z+4, r24	; 0x04
     4b0:	95 83       	std	Z+5, r25	; 0x05
     4b2:	a6 83       	std	Z+6, r26	; 0x06
     4b4:	b7 83       	std	Z+7, r27	; 0x07
     4b6:	82 81       	ldd	r24, Z+2	; 0x02
     4b8:	93 81       	ldd	r25, Z+3	; 0x03
     4ba:	01 96       	adiw	r24, 0x01	; 1
     4bc:	93 83       	std	Z+3, r25	; 0x03
     4be:	82 83       	std	Z+2, r24	; 0x02
     4c0:	df 01       	movw	r26, r30
     4c2:	01 c0       	rjmp	.+2      	; 0x4c6 <_fpadd_parts+0x28c>
     4c4:	d2 01       	movw	r26, r4
     4c6:	cd 01       	movw	r24, r26
     4c8:	cd b7       	in	r28, 0x3d	; 61
     4ca:	de b7       	in	r29, 0x3e	; 62
     4cc:	e2 e1       	ldi	r30, 0x12	; 18
     4ce:	0c 94 fd 3a 	jmp	0x75fa	; 0x75fa <__epilogue_restores__>

000004d2 <__subsf3>:
     4d2:	a0 e2       	ldi	r26, 0x20	; 32
     4d4:	b0 e0       	ldi	r27, 0x00	; 0
     4d6:	ef e6       	ldi	r30, 0x6F	; 111
     4d8:	f2 e0       	ldi	r31, 0x02	; 2
     4da:	0c 94 ed 3a 	jmp	0x75da	; 0x75da <__prologue_saves__+0x18>
     4de:	69 83       	std	Y+1, r22	; 0x01
     4e0:	7a 83       	std	Y+2, r23	; 0x02
     4e2:	8b 83       	std	Y+3, r24	; 0x03
     4e4:	9c 83       	std	Y+4, r25	; 0x04
     4e6:	2d 83       	std	Y+5, r18	; 0x05
     4e8:	3e 83       	std	Y+6, r19	; 0x06
     4ea:	4f 83       	std	Y+7, r20	; 0x07
     4ec:	58 87       	std	Y+8, r21	; 0x08
     4ee:	e9 e0       	ldi	r30, 0x09	; 9
     4f0:	ee 2e       	mov	r14, r30
     4f2:	f1 2c       	mov	r15, r1
     4f4:	ec 0e       	add	r14, r28
     4f6:	fd 1e       	adc	r15, r29
     4f8:	ce 01       	movw	r24, r28
     4fa:	01 96       	adiw	r24, 0x01	; 1
     4fc:	b7 01       	movw	r22, r14
     4fe:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     502:	8e 01       	movw	r16, r28
     504:	0f 5e       	subi	r16, 0xEF	; 239
     506:	1f 4f       	sbci	r17, 0xFF	; 255
     508:	ce 01       	movw	r24, r28
     50a:	05 96       	adiw	r24, 0x05	; 5
     50c:	b8 01       	movw	r22, r16
     50e:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     512:	8a 89       	ldd	r24, Y+18	; 0x12
     514:	91 e0       	ldi	r25, 0x01	; 1
     516:	89 27       	eor	r24, r25
     518:	8a 8b       	std	Y+18, r24	; 0x12
     51a:	c7 01       	movw	r24, r14
     51c:	b8 01       	movw	r22, r16
     51e:	ae 01       	movw	r20, r28
     520:	47 5e       	subi	r20, 0xE7	; 231
     522:	5f 4f       	sbci	r21, 0xFF	; 255
     524:	0e 94 1d 01 	call	0x23a	; 0x23a <_fpadd_parts>
     528:	0e 94 98 06 	call	0xd30	; 0xd30 <__pack_f>
     52c:	a0 96       	adiw	r28, 0x20	; 32
     52e:	e6 e0       	ldi	r30, 0x06	; 6
     530:	0c 94 09 3b 	jmp	0x7612	; 0x7612 <__epilogue_restores__+0x18>

00000534 <__addsf3>:
     534:	a0 e2       	ldi	r26, 0x20	; 32
     536:	b0 e0       	ldi	r27, 0x00	; 0
     538:	e0 ea       	ldi	r30, 0xA0	; 160
     53a:	f2 e0       	ldi	r31, 0x02	; 2
     53c:	0c 94 ed 3a 	jmp	0x75da	; 0x75da <__prologue_saves__+0x18>
     540:	69 83       	std	Y+1, r22	; 0x01
     542:	7a 83       	std	Y+2, r23	; 0x02
     544:	8b 83       	std	Y+3, r24	; 0x03
     546:	9c 83       	std	Y+4, r25	; 0x04
     548:	2d 83       	std	Y+5, r18	; 0x05
     54a:	3e 83       	std	Y+6, r19	; 0x06
     54c:	4f 83       	std	Y+7, r20	; 0x07
     54e:	58 87       	std	Y+8, r21	; 0x08
     550:	f9 e0       	ldi	r31, 0x09	; 9
     552:	ef 2e       	mov	r14, r31
     554:	f1 2c       	mov	r15, r1
     556:	ec 0e       	add	r14, r28
     558:	fd 1e       	adc	r15, r29
     55a:	ce 01       	movw	r24, r28
     55c:	01 96       	adiw	r24, 0x01	; 1
     55e:	b7 01       	movw	r22, r14
     560:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     564:	8e 01       	movw	r16, r28
     566:	0f 5e       	subi	r16, 0xEF	; 239
     568:	1f 4f       	sbci	r17, 0xFF	; 255
     56a:	ce 01       	movw	r24, r28
     56c:	05 96       	adiw	r24, 0x05	; 5
     56e:	b8 01       	movw	r22, r16
     570:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     574:	c7 01       	movw	r24, r14
     576:	b8 01       	movw	r22, r16
     578:	ae 01       	movw	r20, r28
     57a:	47 5e       	subi	r20, 0xE7	; 231
     57c:	5f 4f       	sbci	r21, 0xFF	; 255
     57e:	0e 94 1d 01 	call	0x23a	; 0x23a <_fpadd_parts>
     582:	0e 94 98 06 	call	0xd30	; 0xd30 <__pack_f>
     586:	a0 96       	adiw	r28, 0x20	; 32
     588:	e6 e0       	ldi	r30, 0x06	; 6
     58a:	0c 94 09 3b 	jmp	0x7612	; 0x7612 <__epilogue_restores__+0x18>

0000058e <__mulsf3>:
     58e:	a0 e2       	ldi	r26, 0x20	; 32
     590:	b0 e0       	ldi	r27, 0x00	; 0
     592:	ed ec       	ldi	r30, 0xCD	; 205
     594:	f2 e0       	ldi	r31, 0x02	; 2
     596:	0c 94 e1 3a 	jmp	0x75c2	; 0x75c2 <__prologue_saves__>
     59a:	69 83       	std	Y+1, r22	; 0x01
     59c:	7a 83       	std	Y+2, r23	; 0x02
     59e:	8b 83       	std	Y+3, r24	; 0x03
     5a0:	9c 83       	std	Y+4, r25	; 0x04
     5a2:	2d 83       	std	Y+5, r18	; 0x05
     5a4:	3e 83       	std	Y+6, r19	; 0x06
     5a6:	4f 83       	std	Y+7, r20	; 0x07
     5a8:	58 87       	std	Y+8, r21	; 0x08
     5aa:	ce 01       	movw	r24, r28
     5ac:	01 96       	adiw	r24, 0x01	; 1
     5ae:	be 01       	movw	r22, r28
     5b0:	67 5f       	subi	r22, 0xF7	; 247
     5b2:	7f 4f       	sbci	r23, 0xFF	; 255
     5b4:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     5b8:	ce 01       	movw	r24, r28
     5ba:	05 96       	adiw	r24, 0x05	; 5
     5bc:	be 01       	movw	r22, r28
     5be:	6f 5e       	subi	r22, 0xEF	; 239
     5c0:	7f 4f       	sbci	r23, 0xFF	; 255
     5c2:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     5c6:	99 85       	ldd	r25, Y+9	; 0x09
     5c8:	92 30       	cpi	r25, 0x02	; 2
     5ca:	88 f0       	brcs	.+34     	; 0x5ee <__mulsf3+0x60>
     5cc:	89 89       	ldd	r24, Y+17	; 0x11
     5ce:	82 30       	cpi	r24, 0x02	; 2
     5d0:	c8 f0       	brcs	.+50     	; 0x604 <__mulsf3+0x76>
     5d2:	94 30       	cpi	r25, 0x04	; 4
     5d4:	19 f4       	brne	.+6      	; 0x5dc <__mulsf3+0x4e>
     5d6:	82 30       	cpi	r24, 0x02	; 2
     5d8:	51 f4       	brne	.+20     	; 0x5ee <__mulsf3+0x60>
     5da:	04 c0       	rjmp	.+8      	; 0x5e4 <__mulsf3+0x56>
     5dc:	84 30       	cpi	r24, 0x04	; 4
     5de:	29 f4       	brne	.+10     	; 0x5ea <__mulsf3+0x5c>
     5e0:	92 30       	cpi	r25, 0x02	; 2
     5e2:	81 f4       	brne	.+32     	; 0x604 <__mulsf3+0x76>
     5e4:	88 e6       	ldi	r24, 0x68	; 104
     5e6:	90 e0       	ldi	r25, 0x00	; 0
     5e8:	c6 c0       	rjmp	.+396    	; 0x776 <__mulsf3+0x1e8>
     5ea:	92 30       	cpi	r25, 0x02	; 2
     5ec:	49 f4       	brne	.+18     	; 0x600 <__mulsf3+0x72>
     5ee:	20 e0       	ldi	r18, 0x00	; 0
     5f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     5f2:	8a 89       	ldd	r24, Y+18	; 0x12
     5f4:	98 13       	cpse	r25, r24
     5f6:	21 e0       	ldi	r18, 0x01	; 1
     5f8:	2a 87       	std	Y+10, r18	; 0x0a
     5fa:	ce 01       	movw	r24, r28
     5fc:	09 96       	adiw	r24, 0x09	; 9
     5fe:	bb c0       	rjmp	.+374    	; 0x776 <__mulsf3+0x1e8>
     600:	82 30       	cpi	r24, 0x02	; 2
     602:	49 f4       	brne	.+18     	; 0x616 <__mulsf3+0x88>
     604:	20 e0       	ldi	r18, 0x00	; 0
     606:	9a 85       	ldd	r25, Y+10	; 0x0a
     608:	8a 89       	ldd	r24, Y+18	; 0x12
     60a:	98 13       	cpse	r25, r24
     60c:	21 e0       	ldi	r18, 0x01	; 1
     60e:	2a 8b       	std	Y+18, r18	; 0x12
     610:	ce 01       	movw	r24, r28
     612:	41 96       	adiw	r24, 0x11	; 17
     614:	b0 c0       	rjmp	.+352    	; 0x776 <__mulsf3+0x1e8>
     616:	2d 84       	ldd	r2, Y+13	; 0x0d
     618:	3e 84       	ldd	r3, Y+14	; 0x0e
     61a:	4f 84       	ldd	r4, Y+15	; 0x0f
     61c:	58 88       	ldd	r5, Y+16	; 0x10
     61e:	6d 88       	ldd	r6, Y+21	; 0x15
     620:	7e 88       	ldd	r7, Y+22	; 0x16
     622:	8f 88       	ldd	r8, Y+23	; 0x17
     624:	98 8c       	ldd	r9, Y+24	; 0x18
     626:	ee 24       	eor	r14, r14
     628:	ff 24       	eor	r15, r15
     62a:	87 01       	movw	r16, r14
     62c:	aa 24       	eor	r10, r10
     62e:	bb 24       	eor	r11, r11
     630:	65 01       	movw	r12, r10
     632:	40 e0       	ldi	r20, 0x00	; 0
     634:	50 e0       	ldi	r21, 0x00	; 0
     636:	60 e0       	ldi	r22, 0x00	; 0
     638:	70 e0       	ldi	r23, 0x00	; 0
     63a:	e0 e0       	ldi	r30, 0x00	; 0
     63c:	f0 e0       	ldi	r31, 0x00	; 0
     63e:	c1 01       	movw	r24, r2
     640:	81 70       	andi	r24, 0x01	; 1
     642:	90 70       	andi	r25, 0x00	; 0
     644:	89 2b       	or	r24, r25
     646:	e9 f0       	breq	.+58     	; 0x682 <__mulsf3+0xf4>
     648:	e6 0c       	add	r14, r6
     64a:	f7 1c       	adc	r15, r7
     64c:	08 1d       	adc	r16, r8
     64e:	19 1d       	adc	r17, r9
     650:	9a 01       	movw	r18, r20
     652:	ab 01       	movw	r20, r22
     654:	2a 0d       	add	r18, r10
     656:	3b 1d       	adc	r19, r11
     658:	4c 1d       	adc	r20, r12
     65a:	5d 1d       	adc	r21, r13
     65c:	80 e0       	ldi	r24, 0x00	; 0
     65e:	90 e0       	ldi	r25, 0x00	; 0
     660:	a0 e0       	ldi	r26, 0x00	; 0
     662:	b0 e0       	ldi	r27, 0x00	; 0
     664:	e6 14       	cp	r14, r6
     666:	f7 04       	cpc	r15, r7
     668:	08 05       	cpc	r16, r8
     66a:	19 05       	cpc	r17, r9
     66c:	20 f4       	brcc	.+8      	; 0x676 <__mulsf3+0xe8>
     66e:	81 e0       	ldi	r24, 0x01	; 1
     670:	90 e0       	ldi	r25, 0x00	; 0
     672:	a0 e0       	ldi	r26, 0x00	; 0
     674:	b0 e0       	ldi	r27, 0x00	; 0
     676:	ba 01       	movw	r22, r20
     678:	a9 01       	movw	r20, r18
     67a:	48 0f       	add	r20, r24
     67c:	59 1f       	adc	r21, r25
     67e:	6a 1f       	adc	r22, r26
     680:	7b 1f       	adc	r23, r27
     682:	aa 0c       	add	r10, r10
     684:	bb 1c       	adc	r11, r11
     686:	cc 1c       	adc	r12, r12
     688:	dd 1c       	adc	r13, r13
     68a:	97 fe       	sbrs	r9, 7
     68c:	08 c0       	rjmp	.+16     	; 0x69e <__mulsf3+0x110>
     68e:	81 e0       	ldi	r24, 0x01	; 1
     690:	90 e0       	ldi	r25, 0x00	; 0
     692:	a0 e0       	ldi	r26, 0x00	; 0
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	a8 2a       	or	r10, r24
     698:	b9 2a       	or	r11, r25
     69a:	ca 2a       	or	r12, r26
     69c:	db 2a       	or	r13, r27
     69e:	31 96       	adiw	r30, 0x01	; 1
     6a0:	e0 32       	cpi	r30, 0x20	; 32
     6a2:	f1 05       	cpc	r31, r1
     6a4:	49 f0       	breq	.+18     	; 0x6b8 <__mulsf3+0x12a>
     6a6:	66 0c       	add	r6, r6
     6a8:	77 1c       	adc	r7, r7
     6aa:	88 1c       	adc	r8, r8
     6ac:	99 1c       	adc	r9, r9
     6ae:	56 94       	lsr	r5
     6b0:	47 94       	ror	r4
     6b2:	37 94       	ror	r3
     6b4:	27 94       	ror	r2
     6b6:	c3 cf       	rjmp	.-122    	; 0x63e <__mulsf3+0xb0>
     6b8:	fa 85       	ldd	r31, Y+10	; 0x0a
     6ba:	ea 89       	ldd	r30, Y+18	; 0x12
     6bc:	2b 89       	ldd	r18, Y+19	; 0x13
     6be:	3c 89       	ldd	r19, Y+20	; 0x14
     6c0:	8b 85       	ldd	r24, Y+11	; 0x0b
     6c2:	9c 85       	ldd	r25, Y+12	; 0x0c
     6c4:	28 0f       	add	r18, r24
     6c6:	39 1f       	adc	r19, r25
     6c8:	2e 5f       	subi	r18, 0xFE	; 254
     6ca:	3f 4f       	sbci	r19, 0xFF	; 255
     6cc:	17 c0       	rjmp	.+46     	; 0x6fc <__mulsf3+0x16e>
     6ce:	ca 01       	movw	r24, r20
     6d0:	81 70       	andi	r24, 0x01	; 1
     6d2:	90 70       	andi	r25, 0x00	; 0
     6d4:	89 2b       	or	r24, r25
     6d6:	61 f0       	breq	.+24     	; 0x6f0 <__mulsf3+0x162>
     6d8:	16 95       	lsr	r17
     6da:	07 95       	ror	r16
     6dc:	f7 94       	ror	r15
     6de:	e7 94       	ror	r14
     6e0:	80 e0       	ldi	r24, 0x00	; 0
     6e2:	90 e0       	ldi	r25, 0x00	; 0
     6e4:	a0 e0       	ldi	r26, 0x00	; 0
     6e6:	b0 e8       	ldi	r27, 0x80	; 128
     6e8:	e8 2a       	or	r14, r24
     6ea:	f9 2a       	or	r15, r25
     6ec:	0a 2b       	or	r16, r26
     6ee:	1b 2b       	or	r17, r27
     6f0:	76 95       	lsr	r23
     6f2:	67 95       	ror	r22
     6f4:	57 95       	ror	r21
     6f6:	47 95       	ror	r20
     6f8:	2f 5f       	subi	r18, 0xFF	; 255
     6fa:	3f 4f       	sbci	r19, 0xFF	; 255
     6fc:	77 fd       	sbrc	r23, 7
     6fe:	e7 cf       	rjmp	.-50     	; 0x6ce <__mulsf3+0x140>
     700:	0c c0       	rjmp	.+24     	; 0x71a <__mulsf3+0x18c>
     702:	44 0f       	add	r20, r20
     704:	55 1f       	adc	r21, r21
     706:	66 1f       	adc	r22, r22
     708:	77 1f       	adc	r23, r23
     70a:	17 fd       	sbrc	r17, 7
     70c:	41 60       	ori	r20, 0x01	; 1
     70e:	ee 0c       	add	r14, r14
     710:	ff 1c       	adc	r15, r15
     712:	00 1f       	adc	r16, r16
     714:	11 1f       	adc	r17, r17
     716:	21 50       	subi	r18, 0x01	; 1
     718:	30 40       	sbci	r19, 0x00	; 0
     71a:	40 30       	cpi	r20, 0x00	; 0
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	59 07       	cpc	r21, r25
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	69 07       	cpc	r22, r25
     724:	90 e4       	ldi	r25, 0x40	; 64
     726:	79 07       	cpc	r23, r25
     728:	60 f3       	brcs	.-40     	; 0x702 <__mulsf3+0x174>
     72a:	2b 8f       	std	Y+27, r18	; 0x1b
     72c:	3c 8f       	std	Y+28, r19	; 0x1c
     72e:	db 01       	movw	r26, r22
     730:	ca 01       	movw	r24, r20
     732:	8f 77       	andi	r24, 0x7F	; 127
     734:	90 70       	andi	r25, 0x00	; 0
     736:	a0 70       	andi	r26, 0x00	; 0
     738:	b0 70       	andi	r27, 0x00	; 0
     73a:	80 34       	cpi	r24, 0x40	; 64
     73c:	91 05       	cpc	r25, r1
     73e:	a1 05       	cpc	r26, r1
     740:	b1 05       	cpc	r27, r1
     742:	61 f4       	brne	.+24     	; 0x75c <__mulsf3+0x1ce>
     744:	47 fd       	sbrc	r20, 7
     746:	0a c0       	rjmp	.+20     	; 0x75c <__mulsf3+0x1ce>
     748:	e1 14       	cp	r14, r1
     74a:	f1 04       	cpc	r15, r1
     74c:	01 05       	cpc	r16, r1
     74e:	11 05       	cpc	r17, r1
     750:	29 f0       	breq	.+10     	; 0x75c <__mulsf3+0x1ce>
     752:	40 5c       	subi	r20, 0xC0	; 192
     754:	5f 4f       	sbci	r21, 0xFF	; 255
     756:	6f 4f       	sbci	r22, 0xFF	; 255
     758:	7f 4f       	sbci	r23, 0xFF	; 255
     75a:	40 78       	andi	r20, 0x80	; 128
     75c:	1a 8e       	std	Y+26, r1	; 0x1a
     75e:	fe 17       	cp	r31, r30
     760:	11 f0       	breq	.+4      	; 0x766 <__mulsf3+0x1d8>
     762:	81 e0       	ldi	r24, 0x01	; 1
     764:	8a 8f       	std	Y+26, r24	; 0x1a
     766:	4d 8f       	std	Y+29, r20	; 0x1d
     768:	5e 8f       	std	Y+30, r21	; 0x1e
     76a:	6f 8f       	std	Y+31, r22	; 0x1f
     76c:	78 a3       	std	Y+32, r23	; 0x20
     76e:	83 e0       	ldi	r24, 0x03	; 3
     770:	89 8f       	std	Y+25, r24	; 0x19
     772:	ce 01       	movw	r24, r28
     774:	49 96       	adiw	r24, 0x19	; 25
     776:	0e 94 98 06 	call	0xd30	; 0xd30 <__pack_f>
     77a:	a0 96       	adiw	r28, 0x20	; 32
     77c:	e2 e1       	ldi	r30, 0x12	; 18
     77e:	0c 94 fd 3a 	jmp	0x75fa	; 0x75fa <__epilogue_restores__>

00000782 <__divsf3>:
     782:	a8 e1       	ldi	r26, 0x18	; 24
     784:	b0 e0       	ldi	r27, 0x00	; 0
     786:	e7 ec       	ldi	r30, 0xC7	; 199
     788:	f3 e0       	ldi	r31, 0x03	; 3
     78a:	0c 94 e9 3a 	jmp	0x75d2	; 0x75d2 <__prologue_saves__+0x10>
     78e:	69 83       	std	Y+1, r22	; 0x01
     790:	7a 83       	std	Y+2, r23	; 0x02
     792:	8b 83       	std	Y+3, r24	; 0x03
     794:	9c 83       	std	Y+4, r25	; 0x04
     796:	2d 83       	std	Y+5, r18	; 0x05
     798:	3e 83       	std	Y+6, r19	; 0x06
     79a:	4f 83       	std	Y+7, r20	; 0x07
     79c:	58 87       	std	Y+8, r21	; 0x08
     79e:	b9 e0       	ldi	r27, 0x09	; 9
     7a0:	eb 2e       	mov	r14, r27
     7a2:	f1 2c       	mov	r15, r1
     7a4:	ec 0e       	add	r14, r28
     7a6:	fd 1e       	adc	r15, r29
     7a8:	ce 01       	movw	r24, r28
     7aa:	01 96       	adiw	r24, 0x01	; 1
     7ac:	b7 01       	movw	r22, r14
     7ae:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     7b2:	8e 01       	movw	r16, r28
     7b4:	0f 5e       	subi	r16, 0xEF	; 239
     7b6:	1f 4f       	sbci	r17, 0xFF	; 255
     7b8:	ce 01       	movw	r24, r28
     7ba:	05 96       	adiw	r24, 0x05	; 5
     7bc:	b8 01       	movw	r22, r16
     7be:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     7c2:	29 85       	ldd	r18, Y+9	; 0x09
     7c4:	22 30       	cpi	r18, 0x02	; 2
     7c6:	08 f4       	brcc	.+2      	; 0x7ca <__divsf3+0x48>
     7c8:	7e c0       	rjmp	.+252    	; 0x8c6 <__stack+0x67>
     7ca:	39 89       	ldd	r19, Y+17	; 0x11
     7cc:	32 30       	cpi	r19, 0x02	; 2
     7ce:	10 f4       	brcc	.+4      	; 0x7d4 <__divsf3+0x52>
     7d0:	b8 01       	movw	r22, r16
     7d2:	7c c0       	rjmp	.+248    	; 0x8cc <__stack+0x6d>
     7d4:	8a 85       	ldd	r24, Y+10	; 0x0a
     7d6:	9a 89       	ldd	r25, Y+18	; 0x12
     7d8:	89 27       	eor	r24, r25
     7da:	8a 87       	std	Y+10, r24	; 0x0a
     7dc:	24 30       	cpi	r18, 0x04	; 4
     7de:	11 f0       	breq	.+4      	; 0x7e4 <__divsf3+0x62>
     7e0:	22 30       	cpi	r18, 0x02	; 2
     7e2:	31 f4       	brne	.+12     	; 0x7f0 <__divsf3+0x6e>
     7e4:	23 17       	cp	r18, r19
     7e6:	09 f0       	breq	.+2      	; 0x7ea <__divsf3+0x68>
     7e8:	6e c0       	rjmp	.+220    	; 0x8c6 <__stack+0x67>
     7ea:	68 e6       	ldi	r22, 0x68	; 104
     7ec:	70 e0       	ldi	r23, 0x00	; 0
     7ee:	6e c0       	rjmp	.+220    	; 0x8cc <__stack+0x6d>
     7f0:	34 30       	cpi	r19, 0x04	; 4
     7f2:	39 f4       	brne	.+14     	; 0x802 <__divsf3+0x80>
     7f4:	1d 86       	std	Y+13, r1	; 0x0d
     7f6:	1e 86       	std	Y+14, r1	; 0x0e
     7f8:	1f 86       	std	Y+15, r1	; 0x0f
     7fa:	18 8a       	std	Y+16, r1	; 0x10
     7fc:	1c 86       	std	Y+12, r1	; 0x0c
     7fe:	1b 86       	std	Y+11, r1	; 0x0b
     800:	04 c0       	rjmp	.+8      	; 0x80a <__divsf3+0x88>
     802:	32 30       	cpi	r19, 0x02	; 2
     804:	21 f4       	brne	.+8      	; 0x80e <__divsf3+0x8c>
     806:	84 e0       	ldi	r24, 0x04	; 4
     808:	89 87       	std	Y+9, r24	; 0x09
     80a:	b7 01       	movw	r22, r14
     80c:	5f c0       	rjmp	.+190    	; 0x8cc <__stack+0x6d>
     80e:	2b 85       	ldd	r18, Y+11	; 0x0b
     810:	3c 85       	ldd	r19, Y+12	; 0x0c
     812:	8b 89       	ldd	r24, Y+19	; 0x13
     814:	9c 89       	ldd	r25, Y+20	; 0x14
     816:	28 1b       	sub	r18, r24
     818:	39 0b       	sbc	r19, r25
     81a:	3c 87       	std	Y+12, r19	; 0x0c
     81c:	2b 87       	std	Y+11, r18	; 0x0b
     81e:	ed 84       	ldd	r14, Y+13	; 0x0d
     820:	fe 84       	ldd	r15, Y+14	; 0x0e
     822:	0f 85       	ldd	r16, Y+15	; 0x0f
     824:	18 89       	ldd	r17, Y+16	; 0x10
     826:	ad 88       	ldd	r10, Y+21	; 0x15
     828:	be 88       	ldd	r11, Y+22	; 0x16
     82a:	cf 88       	ldd	r12, Y+23	; 0x17
     82c:	d8 8c       	ldd	r13, Y+24	; 0x18
     82e:	ea 14       	cp	r14, r10
     830:	fb 04       	cpc	r15, r11
     832:	0c 05       	cpc	r16, r12
     834:	1d 05       	cpc	r17, r13
     836:	40 f4       	brcc	.+16     	; 0x848 <__divsf3+0xc6>
     838:	ee 0c       	add	r14, r14
     83a:	ff 1c       	adc	r15, r15
     83c:	00 1f       	adc	r16, r16
     83e:	11 1f       	adc	r17, r17
     840:	21 50       	subi	r18, 0x01	; 1
     842:	30 40       	sbci	r19, 0x00	; 0
     844:	3c 87       	std	Y+12, r19	; 0x0c
     846:	2b 87       	std	Y+11, r18	; 0x0b
     848:	20 e0       	ldi	r18, 0x00	; 0
     84a:	30 e0       	ldi	r19, 0x00	; 0
     84c:	40 e0       	ldi	r20, 0x00	; 0
     84e:	50 e0       	ldi	r21, 0x00	; 0
     850:	80 e0       	ldi	r24, 0x00	; 0
     852:	90 e0       	ldi	r25, 0x00	; 0
     854:	a0 e0       	ldi	r26, 0x00	; 0
     856:	b0 e4       	ldi	r27, 0x40	; 64
     858:	60 e0       	ldi	r22, 0x00	; 0
     85a:	70 e0       	ldi	r23, 0x00	; 0
     85c:	ea 14       	cp	r14, r10
     85e:	fb 04       	cpc	r15, r11
     860:	0c 05       	cpc	r16, r12
     862:	1d 05       	cpc	r17, r13
     864:	40 f0       	brcs	.+16     	; 0x876 <__stack+0x17>
     866:	28 2b       	or	r18, r24
     868:	39 2b       	or	r19, r25
     86a:	4a 2b       	or	r20, r26
     86c:	5b 2b       	or	r21, r27
     86e:	ea 18       	sub	r14, r10
     870:	fb 08       	sbc	r15, r11
     872:	0c 09       	sbc	r16, r12
     874:	1d 09       	sbc	r17, r13
     876:	b6 95       	lsr	r27
     878:	a7 95       	ror	r26
     87a:	97 95       	ror	r25
     87c:	87 95       	ror	r24
     87e:	ee 0c       	add	r14, r14
     880:	ff 1c       	adc	r15, r15
     882:	00 1f       	adc	r16, r16
     884:	11 1f       	adc	r17, r17
     886:	6f 5f       	subi	r22, 0xFF	; 255
     888:	7f 4f       	sbci	r23, 0xFF	; 255
     88a:	6f 31       	cpi	r22, 0x1F	; 31
     88c:	71 05       	cpc	r23, r1
     88e:	31 f7       	brne	.-52     	; 0x85c <__divsf3+0xda>
     890:	da 01       	movw	r26, r20
     892:	c9 01       	movw	r24, r18
     894:	8f 77       	andi	r24, 0x7F	; 127
     896:	90 70       	andi	r25, 0x00	; 0
     898:	a0 70       	andi	r26, 0x00	; 0
     89a:	b0 70       	andi	r27, 0x00	; 0
     89c:	80 34       	cpi	r24, 0x40	; 64
     89e:	91 05       	cpc	r25, r1
     8a0:	a1 05       	cpc	r26, r1
     8a2:	b1 05       	cpc	r27, r1
     8a4:	61 f4       	brne	.+24     	; 0x8be <__stack+0x5f>
     8a6:	27 fd       	sbrc	r18, 7
     8a8:	0a c0       	rjmp	.+20     	; 0x8be <__stack+0x5f>
     8aa:	e1 14       	cp	r14, r1
     8ac:	f1 04       	cpc	r15, r1
     8ae:	01 05       	cpc	r16, r1
     8b0:	11 05       	cpc	r17, r1
     8b2:	29 f0       	breq	.+10     	; 0x8be <__stack+0x5f>
     8b4:	20 5c       	subi	r18, 0xC0	; 192
     8b6:	3f 4f       	sbci	r19, 0xFF	; 255
     8b8:	4f 4f       	sbci	r20, 0xFF	; 255
     8ba:	5f 4f       	sbci	r21, 0xFF	; 255
     8bc:	20 78       	andi	r18, 0x80	; 128
     8be:	2d 87       	std	Y+13, r18	; 0x0d
     8c0:	3e 87       	std	Y+14, r19	; 0x0e
     8c2:	4f 87       	std	Y+15, r20	; 0x0f
     8c4:	58 8b       	std	Y+16, r21	; 0x10
     8c6:	be 01       	movw	r22, r28
     8c8:	67 5f       	subi	r22, 0xF7	; 247
     8ca:	7f 4f       	sbci	r23, 0xFF	; 255
     8cc:	cb 01       	movw	r24, r22
     8ce:	0e 94 98 06 	call	0xd30	; 0xd30 <__pack_f>
     8d2:	68 96       	adiw	r28, 0x18	; 24
     8d4:	ea e0       	ldi	r30, 0x0A	; 10
     8d6:	0c 94 05 3b 	jmp	0x760a	; 0x760a <__epilogue_restores__+0x10>

000008da <__gtsf2>:
     8da:	a8 e1       	ldi	r26, 0x18	; 24
     8dc:	b0 e0       	ldi	r27, 0x00	; 0
     8de:	e3 e7       	ldi	r30, 0x73	; 115
     8e0:	f4 e0       	ldi	r31, 0x04	; 4
     8e2:	0c 94 ed 3a 	jmp	0x75da	; 0x75da <__prologue_saves__+0x18>
     8e6:	69 83       	std	Y+1, r22	; 0x01
     8e8:	7a 83       	std	Y+2, r23	; 0x02
     8ea:	8b 83       	std	Y+3, r24	; 0x03
     8ec:	9c 83       	std	Y+4, r25	; 0x04
     8ee:	2d 83       	std	Y+5, r18	; 0x05
     8f0:	3e 83       	std	Y+6, r19	; 0x06
     8f2:	4f 83       	std	Y+7, r20	; 0x07
     8f4:	58 87       	std	Y+8, r21	; 0x08
     8f6:	89 e0       	ldi	r24, 0x09	; 9
     8f8:	e8 2e       	mov	r14, r24
     8fa:	f1 2c       	mov	r15, r1
     8fc:	ec 0e       	add	r14, r28
     8fe:	fd 1e       	adc	r15, r29
     900:	ce 01       	movw	r24, r28
     902:	01 96       	adiw	r24, 0x01	; 1
     904:	b7 01       	movw	r22, r14
     906:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     90a:	8e 01       	movw	r16, r28
     90c:	0f 5e       	subi	r16, 0xEF	; 239
     90e:	1f 4f       	sbci	r17, 0xFF	; 255
     910:	ce 01       	movw	r24, r28
     912:	05 96       	adiw	r24, 0x05	; 5
     914:	b8 01       	movw	r22, r16
     916:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     91a:	89 85       	ldd	r24, Y+9	; 0x09
     91c:	82 30       	cpi	r24, 0x02	; 2
     91e:	40 f0       	brcs	.+16     	; 0x930 <__gtsf2+0x56>
     920:	89 89       	ldd	r24, Y+17	; 0x11
     922:	82 30       	cpi	r24, 0x02	; 2
     924:	28 f0       	brcs	.+10     	; 0x930 <__gtsf2+0x56>
     926:	c7 01       	movw	r24, r14
     928:	b8 01       	movw	r22, r16
     92a:	0e 94 e5 07 	call	0xfca	; 0xfca <__fpcmp_parts_f>
     92e:	01 c0       	rjmp	.+2      	; 0x932 <__gtsf2+0x58>
     930:	8f ef       	ldi	r24, 0xFF	; 255
     932:	68 96       	adiw	r28, 0x18	; 24
     934:	e6 e0       	ldi	r30, 0x06	; 6
     936:	0c 94 09 3b 	jmp	0x7612	; 0x7612 <__epilogue_restores__+0x18>

0000093a <__gesf2>:
     93a:	a8 e1       	ldi	r26, 0x18	; 24
     93c:	b0 e0       	ldi	r27, 0x00	; 0
     93e:	e3 ea       	ldi	r30, 0xA3	; 163
     940:	f4 e0       	ldi	r31, 0x04	; 4
     942:	0c 94 ed 3a 	jmp	0x75da	; 0x75da <__prologue_saves__+0x18>
     946:	69 83       	std	Y+1, r22	; 0x01
     948:	7a 83       	std	Y+2, r23	; 0x02
     94a:	8b 83       	std	Y+3, r24	; 0x03
     94c:	9c 83       	std	Y+4, r25	; 0x04
     94e:	2d 83       	std	Y+5, r18	; 0x05
     950:	3e 83       	std	Y+6, r19	; 0x06
     952:	4f 83       	std	Y+7, r20	; 0x07
     954:	58 87       	std	Y+8, r21	; 0x08
     956:	89 e0       	ldi	r24, 0x09	; 9
     958:	e8 2e       	mov	r14, r24
     95a:	f1 2c       	mov	r15, r1
     95c:	ec 0e       	add	r14, r28
     95e:	fd 1e       	adc	r15, r29
     960:	ce 01       	movw	r24, r28
     962:	01 96       	adiw	r24, 0x01	; 1
     964:	b7 01       	movw	r22, r14
     966:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     96a:	8e 01       	movw	r16, r28
     96c:	0f 5e       	subi	r16, 0xEF	; 239
     96e:	1f 4f       	sbci	r17, 0xFF	; 255
     970:	ce 01       	movw	r24, r28
     972:	05 96       	adiw	r24, 0x05	; 5
     974:	b8 01       	movw	r22, r16
     976:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     97a:	89 85       	ldd	r24, Y+9	; 0x09
     97c:	82 30       	cpi	r24, 0x02	; 2
     97e:	40 f0       	brcs	.+16     	; 0x990 <__gesf2+0x56>
     980:	89 89       	ldd	r24, Y+17	; 0x11
     982:	82 30       	cpi	r24, 0x02	; 2
     984:	28 f0       	brcs	.+10     	; 0x990 <__gesf2+0x56>
     986:	c7 01       	movw	r24, r14
     988:	b8 01       	movw	r22, r16
     98a:	0e 94 e5 07 	call	0xfca	; 0xfca <__fpcmp_parts_f>
     98e:	01 c0       	rjmp	.+2      	; 0x992 <__gesf2+0x58>
     990:	8f ef       	ldi	r24, 0xFF	; 255
     992:	68 96       	adiw	r28, 0x18	; 24
     994:	e6 e0       	ldi	r30, 0x06	; 6
     996:	0c 94 09 3b 	jmp	0x7612	; 0x7612 <__epilogue_restores__+0x18>

0000099a <__ltsf2>:
     99a:	a8 e1       	ldi	r26, 0x18	; 24
     99c:	b0 e0       	ldi	r27, 0x00	; 0
     99e:	e3 ed       	ldi	r30, 0xD3	; 211
     9a0:	f4 e0       	ldi	r31, 0x04	; 4
     9a2:	0c 94 ed 3a 	jmp	0x75da	; 0x75da <__prologue_saves__+0x18>
     9a6:	69 83       	std	Y+1, r22	; 0x01
     9a8:	7a 83       	std	Y+2, r23	; 0x02
     9aa:	8b 83       	std	Y+3, r24	; 0x03
     9ac:	9c 83       	std	Y+4, r25	; 0x04
     9ae:	2d 83       	std	Y+5, r18	; 0x05
     9b0:	3e 83       	std	Y+6, r19	; 0x06
     9b2:	4f 83       	std	Y+7, r20	; 0x07
     9b4:	58 87       	std	Y+8, r21	; 0x08
     9b6:	89 e0       	ldi	r24, 0x09	; 9
     9b8:	e8 2e       	mov	r14, r24
     9ba:	f1 2c       	mov	r15, r1
     9bc:	ec 0e       	add	r14, r28
     9be:	fd 1e       	adc	r15, r29
     9c0:	ce 01       	movw	r24, r28
     9c2:	01 96       	adiw	r24, 0x01	; 1
     9c4:	b7 01       	movw	r22, r14
     9c6:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     9ca:	8e 01       	movw	r16, r28
     9cc:	0f 5e       	subi	r16, 0xEF	; 239
     9ce:	1f 4f       	sbci	r17, 0xFF	; 255
     9d0:	ce 01       	movw	r24, r28
     9d2:	05 96       	adiw	r24, 0x05	; 5
     9d4:	b8 01       	movw	r22, r16
     9d6:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     9da:	89 85       	ldd	r24, Y+9	; 0x09
     9dc:	82 30       	cpi	r24, 0x02	; 2
     9de:	40 f0       	brcs	.+16     	; 0x9f0 <__ltsf2+0x56>
     9e0:	89 89       	ldd	r24, Y+17	; 0x11
     9e2:	82 30       	cpi	r24, 0x02	; 2
     9e4:	28 f0       	brcs	.+10     	; 0x9f0 <__ltsf2+0x56>
     9e6:	c7 01       	movw	r24, r14
     9e8:	b8 01       	movw	r22, r16
     9ea:	0e 94 e5 07 	call	0xfca	; 0xfca <__fpcmp_parts_f>
     9ee:	01 c0       	rjmp	.+2      	; 0x9f2 <__ltsf2+0x58>
     9f0:	81 e0       	ldi	r24, 0x01	; 1
     9f2:	68 96       	adiw	r28, 0x18	; 24
     9f4:	e6 e0       	ldi	r30, 0x06	; 6
     9f6:	0c 94 09 3b 	jmp	0x7612	; 0x7612 <__epilogue_restores__+0x18>

000009fa <__fixsfsi>:
     9fa:	ac e0       	ldi	r26, 0x0C	; 12
     9fc:	b0 e0       	ldi	r27, 0x00	; 0
     9fe:	e3 e0       	ldi	r30, 0x03	; 3
     a00:	f5 e0       	ldi	r31, 0x05	; 5
     a02:	0c 94 f1 3a 	jmp	0x75e2	; 0x75e2 <__prologue_saves__+0x20>
     a06:	69 83       	std	Y+1, r22	; 0x01
     a08:	7a 83       	std	Y+2, r23	; 0x02
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	9c 83       	std	Y+4, r25	; 0x04
     a0e:	ce 01       	movw	r24, r28
     a10:	01 96       	adiw	r24, 0x01	; 1
     a12:	be 01       	movw	r22, r28
     a14:	6b 5f       	subi	r22, 0xFB	; 251
     a16:	7f 4f       	sbci	r23, 0xFF	; 255
     a18:	0e 94 6d 07 	call	0xeda	; 0xeda <__unpack_f>
     a1c:	8d 81       	ldd	r24, Y+5	; 0x05
     a1e:	82 30       	cpi	r24, 0x02	; 2
     a20:	61 f1       	breq	.+88     	; 0xa7a <__fixsfsi+0x80>
     a22:	82 30       	cpi	r24, 0x02	; 2
     a24:	50 f1       	brcs	.+84     	; 0xa7a <__fixsfsi+0x80>
     a26:	84 30       	cpi	r24, 0x04	; 4
     a28:	21 f4       	brne	.+8      	; 0xa32 <__fixsfsi+0x38>
     a2a:	8e 81       	ldd	r24, Y+6	; 0x06
     a2c:	88 23       	and	r24, r24
     a2e:	51 f1       	breq	.+84     	; 0xa84 <__fixsfsi+0x8a>
     a30:	2e c0       	rjmp	.+92     	; 0xa8e <__fixsfsi+0x94>
     a32:	2f 81       	ldd	r18, Y+7	; 0x07
     a34:	38 85       	ldd	r19, Y+8	; 0x08
     a36:	37 fd       	sbrc	r19, 7
     a38:	20 c0       	rjmp	.+64     	; 0xa7a <__fixsfsi+0x80>
     a3a:	6e 81       	ldd	r22, Y+6	; 0x06
     a3c:	2f 31       	cpi	r18, 0x1F	; 31
     a3e:	31 05       	cpc	r19, r1
     a40:	1c f0       	brlt	.+6      	; 0xa48 <__fixsfsi+0x4e>
     a42:	66 23       	and	r22, r22
     a44:	f9 f0       	breq	.+62     	; 0xa84 <__fixsfsi+0x8a>
     a46:	23 c0       	rjmp	.+70     	; 0xa8e <__fixsfsi+0x94>
     a48:	8e e1       	ldi	r24, 0x1E	; 30
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	82 1b       	sub	r24, r18
     a4e:	93 0b       	sbc	r25, r19
     a50:	29 85       	ldd	r18, Y+9	; 0x09
     a52:	3a 85       	ldd	r19, Y+10	; 0x0a
     a54:	4b 85       	ldd	r20, Y+11	; 0x0b
     a56:	5c 85       	ldd	r21, Y+12	; 0x0c
     a58:	04 c0       	rjmp	.+8      	; 0xa62 <__fixsfsi+0x68>
     a5a:	56 95       	lsr	r21
     a5c:	47 95       	ror	r20
     a5e:	37 95       	ror	r19
     a60:	27 95       	ror	r18
     a62:	8a 95       	dec	r24
     a64:	d2 f7       	brpl	.-12     	; 0xa5a <__fixsfsi+0x60>
     a66:	66 23       	and	r22, r22
     a68:	b1 f0       	breq	.+44     	; 0xa96 <__fixsfsi+0x9c>
     a6a:	50 95       	com	r21
     a6c:	40 95       	com	r20
     a6e:	30 95       	com	r19
     a70:	21 95       	neg	r18
     a72:	3f 4f       	sbci	r19, 0xFF	; 255
     a74:	4f 4f       	sbci	r20, 0xFF	; 255
     a76:	5f 4f       	sbci	r21, 0xFF	; 255
     a78:	0e c0       	rjmp	.+28     	; 0xa96 <__fixsfsi+0x9c>
     a7a:	20 e0       	ldi	r18, 0x00	; 0
     a7c:	30 e0       	ldi	r19, 0x00	; 0
     a7e:	40 e0       	ldi	r20, 0x00	; 0
     a80:	50 e0       	ldi	r21, 0x00	; 0
     a82:	09 c0       	rjmp	.+18     	; 0xa96 <__fixsfsi+0x9c>
     a84:	2f ef       	ldi	r18, 0xFF	; 255
     a86:	3f ef       	ldi	r19, 0xFF	; 255
     a88:	4f ef       	ldi	r20, 0xFF	; 255
     a8a:	5f e7       	ldi	r21, 0x7F	; 127
     a8c:	04 c0       	rjmp	.+8      	; 0xa96 <__fixsfsi+0x9c>
     a8e:	20 e0       	ldi	r18, 0x00	; 0
     a90:	30 e0       	ldi	r19, 0x00	; 0
     a92:	40 e0       	ldi	r20, 0x00	; 0
     a94:	50 e8       	ldi	r21, 0x80	; 128
     a96:	b9 01       	movw	r22, r18
     a98:	ca 01       	movw	r24, r20
     a9a:	2c 96       	adiw	r28, 0x0c	; 12
     a9c:	e2 e0       	ldi	r30, 0x02	; 2
     a9e:	0c 94 0d 3b 	jmp	0x761a	; 0x761a <__epilogue_restores__+0x20>

00000aa2 <__floatunsisf>:
     aa2:	a8 e0       	ldi	r26, 0x08	; 8
     aa4:	b0 e0       	ldi	r27, 0x00	; 0
     aa6:	e7 e5       	ldi	r30, 0x57	; 87
     aa8:	f5 e0       	ldi	r31, 0x05	; 5
     aaa:	0c 94 e9 3a 	jmp	0x75d2	; 0x75d2 <__prologue_saves__+0x10>
     aae:	7b 01       	movw	r14, r22
     ab0:	8c 01       	movw	r16, r24
     ab2:	61 15       	cp	r22, r1
     ab4:	71 05       	cpc	r23, r1
     ab6:	81 05       	cpc	r24, r1
     ab8:	91 05       	cpc	r25, r1
     aba:	19 f4       	brne	.+6      	; 0xac2 <__floatunsisf+0x20>
     abc:	82 e0       	ldi	r24, 0x02	; 2
     abe:	89 83       	std	Y+1, r24	; 0x01
     ac0:	60 c0       	rjmp	.+192    	; 0xb82 <__floatunsisf+0xe0>
     ac2:	83 e0       	ldi	r24, 0x03	; 3
     ac4:	89 83       	std	Y+1, r24	; 0x01
     ac6:	8e e1       	ldi	r24, 0x1E	; 30
     ac8:	c8 2e       	mov	r12, r24
     aca:	d1 2c       	mov	r13, r1
     acc:	dc 82       	std	Y+4, r13	; 0x04
     ace:	cb 82       	std	Y+3, r12	; 0x03
     ad0:	ed 82       	std	Y+5, r14	; 0x05
     ad2:	fe 82       	std	Y+6, r15	; 0x06
     ad4:	0f 83       	std	Y+7, r16	; 0x07
     ad6:	18 87       	std	Y+8, r17	; 0x08
     ad8:	c8 01       	movw	r24, r16
     ada:	b7 01       	movw	r22, r14
     adc:	0e 94 49 06 	call	0xc92	; 0xc92 <__clzsi2>
     ae0:	fc 01       	movw	r30, r24
     ae2:	31 97       	sbiw	r30, 0x01	; 1
     ae4:	f7 ff       	sbrs	r31, 7
     ae6:	3b c0       	rjmp	.+118    	; 0xb5e <__floatunsisf+0xbc>
     ae8:	22 27       	eor	r18, r18
     aea:	33 27       	eor	r19, r19
     aec:	2e 1b       	sub	r18, r30
     aee:	3f 0b       	sbc	r19, r31
     af0:	57 01       	movw	r10, r14
     af2:	68 01       	movw	r12, r16
     af4:	02 2e       	mov	r0, r18
     af6:	04 c0       	rjmp	.+8      	; 0xb00 <__floatunsisf+0x5e>
     af8:	d6 94       	lsr	r13
     afa:	c7 94       	ror	r12
     afc:	b7 94       	ror	r11
     afe:	a7 94       	ror	r10
     b00:	0a 94       	dec	r0
     b02:	d2 f7       	brpl	.-12     	; 0xaf8 <__floatunsisf+0x56>
     b04:	40 e0       	ldi	r20, 0x00	; 0
     b06:	50 e0       	ldi	r21, 0x00	; 0
     b08:	60 e0       	ldi	r22, 0x00	; 0
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	81 e0       	ldi	r24, 0x01	; 1
     b0e:	90 e0       	ldi	r25, 0x00	; 0
     b10:	a0 e0       	ldi	r26, 0x00	; 0
     b12:	b0 e0       	ldi	r27, 0x00	; 0
     b14:	04 c0       	rjmp	.+8      	; 0xb1e <__floatunsisf+0x7c>
     b16:	88 0f       	add	r24, r24
     b18:	99 1f       	adc	r25, r25
     b1a:	aa 1f       	adc	r26, r26
     b1c:	bb 1f       	adc	r27, r27
     b1e:	2a 95       	dec	r18
     b20:	d2 f7       	brpl	.-12     	; 0xb16 <__floatunsisf+0x74>
     b22:	01 97       	sbiw	r24, 0x01	; 1
     b24:	a1 09       	sbc	r26, r1
     b26:	b1 09       	sbc	r27, r1
     b28:	8e 21       	and	r24, r14
     b2a:	9f 21       	and	r25, r15
     b2c:	a0 23       	and	r26, r16
     b2e:	b1 23       	and	r27, r17
     b30:	00 97       	sbiw	r24, 0x00	; 0
     b32:	a1 05       	cpc	r26, r1
     b34:	b1 05       	cpc	r27, r1
     b36:	21 f0       	breq	.+8      	; 0xb40 <__floatunsisf+0x9e>
     b38:	41 e0       	ldi	r20, 0x01	; 1
     b3a:	50 e0       	ldi	r21, 0x00	; 0
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	4a 29       	or	r20, r10
     b42:	5b 29       	or	r21, r11
     b44:	6c 29       	or	r22, r12
     b46:	7d 29       	or	r23, r13
     b48:	4d 83       	std	Y+5, r20	; 0x05
     b4a:	5e 83       	std	Y+6, r21	; 0x06
     b4c:	6f 83       	std	Y+7, r22	; 0x07
     b4e:	78 87       	std	Y+8, r23	; 0x08
     b50:	8e e1       	ldi	r24, 0x1E	; 30
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	8e 1b       	sub	r24, r30
     b56:	9f 0b       	sbc	r25, r31
     b58:	9c 83       	std	Y+4, r25	; 0x04
     b5a:	8b 83       	std	Y+3, r24	; 0x03
     b5c:	12 c0       	rjmp	.+36     	; 0xb82 <__floatunsisf+0xe0>
     b5e:	30 97       	sbiw	r30, 0x00	; 0
     b60:	81 f0       	breq	.+32     	; 0xb82 <__floatunsisf+0xe0>
     b62:	0e 2e       	mov	r0, r30
     b64:	04 c0       	rjmp	.+8      	; 0xb6e <__floatunsisf+0xcc>
     b66:	ee 0c       	add	r14, r14
     b68:	ff 1c       	adc	r15, r15
     b6a:	00 1f       	adc	r16, r16
     b6c:	11 1f       	adc	r17, r17
     b6e:	0a 94       	dec	r0
     b70:	d2 f7       	brpl	.-12     	; 0xb66 <__floatunsisf+0xc4>
     b72:	ed 82       	std	Y+5, r14	; 0x05
     b74:	fe 82       	std	Y+6, r15	; 0x06
     b76:	0f 83       	std	Y+7, r16	; 0x07
     b78:	18 87       	std	Y+8, r17	; 0x08
     b7a:	ce 1a       	sub	r12, r30
     b7c:	df 0a       	sbc	r13, r31
     b7e:	dc 82       	std	Y+4, r13	; 0x04
     b80:	cb 82       	std	Y+3, r12	; 0x03
     b82:	1a 82       	std	Y+2, r1	; 0x02
     b84:	ce 01       	movw	r24, r28
     b86:	01 96       	adiw	r24, 0x01	; 1
     b88:	0e 94 98 06 	call	0xd30	; 0xd30 <__pack_f>
     b8c:	28 96       	adiw	r28, 0x08	; 8
     b8e:	ea e0       	ldi	r30, 0x0A	; 10
     b90:	0c 94 05 3b 	jmp	0x760a	; 0x760a <__epilogue_restores__+0x10>

00000b94 <__ashldi3>:
     b94:	ef 92       	push	r14
     b96:	ff 92       	push	r15
     b98:	0f 93       	push	r16
     b9a:	df 93       	push	r29
     b9c:	cf 93       	push	r28
     b9e:	cd b7       	in	r28, 0x3d	; 61
     ba0:	de b7       	in	r29, 0x3e	; 62
     ba2:	60 97       	sbiw	r28, 0x10	; 16
     ba4:	0f b6       	in	r0, 0x3f	; 63
     ba6:	f8 94       	cli
     ba8:	de bf       	out	0x3e, r29	; 62
     baa:	0f be       	out	0x3f, r0	; 63
     bac:	cd bf       	out	0x3d, r28	; 61
     bae:	a8 2f       	mov	r26, r24
     bb0:	00 23       	and	r16, r16
     bb2:	09 f4       	brne	.+2      	; 0xbb6 <__ashldi3+0x22>
     bb4:	61 c0       	rjmp	.+194    	; 0xc78 <__ashldi3+0xe4>
     bb6:	7e 01       	movw	r14, r28
     bb8:	08 94       	sec
     bba:	e1 1c       	adc	r14, r1
     bbc:	f1 1c       	adc	r15, r1
     bbe:	88 e0       	ldi	r24, 0x08	; 8
     bc0:	f7 01       	movw	r30, r14
     bc2:	11 92       	st	Z+, r1
     bc4:	8a 95       	dec	r24
     bc6:	e9 f7       	brne	.-6      	; 0xbc2 <__ashldi3+0x2e>
     bc8:	29 83       	std	Y+1, r18	; 0x01
     bca:	3a 83       	std	Y+2, r19	; 0x02
     bcc:	4b 83       	std	Y+3, r20	; 0x03
     bce:	5c 83       	std	Y+4, r21	; 0x04
     bd0:	6d 83       	std	Y+5, r22	; 0x05
     bd2:	7e 83       	std	Y+6, r23	; 0x06
     bd4:	af 83       	std	Y+7, r26	; 0x07
     bd6:	98 87       	std	Y+8, r25	; 0x08
     bd8:	80 e2       	ldi	r24, 0x20	; 32
     bda:	80 1b       	sub	r24, r16
     bdc:	e8 2f       	mov	r30, r24
     bde:	ff 27       	eor	r31, r31
     be0:	e7 fd       	sbrc	r30, 7
     be2:	f0 95       	com	r31
     be4:	49 81       	ldd	r20, Y+1	; 0x01
     be6:	5a 81       	ldd	r21, Y+2	; 0x02
     be8:	6b 81       	ldd	r22, Y+3	; 0x03
     bea:	7c 81       	ldd	r23, Y+4	; 0x04
     bec:	18 16       	cp	r1, r24
     bee:	84 f0       	brlt	.+32     	; 0xc10 <__ashldi3+0x7c>
     bf0:	19 86       	std	Y+9, r1	; 0x09
     bf2:	1a 86       	std	Y+10, r1	; 0x0a
     bf4:	1b 86       	std	Y+11, r1	; 0x0b
     bf6:	1c 86       	std	Y+12, r1	; 0x0c
     bf8:	88 27       	eor	r24, r24
     bfa:	99 27       	eor	r25, r25
     bfc:	8e 1b       	sub	r24, r30
     bfe:	9f 0b       	sbc	r25, r31
     c00:	04 c0       	rjmp	.+8      	; 0xc0a <__ashldi3+0x76>
     c02:	44 0f       	add	r20, r20
     c04:	55 1f       	adc	r21, r21
     c06:	66 1f       	adc	r22, r22
     c08:	77 1f       	adc	r23, r23
     c0a:	8a 95       	dec	r24
     c0c:	d2 f7       	brpl	.-12     	; 0xc02 <__ashldi3+0x6e>
     c0e:	28 c0       	rjmp	.+80     	; 0xc60 <__ashldi3+0xcc>
     c10:	20 2f       	mov	r18, r16
     c12:	33 27       	eor	r19, r19
     c14:	27 fd       	sbrc	r18, 7
     c16:	30 95       	com	r19
     c18:	db 01       	movw	r26, r22
     c1a:	ca 01       	movw	r24, r20
     c1c:	02 2e       	mov	r0, r18
     c1e:	04 c0       	rjmp	.+8      	; 0xc28 <__ashldi3+0x94>
     c20:	88 0f       	add	r24, r24
     c22:	99 1f       	adc	r25, r25
     c24:	aa 1f       	adc	r26, r26
     c26:	bb 1f       	adc	r27, r27
     c28:	0a 94       	dec	r0
     c2a:	d2 f7       	brpl	.-12     	; 0xc20 <__ashldi3+0x8c>
     c2c:	89 87       	std	Y+9, r24	; 0x09
     c2e:	9a 87       	std	Y+10, r25	; 0x0a
     c30:	ab 87       	std	Y+11, r26	; 0x0b
     c32:	bc 87       	std	Y+12, r27	; 0x0c
     c34:	04 c0       	rjmp	.+8      	; 0xc3e <__ashldi3+0xaa>
     c36:	76 95       	lsr	r23
     c38:	67 95       	ror	r22
     c3a:	57 95       	ror	r21
     c3c:	47 95       	ror	r20
     c3e:	ea 95       	dec	r30
     c40:	d2 f7       	brpl	.-12     	; 0xc36 <__ashldi3+0xa2>
     c42:	8d 81       	ldd	r24, Y+5	; 0x05
     c44:	9e 81       	ldd	r25, Y+6	; 0x06
     c46:	af 81       	ldd	r26, Y+7	; 0x07
     c48:	b8 85       	ldd	r27, Y+8	; 0x08
     c4a:	04 c0       	rjmp	.+8      	; 0xc54 <__ashldi3+0xc0>
     c4c:	88 0f       	add	r24, r24
     c4e:	99 1f       	adc	r25, r25
     c50:	aa 1f       	adc	r26, r26
     c52:	bb 1f       	adc	r27, r27
     c54:	2a 95       	dec	r18
     c56:	d2 f7       	brpl	.-12     	; 0xc4c <__ashldi3+0xb8>
     c58:	48 2b       	or	r20, r24
     c5a:	59 2b       	or	r21, r25
     c5c:	6a 2b       	or	r22, r26
     c5e:	7b 2b       	or	r23, r27
     c60:	4d 87       	std	Y+13, r20	; 0x0d
     c62:	5e 87       	std	Y+14, r21	; 0x0e
     c64:	6f 87       	std	Y+15, r22	; 0x0f
     c66:	78 8b       	std	Y+16, r23	; 0x10
     c68:	29 85       	ldd	r18, Y+9	; 0x09
     c6a:	3a 85       	ldd	r19, Y+10	; 0x0a
     c6c:	4b 85       	ldd	r20, Y+11	; 0x0b
     c6e:	5c 85       	ldd	r21, Y+12	; 0x0c
     c70:	6d 85       	ldd	r22, Y+13	; 0x0d
     c72:	7e 85       	ldd	r23, Y+14	; 0x0e
     c74:	af 85       	ldd	r26, Y+15	; 0x0f
     c76:	98 89       	ldd	r25, Y+16	; 0x10
     c78:	8a 2f       	mov	r24, r26
     c7a:	60 96       	adiw	r28, 0x10	; 16
     c7c:	0f b6       	in	r0, 0x3f	; 63
     c7e:	f8 94       	cli
     c80:	de bf       	out	0x3e, r29	; 62
     c82:	0f be       	out	0x3f, r0	; 63
     c84:	cd bf       	out	0x3d, r28	; 61
     c86:	cf 91       	pop	r28
     c88:	df 91       	pop	r29
     c8a:	0f 91       	pop	r16
     c8c:	ff 90       	pop	r15
     c8e:	ef 90       	pop	r14
     c90:	08 95       	ret

00000c92 <__clzsi2>:
     c92:	ef 92       	push	r14
     c94:	ff 92       	push	r15
     c96:	0f 93       	push	r16
     c98:	1f 93       	push	r17
     c9a:	7b 01       	movw	r14, r22
     c9c:	8c 01       	movw	r16, r24
     c9e:	80 e0       	ldi	r24, 0x00	; 0
     ca0:	e8 16       	cp	r14, r24
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	f8 06       	cpc	r15, r24
     ca6:	81 e0       	ldi	r24, 0x01	; 1
     ca8:	08 07       	cpc	r16, r24
     caa:	80 e0       	ldi	r24, 0x00	; 0
     cac:	18 07       	cpc	r17, r24
     cae:	88 f4       	brcc	.+34     	; 0xcd2 <__clzsi2+0x40>
     cb0:	8f ef       	ldi	r24, 0xFF	; 255
     cb2:	e8 16       	cp	r14, r24
     cb4:	f1 04       	cpc	r15, r1
     cb6:	01 05       	cpc	r16, r1
     cb8:	11 05       	cpc	r17, r1
     cba:	31 f0       	breq	.+12     	; 0xcc8 <__clzsi2+0x36>
     cbc:	28 f0       	brcs	.+10     	; 0xcc8 <__clzsi2+0x36>
     cbe:	88 e0       	ldi	r24, 0x08	; 8
     cc0:	90 e0       	ldi	r25, 0x00	; 0
     cc2:	a0 e0       	ldi	r26, 0x00	; 0
     cc4:	b0 e0       	ldi	r27, 0x00	; 0
     cc6:	17 c0       	rjmp	.+46     	; 0xcf6 <__clzsi2+0x64>
     cc8:	80 e0       	ldi	r24, 0x00	; 0
     cca:	90 e0       	ldi	r25, 0x00	; 0
     ccc:	a0 e0       	ldi	r26, 0x00	; 0
     cce:	b0 e0       	ldi	r27, 0x00	; 0
     cd0:	12 c0       	rjmp	.+36     	; 0xcf6 <__clzsi2+0x64>
     cd2:	80 e0       	ldi	r24, 0x00	; 0
     cd4:	e8 16       	cp	r14, r24
     cd6:	80 e0       	ldi	r24, 0x00	; 0
     cd8:	f8 06       	cpc	r15, r24
     cda:	80 e0       	ldi	r24, 0x00	; 0
     cdc:	08 07       	cpc	r16, r24
     cde:	81 e0       	ldi	r24, 0x01	; 1
     ce0:	18 07       	cpc	r17, r24
     ce2:	28 f0       	brcs	.+10     	; 0xcee <__clzsi2+0x5c>
     ce4:	88 e1       	ldi	r24, 0x18	; 24
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	a0 e0       	ldi	r26, 0x00	; 0
     cea:	b0 e0       	ldi	r27, 0x00	; 0
     cec:	04 c0       	rjmp	.+8      	; 0xcf6 <__clzsi2+0x64>
     cee:	80 e1       	ldi	r24, 0x10	; 16
     cf0:	90 e0       	ldi	r25, 0x00	; 0
     cf2:	a0 e0       	ldi	r26, 0x00	; 0
     cf4:	b0 e0       	ldi	r27, 0x00	; 0
     cf6:	20 e2       	ldi	r18, 0x20	; 32
     cf8:	30 e0       	ldi	r19, 0x00	; 0
     cfa:	40 e0       	ldi	r20, 0x00	; 0
     cfc:	50 e0       	ldi	r21, 0x00	; 0
     cfe:	28 1b       	sub	r18, r24
     d00:	39 0b       	sbc	r19, r25
     d02:	4a 0b       	sbc	r20, r26
     d04:	5b 0b       	sbc	r21, r27
     d06:	04 c0       	rjmp	.+8      	; 0xd10 <__clzsi2+0x7e>
     d08:	16 95       	lsr	r17
     d0a:	07 95       	ror	r16
     d0c:	f7 94       	ror	r15
     d0e:	e7 94       	ror	r14
     d10:	8a 95       	dec	r24
     d12:	d2 f7       	brpl	.-12     	; 0xd08 <__clzsi2+0x76>
     d14:	f7 01       	movw	r30, r14
     d16:	e0 59       	subi	r30, 0x90	; 144
     d18:	ff 4f       	sbci	r31, 0xFF	; 255
     d1a:	80 81       	ld	r24, Z
     d1c:	28 1b       	sub	r18, r24
     d1e:	31 09       	sbc	r19, r1
     d20:	41 09       	sbc	r20, r1
     d22:	51 09       	sbc	r21, r1
     d24:	c9 01       	movw	r24, r18
     d26:	1f 91       	pop	r17
     d28:	0f 91       	pop	r16
     d2a:	ff 90       	pop	r15
     d2c:	ef 90       	pop	r14
     d2e:	08 95       	ret

00000d30 <__pack_f>:
     d30:	df 92       	push	r13
     d32:	ef 92       	push	r14
     d34:	ff 92       	push	r15
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	fc 01       	movw	r30, r24
     d3c:	e4 80       	ldd	r14, Z+4	; 0x04
     d3e:	f5 80       	ldd	r15, Z+5	; 0x05
     d40:	06 81       	ldd	r16, Z+6	; 0x06
     d42:	17 81       	ldd	r17, Z+7	; 0x07
     d44:	d1 80       	ldd	r13, Z+1	; 0x01
     d46:	80 81       	ld	r24, Z
     d48:	82 30       	cpi	r24, 0x02	; 2
     d4a:	48 f4       	brcc	.+18     	; 0xd5e <__pack_f+0x2e>
     d4c:	80 e0       	ldi	r24, 0x00	; 0
     d4e:	90 e0       	ldi	r25, 0x00	; 0
     d50:	a0 e1       	ldi	r26, 0x10	; 16
     d52:	b0 e0       	ldi	r27, 0x00	; 0
     d54:	e8 2a       	or	r14, r24
     d56:	f9 2a       	or	r15, r25
     d58:	0a 2b       	or	r16, r26
     d5a:	1b 2b       	or	r17, r27
     d5c:	a5 c0       	rjmp	.+330    	; 0xea8 <__pack_f+0x178>
     d5e:	84 30       	cpi	r24, 0x04	; 4
     d60:	09 f4       	brne	.+2      	; 0xd64 <__pack_f+0x34>
     d62:	9f c0       	rjmp	.+318    	; 0xea2 <__pack_f+0x172>
     d64:	82 30       	cpi	r24, 0x02	; 2
     d66:	21 f4       	brne	.+8      	; 0xd70 <__pack_f+0x40>
     d68:	ee 24       	eor	r14, r14
     d6a:	ff 24       	eor	r15, r15
     d6c:	87 01       	movw	r16, r14
     d6e:	05 c0       	rjmp	.+10     	; 0xd7a <__pack_f+0x4a>
     d70:	e1 14       	cp	r14, r1
     d72:	f1 04       	cpc	r15, r1
     d74:	01 05       	cpc	r16, r1
     d76:	11 05       	cpc	r17, r1
     d78:	19 f4       	brne	.+6      	; 0xd80 <__pack_f+0x50>
     d7a:	e0 e0       	ldi	r30, 0x00	; 0
     d7c:	f0 e0       	ldi	r31, 0x00	; 0
     d7e:	96 c0       	rjmp	.+300    	; 0xeac <__pack_f+0x17c>
     d80:	62 81       	ldd	r22, Z+2	; 0x02
     d82:	73 81       	ldd	r23, Z+3	; 0x03
     d84:	9f ef       	ldi	r25, 0xFF	; 255
     d86:	62 38       	cpi	r22, 0x82	; 130
     d88:	79 07       	cpc	r23, r25
     d8a:	0c f0       	brlt	.+2      	; 0xd8e <__pack_f+0x5e>
     d8c:	5b c0       	rjmp	.+182    	; 0xe44 <__pack_f+0x114>
     d8e:	22 e8       	ldi	r18, 0x82	; 130
     d90:	3f ef       	ldi	r19, 0xFF	; 255
     d92:	26 1b       	sub	r18, r22
     d94:	37 0b       	sbc	r19, r23
     d96:	2a 31       	cpi	r18, 0x1A	; 26
     d98:	31 05       	cpc	r19, r1
     d9a:	2c f0       	brlt	.+10     	; 0xda6 <__pack_f+0x76>
     d9c:	20 e0       	ldi	r18, 0x00	; 0
     d9e:	30 e0       	ldi	r19, 0x00	; 0
     da0:	40 e0       	ldi	r20, 0x00	; 0
     da2:	50 e0       	ldi	r21, 0x00	; 0
     da4:	2a c0       	rjmp	.+84     	; 0xdfa <__pack_f+0xca>
     da6:	b8 01       	movw	r22, r16
     da8:	a7 01       	movw	r20, r14
     daa:	02 2e       	mov	r0, r18
     dac:	04 c0       	rjmp	.+8      	; 0xdb6 <__pack_f+0x86>
     dae:	76 95       	lsr	r23
     db0:	67 95       	ror	r22
     db2:	57 95       	ror	r21
     db4:	47 95       	ror	r20
     db6:	0a 94       	dec	r0
     db8:	d2 f7       	brpl	.-12     	; 0xdae <__pack_f+0x7e>
     dba:	81 e0       	ldi	r24, 0x01	; 1
     dbc:	90 e0       	ldi	r25, 0x00	; 0
     dbe:	a0 e0       	ldi	r26, 0x00	; 0
     dc0:	b0 e0       	ldi	r27, 0x00	; 0
     dc2:	04 c0       	rjmp	.+8      	; 0xdcc <__pack_f+0x9c>
     dc4:	88 0f       	add	r24, r24
     dc6:	99 1f       	adc	r25, r25
     dc8:	aa 1f       	adc	r26, r26
     dca:	bb 1f       	adc	r27, r27
     dcc:	2a 95       	dec	r18
     dce:	d2 f7       	brpl	.-12     	; 0xdc4 <__pack_f+0x94>
     dd0:	01 97       	sbiw	r24, 0x01	; 1
     dd2:	a1 09       	sbc	r26, r1
     dd4:	b1 09       	sbc	r27, r1
     dd6:	8e 21       	and	r24, r14
     dd8:	9f 21       	and	r25, r15
     dda:	a0 23       	and	r26, r16
     ddc:	b1 23       	and	r27, r17
     dde:	00 97       	sbiw	r24, 0x00	; 0
     de0:	a1 05       	cpc	r26, r1
     de2:	b1 05       	cpc	r27, r1
     de4:	21 f0       	breq	.+8      	; 0xdee <__pack_f+0xbe>
     de6:	81 e0       	ldi	r24, 0x01	; 1
     de8:	90 e0       	ldi	r25, 0x00	; 0
     dea:	a0 e0       	ldi	r26, 0x00	; 0
     dec:	b0 e0       	ldi	r27, 0x00	; 0
     dee:	9a 01       	movw	r18, r20
     df0:	ab 01       	movw	r20, r22
     df2:	28 2b       	or	r18, r24
     df4:	39 2b       	or	r19, r25
     df6:	4a 2b       	or	r20, r26
     df8:	5b 2b       	or	r21, r27
     dfa:	da 01       	movw	r26, r20
     dfc:	c9 01       	movw	r24, r18
     dfe:	8f 77       	andi	r24, 0x7F	; 127
     e00:	90 70       	andi	r25, 0x00	; 0
     e02:	a0 70       	andi	r26, 0x00	; 0
     e04:	b0 70       	andi	r27, 0x00	; 0
     e06:	80 34       	cpi	r24, 0x40	; 64
     e08:	91 05       	cpc	r25, r1
     e0a:	a1 05       	cpc	r26, r1
     e0c:	b1 05       	cpc	r27, r1
     e0e:	39 f4       	brne	.+14     	; 0xe1e <__pack_f+0xee>
     e10:	27 ff       	sbrs	r18, 7
     e12:	09 c0       	rjmp	.+18     	; 0xe26 <__pack_f+0xf6>
     e14:	20 5c       	subi	r18, 0xC0	; 192
     e16:	3f 4f       	sbci	r19, 0xFF	; 255
     e18:	4f 4f       	sbci	r20, 0xFF	; 255
     e1a:	5f 4f       	sbci	r21, 0xFF	; 255
     e1c:	04 c0       	rjmp	.+8      	; 0xe26 <__pack_f+0xf6>
     e1e:	21 5c       	subi	r18, 0xC1	; 193
     e20:	3f 4f       	sbci	r19, 0xFF	; 255
     e22:	4f 4f       	sbci	r20, 0xFF	; 255
     e24:	5f 4f       	sbci	r21, 0xFF	; 255
     e26:	e0 e0       	ldi	r30, 0x00	; 0
     e28:	f0 e0       	ldi	r31, 0x00	; 0
     e2a:	20 30       	cpi	r18, 0x00	; 0
     e2c:	a0 e0       	ldi	r26, 0x00	; 0
     e2e:	3a 07       	cpc	r19, r26
     e30:	a0 e0       	ldi	r26, 0x00	; 0
     e32:	4a 07       	cpc	r20, r26
     e34:	a0 e4       	ldi	r26, 0x40	; 64
     e36:	5a 07       	cpc	r21, r26
     e38:	10 f0       	brcs	.+4      	; 0xe3e <__pack_f+0x10e>
     e3a:	e1 e0       	ldi	r30, 0x01	; 1
     e3c:	f0 e0       	ldi	r31, 0x00	; 0
     e3e:	79 01       	movw	r14, r18
     e40:	8a 01       	movw	r16, r20
     e42:	27 c0       	rjmp	.+78     	; 0xe92 <__pack_f+0x162>
     e44:	60 38       	cpi	r22, 0x80	; 128
     e46:	71 05       	cpc	r23, r1
     e48:	64 f5       	brge	.+88     	; 0xea2 <__pack_f+0x172>
     e4a:	fb 01       	movw	r30, r22
     e4c:	e1 58       	subi	r30, 0x81	; 129
     e4e:	ff 4f       	sbci	r31, 0xFF	; 255
     e50:	d8 01       	movw	r26, r16
     e52:	c7 01       	movw	r24, r14
     e54:	8f 77       	andi	r24, 0x7F	; 127
     e56:	90 70       	andi	r25, 0x00	; 0
     e58:	a0 70       	andi	r26, 0x00	; 0
     e5a:	b0 70       	andi	r27, 0x00	; 0
     e5c:	80 34       	cpi	r24, 0x40	; 64
     e5e:	91 05       	cpc	r25, r1
     e60:	a1 05       	cpc	r26, r1
     e62:	b1 05       	cpc	r27, r1
     e64:	39 f4       	brne	.+14     	; 0xe74 <__pack_f+0x144>
     e66:	e7 fe       	sbrs	r14, 7
     e68:	0d c0       	rjmp	.+26     	; 0xe84 <__pack_f+0x154>
     e6a:	80 e4       	ldi	r24, 0x40	; 64
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	a0 e0       	ldi	r26, 0x00	; 0
     e70:	b0 e0       	ldi	r27, 0x00	; 0
     e72:	04 c0       	rjmp	.+8      	; 0xe7c <__pack_f+0x14c>
     e74:	8f e3       	ldi	r24, 0x3F	; 63
     e76:	90 e0       	ldi	r25, 0x00	; 0
     e78:	a0 e0       	ldi	r26, 0x00	; 0
     e7a:	b0 e0       	ldi	r27, 0x00	; 0
     e7c:	e8 0e       	add	r14, r24
     e7e:	f9 1e       	adc	r15, r25
     e80:	0a 1f       	adc	r16, r26
     e82:	1b 1f       	adc	r17, r27
     e84:	17 ff       	sbrs	r17, 7
     e86:	05 c0       	rjmp	.+10     	; 0xe92 <__pack_f+0x162>
     e88:	16 95       	lsr	r17
     e8a:	07 95       	ror	r16
     e8c:	f7 94       	ror	r15
     e8e:	e7 94       	ror	r14
     e90:	31 96       	adiw	r30, 0x01	; 1
     e92:	87 e0       	ldi	r24, 0x07	; 7
     e94:	16 95       	lsr	r17
     e96:	07 95       	ror	r16
     e98:	f7 94       	ror	r15
     e9a:	e7 94       	ror	r14
     e9c:	8a 95       	dec	r24
     e9e:	d1 f7       	brne	.-12     	; 0xe94 <__pack_f+0x164>
     ea0:	05 c0       	rjmp	.+10     	; 0xeac <__pack_f+0x17c>
     ea2:	ee 24       	eor	r14, r14
     ea4:	ff 24       	eor	r15, r15
     ea6:	87 01       	movw	r16, r14
     ea8:	ef ef       	ldi	r30, 0xFF	; 255
     eaa:	f0 e0       	ldi	r31, 0x00	; 0
     eac:	6e 2f       	mov	r22, r30
     eae:	67 95       	ror	r22
     eb0:	66 27       	eor	r22, r22
     eb2:	67 95       	ror	r22
     eb4:	90 2f       	mov	r25, r16
     eb6:	9f 77       	andi	r25, 0x7F	; 127
     eb8:	d7 94       	ror	r13
     eba:	dd 24       	eor	r13, r13
     ebc:	d7 94       	ror	r13
     ebe:	8e 2f       	mov	r24, r30
     ec0:	86 95       	lsr	r24
     ec2:	49 2f       	mov	r20, r25
     ec4:	46 2b       	or	r20, r22
     ec6:	58 2f       	mov	r21, r24
     ec8:	5d 29       	or	r21, r13
     eca:	b7 01       	movw	r22, r14
     ecc:	ca 01       	movw	r24, r20
     ece:	1f 91       	pop	r17
     ed0:	0f 91       	pop	r16
     ed2:	ff 90       	pop	r15
     ed4:	ef 90       	pop	r14
     ed6:	df 90       	pop	r13
     ed8:	08 95       	ret

00000eda <__unpack_f>:
     eda:	fc 01       	movw	r30, r24
     edc:	db 01       	movw	r26, r22
     ede:	40 81       	ld	r20, Z
     ee0:	51 81       	ldd	r21, Z+1	; 0x01
     ee2:	22 81       	ldd	r18, Z+2	; 0x02
     ee4:	62 2f       	mov	r22, r18
     ee6:	6f 77       	andi	r22, 0x7F	; 127
     ee8:	70 e0       	ldi	r23, 0x00	; 0
     eea:	22 1f       	adc	r18, r18
     eec:	22 27       	eor	r18, r18
     eee:	22 1f       	adc	r18, r18
     ef0:	93 81       	ldd	r25, Z+3	; 0x03
     ef2:	89 2f       	mov	r24, r25
     ef4:	88 0f       	add	r24, r24
     ef6:	82 2b       	or	r24, r18
     ef8:	28 2f       	mov	r18, r24
     efa:	30 e0       	ldi	r19, 0x00	; 0
     efc:	99 1f       	adc	r25, r25
     efe:	99 27       	eor	r25, r25
     f00:	99 1f       	adc	r25, r25
     f02:	11 96       	adiw	r26, 0x01	; 1
     f04:	9c 93       	st	X, r25
     f06:	11 97       	sbiw	r26, 0x01	; 1
     f08:	21 15       	cp	r18, r1
     f0a:	31 05       	cpc	r19, r1
     f0c:	a9 f5       	brne	.+106    	; 0xf78 <__unpack_f+0x9e>
     f0e:	41 15       	cp	r20, r1
     f10:	51 05       	cpc	r21, r1
     f12:	61 05       	cpc	r22, r1
     f14:	71 05       	cpc	r23, r1
     f16:	11 f4       	brne	.+4      	; 0xf1c <__unpack_f+0x42>
     f18:	82 e0       	ldi	r24, 0x02	; 2
     f1a:	37 c0       	rjmp	.+110    	; 0xf8a <__unpack_f+0xb0>
     f1c:	82 e8       	ldi	r24, 0x82	; 130
     f1e:	9f ef       	ldi	r25, 0xFF	; 255
     f20:	13 96       	adiw	r26, 0x03	; 3
     f22:	9c 93       	st	X, r25
     f24:	8e 93       	st	-X, r24
     f26:	12 97       	sbiw	r26, 0x02	; 2
     f28:	9a 01       	movw	r18, r20
     f2a:	ab 01       	movw	r20, r22
     f2c:	67 e0       	ldi	r22, 0x07	; 7
     f2e:	22 0f       	add	r18, r18
     f30:	33 1f       	adc	r19, r19
     f32:	44 1f       	adc	r20, r20
     f34:	55 1f       	adc	r21, r21
     f36:	6a 95       	dec	r22
     f38:	d1 f7       	brne	.-12     	; 0xf2e <__unpack_f+0x54>
     f3a:	83 e0       	ldi	r24, 0x03	; 3
     f3c:	8c 93       	st	X, r24
     f3e:	0d c0       	rjmp	.+26     	; 0xf5a <__unpack_f+0x80>
     f40:	22 0f       	add	r18, r18
     f42:	33 1f       	adc	r19, r19
     f44:	44 1f       	adc	r20, r20
     f46:	55 1f       	adc	r21, r21
     f48:	12 96       	adiw	r26, 0x02	; 2
     f4a:	8d 91       	ld	r24, X+
     f4c:	9c 91       	ld	r25, X
     f4e:	13 97       	sbiw	r26, 0x03	; 3
     f50:	01 97       	sbiw	r24, 0x01	; 1
     f52:	13 96       	adiw	r26, 0x03	; 3
     f54:	9c 93       	st	X, r25
     f56:	8e 93       	st	-X, r24
     f58:	12 97       	sbiw	r26, 0x02	; 2
     f5a:	20 30       	cpi	r18, 0x00	; 0
     f5c:	80 e0       	ldi	r24, 0x00	; 0
     f5e:	38 07       	cpc	r19, r24
     f60:	80 e0       	ldi	r24, 0x00	; 0
     f62:	48 07       	cpc	r20, r24
     f64:	80 e4       	ldi	r24, 0x40	; 64
     f66:	58 07       	cpc	r21, r24
     f68:	58 f3       	brcs	.-42     	; 0xf40 <__unpack_f+0x66>
     f6a:	14 96       	adiw	r26, 0x04	; 4
     f6c:	2d 93       	st	X+, r18
     f6e:	3d 93       	st	X+, r19
     f70:	4d 93       	st	X+, r20
     f72:	5c 93       	st	X, r21
     f74:	17 97       	sbiw	r26, 0x07	; 7
     f76:	08 95       	ret
     f78:	2f 3f       	cpi	r18, 0xFF	; 255
     f7a:	31 05       	cpc	r19, r1
     f7c:	79 f4       	brne	.+30     	; 0xf9c <__unpack_f+0xc2>
     f7e:	41 15       	cp	r20, r1
     f80:	51 05       	cpc	r21, r1
     f82:	61 05       	cpc	r22, r1
     f84:	71 05       	cpc	r23, r1
     f86:	19 f4       	brne	.+6      	; 0xf8e <__unpack_f+0xb4>
     f88:	84 e0       	ldi	r24, 0x04	; 4
     f8a:	8c 93       	st	X, r24
     f8c:	08 95       	ret
     f8e:	64 ff       	sbrs	r22, 4
     f90:	03 c0       	rjmp	.+6      	; 0xf98 <__unpack_f+0xbe>
     f92:	81 e0       	ldi	r24, 0x01	; 1
     f94:	8c 93       	st	X, r24
     f96:	12 c0       	rjmp	.+36     	; 0xfbc <__unpack_f+0xe2>
     f98:	1c 92       	st	X, r1
     f9a:	10 c0       	rjmp	.+32     	; 0xfbc <__unpack_f+0xe2>
     f9c:	2f 57       	subi	r18, 0x7F	; 127
     f9e:	30 40       	sbci	r19, 0x00	; 0
     fa0:	13 96       	adiw	r26, 0x03	; 3
     fa2:	3c 93       	st	X, r19
     fa4:	2e 93       	st	-X, r18
     fa6:	12 97       	sbiw	r26, 0x02	; 2
     fa8:	83 e0       	ldi	r24, 0x03	; 3
     faa:	8c 93       	st	X, r24
     fac:	87 e0       	ldi	r24, 0x07	; 7
     fae:	44 0f       	add	r20, r20
     fb0:	55 1f       	adc	r21, r21
     fb2:	66 1f       	adc	r22, r22
     fb4:	77 1f       	adc	r23, r23
     fb6:	8a 95       	dec	r24
     fb8:	d1 f7       	brne	.-12     	; 0xfae <__unpack_f+0xd4>
     fba:	70 64       	ori	r23, 0x40	; 64
     fbc:	14 96       	adiw	r26, 0x04	; 4
     fbe:	4d 93       	st	X+, r20
     fc0:	5d 93       	st	X+, r21
     fc2:	6d 93       	st	X+, r22
     fc4:	7c 93       	st	X, r23
     fc6:	17 97       	sbiw	r26, 0x07	; 7
     fc8:	08 95       	ret

00000fca <__fpcmp_parts_f>:
     fca:	1f 93       	push	r17
     fcc:	dc 01       	movw	r26, r24
     fce:	fb 01       	movw	r30, r22
     fd0:	9c 91       	ld	r25, X
     fd2:	92 30       	cpi	r25, 0x02	; 2
     fd4:	08 f4       	brcc	.+2      	; 0xfd8 <__fpcmp_parts_f+0xe>
     fd6:	47 c0       	rjmp	.+142    	; 0x1066 <__fpcmp_parts_f+0x9c>
     fd8:	80 81       	ld	r24, Z
     fda:	82 30       	cpi	r24, 0x02	; 2
     fdc:	08 f4       	brcc	.+2      	; 0xfe0 <__fpcmp_parts_f+0x16>
     fde:	43 c0       	rjmp	.+134    	; 0x1066 <__fpcmp_parts_f+0x9c>
     fe0:	94 30       	cpi	r25, 0x04	; 4
     fe2:	51 f4       	brne	.+20     	; 0xff8 <__fpcmp_parts_f+0x2e>
     fe4:	11 96       	adiw	r26, 0x01	; 1
     fe6:	1c 91       	ld	r17, X
     fe8:	84 30       	cpi	r24, 0x04	; 4
     fea:	99 f5       	brne	.+102    	; 0x1052 <__fpcmp_parts_f+0x88>
     fec:	81 81       	ldd	r24, Z+1	; 0x01
     fee:	68 2f       	mov	r22, r24
     ff0:	70 e0       	ldi	r23, 0x00	; 0
     ff2:	61 1b       	sub	r22, r17
     ff4:	71 09       	sbc	r23, r1
     ff6:	3f c0       	rjmp	.+126    	; 0x1076 <__fpcmp_parts_f+0xac>
     ff8:	84 30       	cpi	r24, 0x04	; 4
     ffa:	21 f0       	breq	.+8      	; 0x1004 <__fpcmp_parts_f+0x3a>
     ffc:	92 30       	cpi	r25, 0x02	; 2
     ffe:	31 f4       	brne	.+12     	; 0x100c <__fpcmp_parts_f+0x42>
    1000:	82 30       	cpi	r24, 0x02	; 2
    1002:	b9 f1       	breq	.+110    	; 0x1072 <__fpcmp_parts_f+0xa8>
    1004:	81 81       	ldd	r24, Z+1	; 0x01
    1006:	88 23       	and	r24, r24
    1008:	89 f1       	breq	.+98     	; 0x106c <__fpcmp_parts_f+0xa2>
    100a:	2d c0       	rjmp	.+90     	; 0x1066 <__fpcmp_parts_f+0x9c>
    100c:	11 96       	adiw	r26, 0x01	; 1
    100e:	1c 91       	ld	r17, X
    1010:	11 97       	sbiw	r26, 0x01	; 1
    1012:	82 30       	cpi	r24, 0x02	; 2
    1014:	f1 f0       	breq	.+60     	; 0x1052 <__fpcmp_parts_f+0x88>
    1016:	81 81       	ldd	r24, Z+1	; 0x01
    1018:	18 17       	cp	r17, r24
    101a:	d9 f4       	brne	.+54     	; 0x1052 <__fpcmp_parts_f+0x88>
    101c:	12 96       	adiw	r26, 0x02	; 2
    101e:	2d 91       	ld	r18, X+
    1020:	3c 91       	ld	r19, X
    1022:	13 97       	sbiw	r26, 0x03	; 3
    1024:	82 81       	ldd	r24, Z+2	; 0x02
    1026:	93 81       	ldd	r25, Z+3	; 0x03
    1028:	82 17       	cp	r24, r18
    102a:	93 07       	cpc	r25, r19
    102c:	94 f0       	brlt	.+36     	; 0x1052 <__fpcmp_parts_f+0x88>
    102e:	28 17       	cp	r18, r24
    1030:	39 07       	cpc	r19, r25
    1032:	bc f0       	brlt	.+46     	; 0x1062 <__fpcmp_parts_f+0x98>
    1034:	14 96       	adiw	r26, 0x04	; 4
    1036:	8d 91       	ld	r24, X+
    1038:	9d 91       	ld	r25, X+
    103a:	0d 90       	ld	r0, X+
    103c:	bc 91       	ld	r27, X
    103e:	a0 2d       	mov	r26, r0
    1040:	24 81       	ldd	r18, Z+4	; 0x04
    1042:	35 81       	ldd	r19, Z+5	; 0x05
    1044:	46 81       	ldd	r20, Z+6	; 0x06
    1046:	57 81       	ldd	r21, Z+7	; 0x07
    1048:	28 17       	cp	r18, r24
    104a:	39 07       	cpc	r19, r25
    104c:	4a 07       	cpc	r20, r26
    104e:	5b 07       	cpc	r21, r27
    1050:	18 f4       	brcc	.+6      	; 0x1058 <__fpcmp_parts_f+0x8e>
    1052:	11 23       	and	r17, r17
    1054:	41 f0       	breq	.+16     	; 0x1066 <__fpcmp_parts_f+0x9c>
    1056:	0a c0       	rjmp	.+20     	; 0x106c <__fpcmp_parts_f+0xa2>
    1058:	82 17       	cp	r24, r18
    105a:	93 07       	cpc	r25, r19
    105c:	a4 07       	cpc	r26, r20
    105e:	b5 07       	cpc	r27, r21
    1060:	40 f4       	brcc	.+16     	; 0x1072 <__fpcmp_parts_f+0xa8>
    1062:	11 23       	and	r17, r17
    1064:	19 f0       	breq	.+6      	; 0x106c <__fpcmp_parts_f+0xa2>
    1066:	61 e0       	ldi	r22, 0x01	; 1
    1068:	70 e0       	ldi	r23, 0x00	; 0
    106a:	05 c0       	rjmp	.+10     	; 0x1076 <__fpcmp_parts_f+0xac>
    106c:	6f ef       	ldi	r22, 0xFF	; 255
    106e:	7f ef       	ldi	r23, 0xFF	; 255
    1070:	02 c0       	rjmp	.+4      	; 0x1076 <__fpcmp_parts_f+0xac>
    1072:	60 e0       	ldi	r22, 0x00	; 0
    1074:	70 e0       	ldi	r23, 0x00	; 0
    1076:	cb 01       	movw	r24, r22
    1078:	1f 91       	pop	r17
    107a:	08 95       	ret

0000107c <USART_voidInit>:

#define BAUD_NS_PRESCALE   (((F_SYS / (BAUD_RATE * 16UL))) - 1)
#define BAUD_DS_PRESCALE   (((F_SYS / (BAUD_RATE * 8UL))) - 1)
#define BAUD_SYNC_PRESCALE (((F_SYS / (BAUD_RATE * 2UL))) - 1)

void USART_voidInit(void){
    107c:	df 93       	push	r29
    107e:	cf 93       	push	r28
    1080:	0f 92       	push	r0
    1082:	cd b7       	in	r28, 0x3d	; 61
    1084:	de b7       	in	r29, 0x3e	; 62
	u8 local_UCSRC_REG;
	/* Turn on/off transmission and reception */
#if TX_STATE == TX_ENABLED
	SET_BIT(UCSRB_REG, UCSRB_TXEN);
    1086:	aa e2       	ldi	r26, 0x2A	; 42
    1088:	b0 e0       	ldi	r27, 0x00	; 0
    108a:	ea e2       	ldi	r30, 0x2A	; 42
    108c:	f0 e0       	ldi	r31, 0x00	; 0
    108e:	80 81       	ld	r24, Z
    1090:	88 60       	ori	r24, 0x08	; 8
    1092:	8c 93       	st	X, r24
#elif TX_STATE == TX_DISABLED
	CLR_BIT(UCSRB_REG, UCSRB_TXEN);
#endif
#if RX_STATE == RX_ENABLED
	SET_BIT(UCSRB_REG, UCSRB_RXEN);
    1094:	aa e2       	ldi	r26, 0x2A	; 42
    1096:	b0 e0       	ldi	r27, 0x00	; 0
    1098:	ea e2       	ldi	r30, 0x2A	; 42
    109a:	f0 e0       	ldi	r31, 0x00	; 0
    109c:	80 81       	ld	r24, Z
    109e:	80 61       	ori	r24, 0x10	; 16
    10a0:	8c 93       	st	X, r24
#elif RX_STATE == RX_DISABLED
	CLR_BIT(UCSRB_REG, UCSRB_RXEN);
#endif

	/*Enable write on UCSR-C*/
	SET_BIT(local_UCSRC_REG,UCSRC_URSEL);
    10a2:	89 81       	ldd	r24, Y+1	; 0x01
    10a4:	80 68       	ori	r24, 0x80	; 128
    10a6:	89 83       	std	Y+1, r24	; 0x01
	/* Data Size*/
#if DATA_SIZE == DATA_SIZE_8_BIT
	CLR_BIT(local_UCSRC_REG, UCSRB_UCSZ2);
    10a8:	89 81       	ldd	r24, Y+1	; 0x01
    10aa:	8b 7f       	andi	r24, 0xFB	; 251
    10ac:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(local_UCSRC_REG, UCSRC_UCSZ1);
    10ae:	89 81       	ldd	r24, Y+1	; 0x01
    10b0:	84 60       	ori	r24, 0x04	; 4
    10b2:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(local_UCSRC_REG, UCSRC_UCSZ0);
    10b4:	89 81       	ldd	r24, Y+1	; 0x01
    10b6:	82 60       	ori	r24, 0x02	; 2
    10b8:	89 83       	std	Y+1, r24	; 0x01
	UCSRC_REG = local_UCSRC_REG;
    10ba:	e0 e4       	ldi	r30, 0x40	; 64
    10bc:	f0 e0       	ldi	r31, 0x00	; 0
    10be:	89 81       	ldd	r24, Y+1	; 0x01
    10c0:	80 83       	st	Z, r24
	UCSRC_REG = local_UCSRC_REG;
#endif

	/*Communication Mode ASync/Sync */
#if MODE == ASYNC_MODE
	CLR_BIT(local_UCSRC_REG, UCSRC_UMSEL);
    10c2:	89 81       	ldd	r24, Y+1	; 0x01
    10c4:	8f 7b       	andi	r24, 0xBF	; 191
    10c6:	89 83       	std	Y+1, r24	; 0x01
	UCSRC_REG = local_UCSRC_REG;
    10c8:	e0 e4       	ldi	r30, 0x40	; 64
    10ca:	f0 e0       	ldi	r31, 0x00	; 0
    10cc:	89 81       	ldd	r24, Y+1	; 0x01
    10ce:	80 83       	st	Z, r24
	UCSRC_REG = local_UCSRC_REG;
#endif

	/* PARITY Selection */
#if PARITY==PARITY_DISABLED
	CLR_BIT(local_UCSRC_REG, UCSRC_UPM1);
    10d0:	89 81       	ldd	r24, Y+1	; 0x01
    10d2:	8f 7d       	andi	r24, 0xDF	; 223
    10d4:	89 83       	std	Y+1, r24	; 0x01
	CLR_BIT(local_UCSRC_REG, UCSRC_UPM0);
    10d6:	89 81       	ldd	r24, Y+1	; 0x01
    10d8:	8f 7e       	andi	r24, 0xEF	; 239
    10da:	89 83       	std	Y+1, r24	; 0x01
	UCSRC_REG = local_UCSRC_REG;
    10dc:	e0 e4       	ldi	r30, 0x40	; 64
    10de:	f0 e0       	ldi	r31, 0x00	; 0
    10e0:	89 81       	ldd	r24, Y+1	; 0x01
    10e2:	80 83       	st	Z, r24
	UCSRC_REG = local_UCSRC_REG;
#endif

	/* Stop Bits*/
#if STOP_BIT==STOP_1_BIT
	CLR_BIT(local_UCSRC_REG, UCSRC_USBS);
    10e4:	89 81       	ldd	r24, Y+1	; 0x01
    10e6:	87 7f       	andi	r24, 0xF7	; 247
    10e8:	89 83       	std	Y+1, r24	; 0x01
	UCSRC_REG = local_UCSRC_REG;
    10ea:	e0 e4       	ldi	r30, 0x40	; 64
    10ec:	f0 e0       	ldi	r31, 0x00	; 0
    10ee:	89 81       	ldd	r24, Y+1	; 0x01
    10f0:	80 83       	st	Z, r24
	SET_BIT(local_UCSRC_REG, UCSRC_USBS);
	UCSRC_REG = local_UCSRC_REG;
#endif

	/*Enable write on UBRR*/
	CLR_BIT(local_UCSRC_REG, UCSRC_URSEL);
    10f2:	89 81       	ldd	r24, Y+1	; 0x01
    10f4:	8f 77       	andi	r24, 0x7F	; 127
    10f6:	89 83       	std	Y+1, r24	; 0x01
	UCSRC_REG = local_UCSRC_REG;
    10f8:	e0 e4       	ldi	r30, 0x40	; 64
    10fa:	f0 e0       	ldi	r31, 0x00	; 0
    10fc:	89 81       	ldd	r24, Y+1	; 0x01
    10fe:	80 83       	st	Z, r24
	/* Speed Mode + Baud Rate */
#if SPEED_MODE == NORMAL_SPEED
	CLR_BIT(UCSRA_REG,UCSRA_U2X);
    1100:	ab e2       	ldi	r26, 0x2B	; 43
    1102:	b0 e0       	ldi	r27, 0x00	; 0
    1104:	eb e2       	ldi	r30, 0x2B	; 43
    1106:	f0 e0       	ldi	r31, 0x00	; 0
    1108:	80 81       	ld	r24, Z
    110a:	8d 7f       	andi	r24, 0xFD	; 253
    110c:	8c 93       	st	X, r24
	UBRRL_REG = BAUD_NS_PRESCALE;
    110e:	e9 e2       	ldi	r30, 0x29	; 41
    1110:	f0 e0       	ldi	r31, 0x00	; 0
    1112:	87 e6       	ldi	r24, 0x67	; 103
    1114:	80 83       	st	Z, r24
	UBRRH_REG = (BAUD_NS_PRESCALE >> 8);
    1116:	e0 e4       	ldi	r30, 0x40	; 64
    1118:	f0 e0       	ldi	r31, 0x00	; 0
    111a:	10 82       	st	Z, r1
	UBRRH_REG = (BAUD_DS_PRESCALE >> 8);
#elif MODE == SYNC_MODE
	UBRRL_REG = BAUD_SYNC_PRESCALE;
	UBRRH_REG = (BAUD_SYNC_PRESCALE >> 8);
#endif
}
    111c:	0f 90       	pop	r0
    111e:	cf 91       	pop	r28
    1120:	df 91       	pop	r29
    1122:	08 95       	ret

00001124 <USART_voidTransmitData>:

void USART_voidTransmitData(u16 copy_u16Data){
    1124:	df 93       	push	r29
    1126:	cf 93       	push	r28
    1128:	00 d0       	rcall	.+0      	; 0x112a <USART_voidTransmitData+0x6>
    112a:	cd b7       	in	r28, 0x3d	; 61
    112c:	de b7       	in	r29, 0x3e	; 62
    112e:	9a 83       	std	Y+2, r25	; 0x02
    1130:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while (!GET_BIT(UCSRA_REG,UCSRA_UDRE));
    1132:	eb e2       	ldi	r30, 0x2B	; 43
    1134:	f0 e0       	ldi	r31, 0x00	; 0
    1136:	80 81       	ld	r24, Z
    1138:	82 95       	swap	r24
    113a:	86 95       	lsr	r24
    113c:	87 70       	andi	r24, 0x07	; 7
    113e:	88 2f       	mov	r24, r24
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	81 70       	andi	r24, 0x01	; 1
    1144:	90 70       	andi	r25, 0x00	; 0
    1146:	00 97       	sbiw	r24, 0x00	; 0
    1148:	a1 f3       	breq	.-24     	; 0x1132 <USART_voidTransmitData+0xe>

	/* Put data into buffer, sends the data */
#if DATA_SIZE == DATA_SIZE_9_BIT
	UDR_REG = (u8)(copy_u16Data | (GET_BIT(UCSRB_REG, UCSRB_TXB8)<<8));
#else
	UDR_REG = (u8)copy_u16Data;
    114a:	ec e2       	ldi	r30, 0x2C	; 44
    114c:	f0 e0       	ldi	r31, 0x00	; 0
    114e:	89 81       	ldd	r24, Y+1	; 0x01
    1150:	80 83       	st	Z, r24
#endif
}
    1152:	0f 90       	pop	r0
    1154:	0f 90       	pop	r0
    1156:	cf 91       	pop	r28
    1158:	df 91       	pop	r29
    115a:	08 95       	ret

0000115c <USART_voidTransmitString>:

void USART_voidTransmitString(u8* copy_string){
    115c:	df 93       	push	r29
    115e:	cf 93       	push	r28
    1160:	00 d0       	rcall	.+0      	; 0x1162 <USART_voidTransmitString+0x6>
    1162:	00 d0       	rcall	.+0      	; 0x1164 <USART_voidTransmitString+0x8>
    1164:	00 d0       	rcall	.+0      	; 0x1166 <USART_voidTransmitString+0xa>
    1166:	cd b7       	in	r28, 0x3d	; 61
    1168:	de b7       	in	r29, 0x3e	; 62
    116a:	9e 83       	std	Y+6, r25	; 0x06
    116c:	8d 83       	std	Y+5, r24	; 0x05
	u32 i=0;
    116e:	19 82       	std	Y+1, r1	; 0x01
    1170:	1a 82       	std	Y+2, r1	; 0x02
    1172:	1b 82       	std	Y+3, r1	; 0x03
    1174:	1c 82       	std	Y+4, r1	; 0x04
    1176:	17 c0       	rjmp	.+46     	; 0x11a6 <USART_voidTransmitString+0x4a>
	for(;copy_string[i]!='\0';i++){
		USART_voidTransmitData((u16)copy_string[i]);
    1178:	29 81       	ldd	r18, Y+1	; 0x01
    117a:	3a 81       	ldd	r19, Y+2	; 0x02
    117c:	8d 81       	ldd	r24, Y+5	; 0x05
    117e:	9e 81       	ldd	r25, Y+6	; 0x06
    1180:	fc 01       	movw	r30, r24
    1182:	e2 0f       	add	r30, r18
    1184:	f3 1f       	adc	r31, r19
    1186:	80 81       	ld	r24, Z
    1188:	88 2f       	mov	r24, r24
    118a:	90 e0       	ldi	r25, 0x00	; 0
    118c:	0e 94 92 08 	call	0x1124	; 0x1124 <USART_voidTransmitData>
#endif
}

void USART_voidTransmitString(u8* copy_string){
	u32 i=0;
	for(;copy_string[i]!='\0';i++){
    1190:	89 81       	ldd	r24, Y+1	; 0x01
    1192:	9a 81       	ldd	r25, Y+2	; 0x02
    1194:	ab 81       	ldd	r26, Y+3	; 0x03
    1196:	bc 81       	ldd	r27, Y+4	; 0x04
    1198:	01 96       	adiw	r24, 0x01	; 1
    119a:	a1 1d       	adc	r26, r1
    119c:	b1 1d       	adc	r27, r1
    119e:	89 83       	std	Y+1, r24	; 0x01
    11a0:	9a 83       	std	Y+2, r25	; 0x02
    11a2:	ab 83       	std	Y+3, r26	; 0x03
    11a4:	bc 83       	std	Y+4, r27	; 0x04
    11a6:	29 81       	ldd	r18, Y+1	; 0x01
    11a8:	3a 81       	ldd	r19, Y+2	; 0x02
    11aa:	8d 81       	ldd	r24, Y+5	; 0x05
    11ac:	9e 81       	ldd	r25, Y+6	; 0x06
    11ae:	fc 01       	movw	r30, r24
    11b0:	e2 0f       	add	r30, r18
    11b2:	f3 1f       	adc	r31, r19
    11b4:	80 81       	ld	r24, Z
    11b6:	88 23       	and	r24, r24
    11b8:	f9 f6       	brne	.-66     	; 0x1178 <USART_voidTransmitString+0x1c>
		USART_voidTransmitData((u16)copy_string[i]);
	}
}
    11ba:	26 96       	adiw	r28, 0x06	; 6
    11bc:	0f b6       	in	r0, 0x3f	; 63
    11be:	f8 94       	cli
    11c0:	de bf       	out	0x3e, r29	; 62
    11c2:	0f be       	out	0x3f, r0	; 63
    11c4:	cd bf       	out	0x3d, r28	; 61
    11c6:	cf 91       	pop	r28
    11c8:	df 91       	pop	r29
    11ca:	08 95       	ret

000011cc <USART_u16ReceiveData>:

u16 USART_u16ReceiveData(void){
    11cc:	df 93       	push	r29
    11ce:	cf 93       	push	r28
    11d0:	cd b7       	in	r28, 0x3d	; 61
    11d2:	de b7       	in	r29, 0x3e	; 62
	/* Wait for data to be received */
	while (!GET_BIT(UCSRA_REG, UCSRA_RXC));
    11d4:	eb e2       	ldi	r30, 0x2B	; 43
    11d6:	f0 e0       	ldi	r31, 0x00	; 0
    11d8:	80 81       	ld	r24, Z
    11da:	88 23       	and	r24, r24
    11dc:	dc f7       	brge	.-10     	; 0x11d4 <USART_u16ReceiveData+0x8>

#if DATA_SIZE == DATA_SIZE_9_BIT
	return UDR_REG | GET_BIT(UCSRB_REG, UCSRB_RXB8)<<8 ;

#else
	return UDR_REG;
    11de:	ec e2       	ldi	r30, 0x2C	; 44
    11e0:	f0 e0       	ldi	r31, 0x00	; 0
    11e2:	80 81       	ld	r24, Z
    11e4:	88 2f       	mov	r24, r24
    11e6:	90 e0       	ldi	r25, 0x00	; 0
#endif
}
    11e8:	cf 91       	pop	r28
    11ea:	df 91       	pop	r29
    11ec:	08 95       	ret

000011ee <TMR1_voidInit>:
/***TMR1***/
#include "TMR1_Interface.h"
#include "TMR1_Private.h"
#include "TMR1_Config.h"

void TMR1_voidInit(){
    11ee:	df 93       	push	r29
    11f0:	cf 93       	push	r28
    11f2:	cd b7       	in	r28, 0x3d	; 61
    11f4:	de b7       	in	r29, 0x3e	; 62
	/*** OC1A --> OUTPUT ***/
	DIO_voidSetPinDirection(OC1A_PORT,OC1A_PIN,PIN_OUTPUT);
    11f6:	83 e0       	ldi	r24, 0x03	; 3
    11f8:	65 e0       	ldi	r22, 0x05	; 5
    11fa:	41 e0       	ldi	r20, 0x01	; 1
    11fc:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>

	/*** Compare match = clear on compare ***/
	SET_BIT(TCCR1A_REG,TCCR1A_COM1A1);
    1200:	af e4       	ldi	r26, 0x4F	; 79
    1202:	b0 e0       	ldi	r27, 0x00	; 0
    1204:	ef e4       	ldi	r30, 0x4F	; 79
    1206:	f0 e0       	ldi	r31, 0x00	; 0
    1208:	80 81       	ld	r24, Z
    120a:	80 68       	ori	r24, 0x80	; 128
    120c:	8c 93       	st	X, r24
	CLR_BIT(TCCR1A_REG,TCCR1A_COM1A0);
    120e:	af e4       	ldi	r26, 0x4F	; 79
    1210:	b0 e0       	ldi	r27, 0x00	; 0
    1212:	ef e4       	ldi	r30, 0x4F	; 79
    1214:	f0 e0       	ldi	r31, 0x00	; 0
    1216:	80 81       	ld	r24, Z
    1218:	8f 7b       	andi	r24, 0xBF	; 191
    121a:	8c 93       	st	X, r24

	/*** MODE = FAST_PWM, TOP=ICR1 ***/
	SET_BIT(TCCR1B_REG,TCCR1B_WGM13);
    121c:	ae e4       	ldi	r26, 0x4E	; 78
    121e:	b0 e0       	ldi	r27, 0x00	; 0
    1220:	ee e4       	ldi	r30, 0x4E	; 78
    1222:	f0 e0       	ldi	r31, 0x00	; 0
    1224:	80 81       	ld	r24, Z
    1226:	80 61       	ori	r24, 0x10	; 16
    1228:	8c 93       	st	X, r24
	SET_BIT(TCCR1B_REG,TCCR1B_WGM12);
    122a:	ae e4       	ldi	r26, 0x4E	; 78
    122c:	b0 e0       	ldi	r27, 0x00	; 0
    122e:	ee e4       	ldi	r30, 0x4E	; 78
    1230:	f0 e0       	ldi	r31, 0x00	; 0
    1232:	80 81       	ld	r24, Z
    1234:	88 60       	ori	r24, 0x08	; 8
    1236:	8c 93       	st	X, r24
	SET_BIT(TCCR1A_REG,TCCR1A_WGM11);
    1238:	af e4       	ldi	r26, 0x4F	; 79
    123a:	b0 e0       	ldi	r27, 0x00	; 0
    123c:	ef e4       	ldi	r30, 0x4F	; 79
    123e:	f0 e0       	ldi	r31, 0x00	; 0
    1240:	80 81       	ld	r24, Z
    1242:	82 60       	ori	r24, 0x02	; 2
    1244:	8c 93       	st	X, r24
	CLR_BIT(TCCR1A_REG,TCCR1A_WGM10);
    1246:	af e4       	ldi	r26, 0x4F	; 79
    1248:	b0 e0       	ldi	r27, 0x00	; 0
    124a:	ef e4       	ldi	r30, 0x4F	; 79
    124c:	f0 e0       	ldi	r31, 0x00	; 0
    124e:	80 81       	ld	r24, Z
    1250:	8e 7f       	andi	r24, 0xFE	; 254
    1252:	8c 93       	st	X, r24

	/*** Top Value ***/
	ICR1_REG = (u16)(40000UL);  //for Period_Time = 20 mSec
    1254:	e6 e4       	ldi	r30, 0x46	; 70
    1256:	f0 e0       	ldi	r31, 0x00	; 0
    1258:	80 e4       	ldi	r24, 0x40	; 64
    125a:	9c e9       	ldi	r25, 0x9C	; 156
    125c:	91 83       	std	Z+1, r25	; 0x01
    125e:	80 83       	st	Z, r24

	/*** Compare match from 2000 to 4000 ***/
	OCR1A_REG = (u16)(2000UL); //for On_Time = 1mSec
    1260:	ea e4       	ldi	r30, 0x4A	; 74
    1262:	f0 e0       	ldi	r31, 0x00	; 0
    1264:	80 ed       	ldi	r24, 0xD0	; 208
    1266:	97 e0       	ldi	r25, 0x07	; 7
    1268:	91 83       	std	Z+1, r25	; 0x01
    126a:	80 83       	st	Z, r24

	/*** Prescaler = 8 ***/
	CLR_BIT(TCCR1B_REG,TCCR1B_CS12);
    126c:	ae e4       	ldi	r26, 0x4E	; 78
    126e:	b0 e0       	ldi	r27, 0x00	; 0
    1270:	ee e4       	ldi	r30, 0x4E	; 78
    1272:	f0 e0       	ldi	r31, 0x00	; 0
    1274:	80 81       	ld	r24, Z
    1276:	8b 7f       	andi	r24, 0xFB	; 251
    1278:	8c 93       	st	X, r24
	SET_BIT(TCCR1B_REG,TCCR1B_CS11);
    127a:	ae e4       	ldi	r26, 0x4E	; 78
    127c:	b0 e0       	ldi	r27, 0x00	; 0
    127e:	ee e4       	ldi	r30, 0x4E	; 78
    1280:	f0 e0       	ldi	r31, 0x00	; 0
    1282:	80 81       	ld	r24, Z
    1284:	82 60       	ori	r24, 0x02	; 2
    1286:	8c 93       	st	X, r24
	CLR_BIT(TCCR1A_REG,TCCR1B_CS10);
    1288:	af e4       	ldi	r26, 0x4F	; 79
    128a:	b0 e0       	ldi	r27, 0x00	; 0
    128c:	ef e4       	ldi	r30, 0x4F	; 79
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	80 81       	ld	r24, Z
    1292:	8e 7f       	andi	r24, 0xFE	; 254
    1294:	8c 93       	st	X, r24
}
    1296:	cf 91       	pop	r28
    1298:	df 91       	pop	r29
    129a:	08 95       	ret

0000129c <TMR1_voidGeneratePWMtoRotateServo>:


void TMR1_voidGeneratePWMtoRotateServo(){
    129c:	df 93       	push	r29
    129e:	cf 93       	push	r28
    12a0:	cd b7       	in	r28, 0x3d	; 61
    12a2:	de b7       	in	r29, 0x3e	; 62
    12a4:	60 97       	sbiw	r28, 0x10	; 16
    12a6:	0f b6       	in	r0, 0x3f	; 63
    12a8:	f8 94       	cli
    12aa:	de bf       	out	0x3e, r29	; 62
    12ac:	0f be       	out	0x3f, r0	; 63
    12ae:	cd bf       	out	0x3d, r28	; 61
	u16 i=2000UL;
    12b0:	80 ed       	ldi	r24, 0xD0	; 208
    12b2:	97 e0       	ldi	r25, 0x07	; 7
    12b4:	98 8b       	std	Y+16, r25	; 0x10
    12b6:	8f 87       	std	Y+15, r24	; 0x0f
    12b8:	7d c0       	rjmp	.+250    	; 0x13b4 <TMR1_voidGeneratePWMtoRotateServo+0x118>

	for( ; i<=4000UL ;i++){
		OCR1A_REG = (u16)i;
    12ba:	ea e4       	ldi	r30, 0x4A	; 74
    12bc:	f0 e0       	ldi	r31, 0x00	; 0
    12be:	8f 85       	ldd	r24, Y+15	; 0x0f
    12c0:	98 89       	ldd	r25, Y+16	; 0x10
    12c2:	91 83       	std	Z+1, r25	; 0x01
    12c4:	80 83       	st	Z, r24
    12c6:	80 e0       	ldi	r24, 0x00	; 0
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	a0 ea       	ldi	r26, 0xA0	; 160
    12cc:	b0 e4       	ldi	r27, 0x40	; 64
    12ce:	8b 87       	std	Y+11, r24	; 0x0b
    12d0:	9c 87       	std	Y+12, r25	; 0x0c
    12d2:	ad 87       	std	Y+13, r26	; 0x0d
    12d4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    12d6:	6b 85       	ldd	r22, Y+11	; 0x0b
    12d8:	7c 85       	ldd	r23, Y+12	; 0x0c
    12da:	8d 85       	ldd	r24, Y+13	; 0x0d
    12dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    12de:	20 e0       	ldi	r18, 0x00	; 0
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	4a e7       	ldi	r20, 0x7A	; 122
    12e4:	55 e4       	ldi	r21, 0x45	; 69
    12e6:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    12ea:	dc 01       	movw	r26, r24
    12ec:	cb 01       	movw	r24, r22
    12ee:	8f 83       	std	Y+7, r24	; 0x07
    12f0:	98 87       	std	Y+8, r25	; 0x08
    12f2:	a9 87       	std	Y+9, r26	; 0x09
    12f4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    12f6:	6f 81       	ldd	r22, Y+7	; 0x07
    12f8:	78 85       	ldd	r23, Y+8	; 0x08
    12fa:	89 85       	ldd	r24, Y+9	; 0x09
    12fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    12fe:	20 e0       	ldi	r18, 0x00	; 0
    1300:	30 e0       	ldi	r19, 0x00	; 0
    1302:	40 e8       	ldi	r20, 0x80	; 128
    1304:	5f e3       	ldi	r21, 0x3F	; 63
    1306:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    130a:	88 23       	and	r24, r24
    130c:	2c f4       	brge	.+10     	; 0x1318 <TMR1_voidGeneratePWMtoRotateServo+0x7c>
		__ticks = 1;
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	90 e0       	ldi	r25, 0x00	; 0
    1312:	9e 83       	std	Y+6, r25	; 0x06
    1314:	8d 83       	std	Y+5, r24	; 0x05
    1316:	3f c0       	rjmp	.+126    	; 0x1396 <TMR1_voidGeneratePWMtoRotateServo+0xfa>
	else if (__tmp > 65535)
    1318:	6f 81       	ldd	r22, Y+7	; 0x07
    131a:	78 85       	ldd	r23, Y+8	; 0x08
    131c:	89 85       	ldd	r24, Y+9	; 0x09
    131e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1320:	20 e0       	ldi	r18, 0x00	; 0
    1322:	3f ef       	ldi	r19, 0xFF	; 255
    1324:	4f e7       	ldi	r20, 0x7F	; 127
    1326:	57 e4       	ldi	r21, 0x47	; 71
    1328:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    132c:	18 16       	cp	r1, r24
    132e:	4c f5       	brge	.+82     	; 0x1382 <TMR1_voidGeneratePWMtoRotateServo+0xe6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1330:	6b 85       	ldd	r22, Y+11	; 0x0b
    1332:	7c 85       	ldd	r23, Y+12	; 0x0c
    1334:	8d 85       	ldd	r24, Y+13	; 0x0d
    1336:	9e 85       	ldd	r25, Y+14	; 0x0e
    1338:	20 e0       	ldi	r18, 0x00	; 0
    133a:	30 e0       	ldi	r19, 0x00	; 0
    133c:	40 e2       	ldi	r20, 0x20	; 32
    133e:	51 e4       	ldi	r21, 0x41	; 65
    1340:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    1344:	dc 01       	movw	r26, r24
    1346:	cb 01       	movw	r24, r22
    1348:	bc 01       	movw	r22, r24
    134a:	cd 01       	movw	r24, r26
    134c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1350:	dc 01       	movw	r26, r24
    1352:	cb 01       	movw	r24, r22
    1354:	9e 83       	std	Y+6, r25	; 0x06
    1356:	8d 83       	std	Y+5, r24	; 0x05
    1358:	0f c0       	rjmp	.+30     	; 0x1378 <TMR1_voidGeneratePWMtoRotateServo+0xdc>
    135a:	80 e9       	ldi	r24, 0x90	; 144
    135c:	91 e0       	ldi	r25, 0x01	; 1
    135e:	9c 83       	std	Y+4, r25	; 0x04
    1360:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1362:	8b 81       	ldd	r24, Y+3	; 0x03
    1364:	9c 81       	ldd	r25, Y+4	; 0x04
    1366:	01 97       	sbiw	r24, 0x01	; 1
    1368:	f1 f7       	brne	.-4      	; 0x1366 <TMR1_voidGeneratePWMtoRotateServo+0xca>
    136a:	9c 83       	std	Y+4, r25	; 0x04
    136c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    136e:	8d 81       	ldd	r24, Y+5	; 0x05
    1370:	9e 81       	ldd	r25, Y+6	; 0x06
    1372:	01 97       	sbiw	r24, 0x01	; 1
    1374:	9e 83       	std	Y+6, r25	; 0x06
    1376:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1378:	8d 81       	ldd	r24, Y+5	; 0x05
    137a:	9e 81       	ldd	r25, Y+6	; 0x06
    137c:	00 97       	sbiw	r24, 0x00	; 0
    137e:	69 f7       	brne	.-38     	; 0x135a <TMR1_voidGeneratePWMtoRotateServo+0xbe>
    1380:	14 c0       	rjmp	.+40     	; 0x13aa <TMR1_voidGeneratePWMtoRotateServo+0x10e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1382:	6f 81       	ldd	r22, Y+7	; 0x07
    1384:	78 85       	ldd	r23, Y+8	; 0x08
    1386:	89 85       	ldd	r24, Y+9	; 0x09
    1388:	9a 85       	ldd	r25, Y+10	; 0x0a
    138a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    138e:	dc 01       	movw	r26, r24
    1390:	cb 01       	movw	r24, r22
    1392:	9e 83       	std	Y+6, r25	; 0x06
    1394:	8d 83       	std	Y+5, r24	; 0x05
    1396:	8d 81       	ldd	r24, Y+5	; 0x05
    1398:	9e 81       	ldd	r25, Y+6	; 0x06
    139a:	9a 83       	std	Y+2, r25	; 0x02
    139c:	89 83       	std	Y+1, r24	; 0x01
    139e:	89 81       	ldd	r24, Y+1	; 0x01
    13a0:	9a 81       	ldd	r25, Y+2	; 0x02
    13a2:	01 97       	sbiw	r24, 0x01	; 1
    13a4:	f1 f7       	brne	.-4      	; 0x13a2 <TMR1_voidGeneratePWMtoRotateServo+0x106>
    13a6:	9a 83       	std	Y+2, r25	; 0x02
    13a8:	89 83       	std	Y+1, r24	; 0x01


void TMR1_voidGeneratePWMtoRotateServo(){
	u16 i=2000UL;

	for( ; i<=4000UL ;i++){
    13aa:	8f 85       	ldd	r24, Y+15	; 0x0f
    13ac:	98 89       	ldd	r25, Y+16	; 0x10
    13ae:	01 96       	adiw	r24, 0x01	; 1
    13b0:	98 8b       	std	Y+16, r25	; 0x10
    13b2:	8f 87       	std	Y+15, r24	; 0x0f
    13b4:	8f 85       	ldd	r24, Y+15	; 0x0f
    13b6:	98 89       	ldd	r25, Y+16	; 0x10
    13b8:	2f e0       	ldi	r18, 0x0F	; 15
    13ba:	81 3a       	cpi	r24, 0xA1	; 161
    13bc:	92 07       	cpc	r25, r18
    13be:	08 f4       	brcc	.+2      	; 0x13c2 <TMR1_voidGeneratePWMtoRotateServo+0x126>
    13c0:	7c cf       	rjmp	.-264    	; 0x12ba <TMR1_voidGeneratePWMtoRotateServo+0x1e>
		OCR1A_REG = (u16)i;
		_delay_ms(5);
	}
}
    13c2:	60 96       	adiw	r28, 0x10	; 16
    13c4:	0f b6       	in	r0, 0x3f	; 63
    13c6:	f8 94       	cli
    13c8:	de bf       	out	0x3e, r29	; 62
    13ca:	0f be       	out	0x3f, r0	; 63
    13cc:	cd bf       	out	0x3d, r28	; 61
    13ce:	cf 91       	pop	r28
    13d0:	df 91       	pop	r29
    13d2:	08 95       	ret

000013d4 <TMR0_voidCalculateNumberOfOverFlows>:
static u16 global_u16OverFlowTicks;
static u32 global_u32OverFlows;
static u16 global_u16Preload;

/**** Static Functions ****/
static void TMR0_voidCalculateNumberOfOverFlows(u16 copy_u16DesiredTime){
    13d4:	ef 92       	push	r14
    13d6:	ff 92       	push	r15
    13d8:	0f 93       	push	r16
    13da:	1f 93       	push	r17
    13dc:	df 93       	push	r29
    13de:	cf 93       	push	r28
    13e0:	cd b7       	in	r28, 0x3d	; 61
    13e2:	de b7       	in	r29, 0x3e	; 62
    13e4:	2e 97       	sbiw	r28, 0x0e	; 14
    13e6:	0f b6       	in	r0, 0x3f	; 63
    13e8:	f8 94       	cli
    13ea:	de bf       	out	0x3e, r29	; 62
    13ec:	0f be       	out	0x3f, r0	; 63
    13ee:	cd bf       	out	0x3d, r28	; 61
    13f0:	9e 87       	std	Y+14, r25	; 0x0e
    13f2:	8d 87       	std	Y+13, r24	; 0x0d
#if MODE == NORMAL_MODE
	f64 local_f64TickTime = (1.0*PRESCALER)/F_SYS;
    13f4:	8d eb       	ldi	r24, 0xBD	; 189
    13f6:	97 e3       	ldi	r25, 0x37	; 55
    13f8:	a6 e8       	ldi	r26, 0x86	; 134
    13fa:	b6 e3       	ldi	r27, 0x36	; 54
    13fc:	89 87       	std	Y+9, r24	; 0x09
    13fe:	9a 87       	std	Y+10, r25	; 0x0a
    1400:	ab 87       	std	Y+11, r26	; 0x0b
    1402:	bc 87       	std	Y+12, r27	; 0x0c
	f64 local_f64OverFlows = (copy_u16DesiredTime/(global_u16OverFlowTicks*local_f64TickTime));
    1404:	8d 85       	ldd	r24, Y+13	; 0x0d
    1406:	9e 85       	ldd	r25, Y+14	; 0x0e
    1408:	cc 01       	movw	r24, r24
    140a:	a0 e0       	ldi	r26, 0x00	; 0
    140c:	b0 e0       	ldi	r27, 0x00	; 0
    140e:	bc 01       	movw	r22, r24
    1410:	cd 01       	movw	r24, r26
    1412:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__floatunsisf>
    1416:	7b 01       	movw	r14, r22
    1418:	8c 01       	movw	r16, r24
    141a:	80 91 94 01 	lds	r24, 0x0194
    141e:	90 91 95 01 	lds	r25, 0x0195
    1422:	cc 01       	movw	r24, r24
    1424:	a0 e0       	ldi	r26, 0x00	; 0
    1426:	b0 e0       	ldi	r27, 0x00	; 0
    1428:	bc 01       	movw	r22, r24
    142a:	cd 01       	movw	r24, r26
    142c:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__floatunsisf>
    1430:	dc 01       	movw	r26, r24
    1432:	cb 01       	movw	r24, r22
    1434:	bc 01       	movw	r22, r24
    1436:	cd 01       	movw	r24, r26
    1438:	29 85       	ldd	r18, Y+9	; 0x09
    143a:	3a 85       	ldd	r19, Y+10	; 0x0a
    143c:	4b 85       	ldd	r20, Y+11	; 0x0b
    143e:	5c 85       	ldd	r21, Y+12	; 0x0c
    1440:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    1444:	dc 01       	movw	r26, r24
    1446:	cb 01       	movw	r24, r22
    1448:	9c 01       	movw	r18, r24
    144a:	ad 01       	movw	r20, r26
    144c:	c8 01       	movw	r24, r16
    144e:	b7 01       	movw	r22, r14
    1450:	0e 94 c1 03 	call	0x782	; 0x782 <__divsf3>
    1454:	dc 01       	movw	r26, r24
    1456:	cb 01       	movw	r24, r22
    1458:	8d 83       	std	Y+5, r24	; 0x05
    145a:	9e 83       	std	Y+6, r25	; 0x06
    145c:	af 83       	std	Y+7, r26	; 0x07
    145e:	b8 87       	std	Y+8, r27	; 0x08
	global_u32OverFlows  = (u16) local_f64OverFlows;
    1460:	6d 81       	ldd	r22, Y+5	; 0x05
    1462:	7e 81       	ldd	r23, Y+6	; 0x06
    1464:	8f 81       	ldd	r24, Y+7	; 0x07
    1466:	98 85       	ldd	r25, Y+8	; 0x08
    1468:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    146c:	dc 01       	movw	r26, r24
    146e:	cb 01       	movw	r24, r22
    1470:	cc 01       	movw	r24, r24
    1472:	a0 e0       	ldi	r26, 0x00	; 0
    1474:	b0 e0       	ldi	r27, 0x00	; 0
    1476:	80 93 96 01 	sts	0x0196, r24
    147a:	90 93 97 01 	sts	0x0197, r25
    147e:	a0 93 98 01 	sts	0x0198, r26
    1482:	b0 93 99 01 	sts	0x0199, r27
	f32 local_f32Fraction = local_f64OverFlows - global_u32OverFlows;
    1486:	80 91 96 01 	lds	r24, 0x0196
    148a:	90 91 97 01 	lds	r25, 0x0197
    148e:	a0 91 98 01 	lds	r26, 0x0198
    1492:	b0 91 99 01 	lds	r27, 0x0199
    1496:	bc 01       	movw	r22, r24
    1498:	cd 01       	movw	r24, r26
    149a:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__floatunsisf>
    149e:	9b 01       	movw	r18, r22
    14a0:	ac 01       	movw	r20, r24
    14a2:	6d 81       	ldd	r22, Y+5	; 0x05
    14a4:	7e 81       	ldd	r23, Y+6	; 0x06
    14a6:	8f 81       	ldd	r24, Y+7	; 0x07
    14a8:	98 85       	ldd	r25, Y+8	; 0x08
    14aa:	0e 94 69 02 	call	0x4d2	; 0x4d2 <__subsf3>
    14ae:	dc 01       	movw	r26, r24
    14b0:	cb 01       	movw	r24, r22
    14b2:	89 83       	std	Y+1, r24	; 0x01
    14b4:	9a 83       	std	Y+2, r25	; 0x02
    14b6:	ab 83       	std	Y+3, r26	; 0x03
    14b8:	bc 83       	std	Y+4, r27	; 0x04
	global_u32OverFlows++;
    14ba:	80 91 96 01 	lds	r24, 0x0196
    14be:	90 91 97 01 	lds	r25, 0x0197
    14c2:	a0 91 98 01 	lds	r26, 0x0198
    14c6:	b0 91 99 01 	lds	r27, 0x0199
    14ca:	01 96       	adiw	r24, 0x01	; 1
    14cc:	a1 1d       	adc	r26, r1
    14ce:	b1 1d       	adc	r27, r1
    14d0:	80 93 96 01 	sts	0x0196, r24
    14d4:	90 93 97 01 	sts	0x0197, r25
    14d8:	a0 93 98 01 	sts	0x0198, r26
    14dc:	b0 93 99 01 	sts	0x0199, r27
	global_u16Preload = (1-local_f32Fraction)*global_u32OverFlows;
    14e0:	60 e0       	ldi	r22, 0x00	; 0
    14e2:	70 e0       	ldi	r23, 0x00	; 0
    14e4:	80 e8       	ldi	r24, 0x80	; 128
    14e6:	9f e3       	ldi	r25, 0x3F	; 63
    14e8:	29 81       	ldd	r18, Y+1	; 0x01
    14ea:	3a 81       	ldd	r19, Y+2	; 0x02
    14ec:	4b 81       	ldd	r20, Y+3	; 0x03
    14ee:	5c 81       	ldd	r21, Y+4	; 0x04
    14f0:	0e 94 69 02 	call	0x4d2	; 0x4d2 <__subsf3>
    14f4:	dc 01       	movw	r26, r24
    14f6:	cb 01       	movw	r24, r22
    14f8:	7c 01       	movw	r14, r24
    14fa:	8d 01       	movw	r16, r26
    14fc:	80 91 96 01 	lds	r24, 0x0196
    1500:	90 91 97 01 	lds	r25, 0x0197
    1504:	a0 91 98 01 	lds	r26, 0x0198
    1508:	b0 91 99 01 	lds	r27, 0x0199
    150c:	bc 01       	movw	r22, r24
    150e:	cd 01       	movw	r24, r26
    1510:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__floatunsisf>
    1514:	9b 01       	movw	r18, r22
    1516:	ac 01       	movw	r20, r24
    1518:	c8 01       	movw	r24, r16
    151a:	b7 01       	movw	r22, r14
    151c:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    1520:	dc 01       	movw	r26, r24
    1522:	cb 01       	movw	r24, r22
    1524:	bc 01       	movw	r22, r24
    1526:	cd 01       	movw	r24, r26
    1528:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    152c:	dc 01       	movw	r26, r24
    152e:	cb 01       	movw	r24, r22
    1530:	90 93 9b 01 	sts	0x019B, r25
    1534:	80 93 9a 01 	sts	0x019A, r24
	f64 local_f64TickTime = (1.0*PRESCALER)/F_SYS;
	global_u32OverFlows = CTC_OVERFLOWS;
	global_u16OverFlowTicks = (copy_u16DesiredTime/(local_f64TickTime*global_u32OverFlows));

#endif
}
    1538:	2e 96       	adiw	r28, 0x0e	; 14
    153a:	0f b6       	in	r0, 0x3f	; 63
    153c:	f8 94       	cli
    153e:	de bf       	out	0x3e, r29	; 62
    1540:	0f be       	out	0x3f, r0	; 63
    1542:	cd bf       	out	0x3d, r28	; 61
    1544:	cf 91       	pop	r28
    1546:	df 91       	pop	r29
    1548:	1f 91       	pop	r17
    154a:	0f 91       	pop	r16
    154c:	ff 90       	pop	r15
    154e:	ef 90       	pop	r14
    1550:	08 95       	ret

00001552 <TMR0_voidInit>:

/****** Functions *****/
void TMR0_voidInit(){
    1552:	df 93       	push	r29
    1554:	cf 93       	push	r28
    1556:	cd b7       	in	r28, 0x3d	; 61
    1558:	de b7       	in	r29, 0x3e	; 62
#if MODE == NORMAL_MODE
	CLR_BIT(TCCR0_REG,TCCR0_WGM01);
    155a:	a3 e5       	ldi	r26, 0x53	; 83
    155c:	b0 e0       	ldi	r27, 0x00	; 0
    155e:	e3 e5       	ldi	r30, 0x53	; 83
    1560:	f0 e0       	ldi	r31, 0x00	; 0
    1562:	80 81       	ld	r24, Z
    1564:	87 7f       	andi	r24, 0xF7	; 247
    1566:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,TCCR0_WGM00);
    1568:	a3 e5       	ldi	r26, 0x53	; 83
    156a:	b0 e0       	ldi	r27, 0x00	; 0
    156c:	e3 e5       	ldi	r30, 0x53	; 83
    156e:	f0 e0       	ldi	r31, 0x00	; 0
    1570:	80 81       	ld	r24, Z
    1572:	8f 7b       	andi	r24, 0xBF	; 191
    1574:	8c 93       	st	X, r24
	SET_BIT(TIMSK_REG,TIMSK_TOIE0);
    1576:	a9 e5       	ldi	r26, 0x59	; 89
    1578:	b0 e0       	ldi	r27, 0x00	; 0
    157a:	e9 e5       	ldi	r30, 0x59	; 89
    157c:	f0 e0       	ldi	r31, 0x00	; 0
    157e:	80 81       	ld	r24, Z
    1580:	81 60       	ori	r24, 0x01	; 1
    1582:	8c 93       	st	X, r24
	global_u16OverFlowTicks = NORMAL_OVERFLOW_TICKS;
    1584:	80 e0       	ldi	r24, 0x00	; 0
    1586:	91 e0       	ldi	r25, 0x01	; 1
    1588:	90 93 95 01 	sts	0x0195, r25
    158c:	80 93 94 01 	sts	0x0194, r24
	CLR_BIT(TCCR0_REG,TCCR0_WGM01);
	SET_BIT(TCCR0_REG,TCCR0_WGM00);

#endif

}
    1590:	cf 91       	pop	r28
    1592:	df 91       	pop	r29
    1594:	08 95       	ret

00001596 <TMR0_voidStart>:

void TMR0_voidStart(){
    1596:	df 93       	push	r29
    1598:	cf 93       	push	r28
    159a:	cd b7       	in	r28, 0x3d	; 61
    159c:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0_REG,TCCR0_CS02);
	SET_BIT(TCCR0_REG,TCCR0_CS01);
	CLR_BIT(TCCR0_REG,TCCR0_CS00);

#elif PRESCALER == PRESCALER_64
	CLR_BIT(TCCR0_REG,TCCR0_CS02);
    159e:	a3 e5       	ldi	r26, 0x53	; 83
    15a0:	b0 e0       	ldi	r27, 0x00	; 0
    15a2:	e3 e5       	ldi	r30, 0x53	; 83
    15a4:	f0 e0       	ldi	r31, 0x00	; 0
    15a6:	80 81       	ld	r24, Z
    15a8:	8b 7f       	andi	r24, 0xFB	; 251
    15aa:	8c 93       	st	X, r24
	SET_BIT(TCCR0_REG,TCCR0_CS01);
    15ac:	a3 e5       	ldi	r26, 0x53	; 83
    15ae:	b0 e0       	ldi	r27, 0x00	; 0
    15b0:	e3 e5       	ldi	r30, 0x53	; 83
    15b2:	f0 e0       	ldi	r31, 0x00	; 0
    15b4:	80 81       	ld	r24, Z
    15b6:	82 60       	ori	r24, 0x02	; 2
    15b8:	8c 93       	st	X, r24
	SET_BIT(TCCR0_REG,TCCR0_CS00);
    15ba:	a3 e5       	ldi	r26, 0x53	; 83
    15bc:	b0 e0       	ldi	r27, 0x00	; 0
    15be:	e3 e5       	ldi	r30, 0x53	; 83
    15c0:	f0 e0       	ldi	r31, 0x00	; 0
    15c2:	80 81       	ld	r24, Z
    15c4:	81 60       	ori	r24, 0x01	; 1
    15c6:	8c 93       	st	X, r24
	SET_BIT(TCCR0_REG,TCCR0_CS01);
	SET_BIT(TCCR0_REG,TCCR0_CS00);

#endif

}
    15c8:	cf 91       	pop	r28
    15ca:	df 91       	pop	r29
    15cc:	08 95       	ret

000015ce <TMR0_voidStop>:

void TMR0_voidStop(){
    15ce:	df 93       	push	r29
    15d0:	cf 93       	push	r28
    15d2:	cd b7       	in	r28, 0x3d	; 61
    15d4:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0_REG,TCCR0_CS02);
    15d6:	a3 e5       	ldi	r26, 0x53	; 83
    15d8:	b0 e0       	ldi	r27, 0x00	; 0
    15da:	e3 e5       	ldi	r30, 0x53	; 83
    15dc:	f0 e0       	ldi	r31, 0x00	; 0
    15de:	80 81       	ld	r24, Z
    15e0:	8b 7f       	andi	r24, 0xFB	; 251
    15e2:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,TCCR0_CS01);
    15e4:	a3 e5       	ldi	r26, 0x53	; 83
    15e6:	b0 e0       	ldi	r27, 0x00	; 0
    15e8:	e3 e5       	ldi	r30, 0x53	; 83
    15ea:	f0 e0       	ldi	r31, 0x00	; 0
    15ec:	80 81       	ld	r24, Z
    15ee:	8d 7f       	andi	r24, 0xFD	; 253
    15f0:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,TCCR0_CS00);
    15f2:	a3 e5       	ldi	r26, 0x53	; 83
    15f4:	b0 e0       	ldi	r27, 0x00	; 0
    15f6:	e3 e5       	ldi	r30, 0x53	; 83
    15f8:	f0 e0       	ldi	r31, 0x00	; 0
    15fa:	80 81       	ld	r24, Z
    15fc:	8e 7f       	andi	r24, 0xFE	; 254
    15fe:	8c 93       	st	X, r24
}
    1600:	cf 91       	pop	r28
    1602:	df 91       	pop	r29
    1604:	08 95       	ret

00001606 <TMR0_voidSetCallBack>:

void TMR0_voidSetCallBack(void(*copy_ptf)(void), u16 copy_u16DesiredTime){
    1606:	df 93       	push	r29
    1608:	cf 93       	push	r28
    160a:	00 d0       	rcall	.+0      	; 0x160c <TMR0_voidSetCallBack+0x6>
    160c:	00 d0       	rcall	.+0      	; 0x160e <TMR0_voidSetCallBack+0x8>
    160e:	cd b7       	in	r28, 0x3d	; 61
    1610:	de b7       	in	r29, 0x3e	; 62
    1612:	9a 83       	std	Y+2, r25	; 0x02
    1614:	89 83       	std	Y+1, r24	; 0x01
    1616:	7c 83       	std	Y+4, r23	; 0x04
    1618:	6b 83       	std	Y+3, r22	; 0x03

#if MODE == NORMAL_MODE
	if(copy_ptf != NULL_PTR){
    161a:	89 81       	ldd	r24, Y+1	; 0x01
    161c:	9a 81       	ldd	r25, Y+2	; 0x02
    161e:	00 97       	sbiw	r24, 0x00	; 0
    1620:	99 f0       	breq	.+38     	; 0x1648 <TMR0_voidSetCallBack+0x42>
		TMR0_CallBack = copy_ptf;
    1622:	89 81       	ldd	r24, Y+1	; 0x01
    1624:	9a 81       	ldd	r25, Y+2	; 0x02
    1626:	90 93 8b 01 	sts	0x018B, r25
    162a:	80 93 8a 01 	sts	0x018A, r24
		TMR0_voidCalculateNumberOfOverFlows(copy_u16DesiredTime);
    162e:	8b 81       	ldd	r24, Y+3	; 0x03
    1630:	9c 81       	ldd	r25, Y+4	; 0x04
    1632:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <TMR0_voidCalculateNumberOfOverFlows>
		TCNT0_REG = (u8)global_u16Preload;
    1636:	e2 e5       	ldi	r30, 0x52	; 82
    1638:	f0 e0       	ldi	r31, 0x00	; 0
    163a:	80 91 9a 01 	lds	r24, 0x019A
    163e:	90 91 9b 01 	lds	r25, 0x019B
    1642:	80 83       	st	Z, r24
		TMR0_voidStart();
    1644:	0e 94 cb 0a 	call	0x1596	; 0x1596 <TMR0_voidStart>
		OCR0_REG = (u8)(global_u16OverFlowTicks-1);
		TMR0_voidStart();
	}
#endif

}
    1648:	0f 90       	pop	r0
    164a:	0f 90       	pop	r0
    164c:	0f 90       	pop	r0
    164e:	0f 90       	pop	r0
    1650:	cf 91       	pop	r28
    1652:	df 91       	pop	r29
    1654:	08 95       	ret

00001656 <TMR0_voidGeneratePWM>:

void TMR0_voidGeneratePWM(u8 copy_u8DutyCyclePercent){
    1656:	df 93       	push	r29
    1658:	cf 93       	push	r28
    165a:	0f 92       	push	r0
    165c:	cd b7       	in	r28, 0x3d	; 61
    165e:	de b7       	in	r29, 0x3e	; 62
    1660:	89 83       	std	Y+1, r24	; 0x01
	DIO_voidSetPinDirection(OC0_PORT,OC0_PIN,PIN_OUTPUT);
    1662:	81 e0       	ldi	r24, 0x01	; 1
    1664:	63 e0       	ldi	r22, 0x03	; 3
    1666:	41 e0       	ldi	r20, 0x01	; 1
    1668:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
		TMR0_voidStart();
	#endif

#endif

}
    166c:	0f 90       	pop	r0
    166e:	cf 91       	pop	r28
    1670:	df 91       	pop	r29
    1672:	08 95       	ret

00001674 <__vector_10>:

/*** Timer_0 Compare Match ISR ***/
void __vector_10() __attribute__((signal));
void __vector_10(){
    1674:	1f 92       	push	r1
    1676:	0f 92       	push	r0
    1678:	0f b6       	in	r0, 0x3f	; 63
    167a:	0f 92       	push	r0
    167c:	11 24       	eor	r1, r1
    167e:	2f 93       	push	r18
    1680:	3f 93       	push	r19
    1682:	4f 93       	push	r20
    1684:	5f 93       	push	r21
    1686:	6f 93       	push	r22
    1688:	7f 93       	push	r23
    168a:	8f 93       	push	r24
    168c:	9f 93       	push	r25
    168e:	af 93       	push	r26
    1690:	bf 93       	push	r27
    1692:	ef 93       	push	r30
    1694:	ff 93       	push	r31
    1696:	df 93       	push	r29
    1698:	cf 93       	push	r28
    169a:	cd b7       	in	r28, 0x3d	; 61
    169c:	de b7       	in	r29, 0x3e	; 62
	static u32 static_u32OverFlowsCntr=0;
	static_u32OverFlowsCntr++;
    169e:	80 91 8c 01 	lds	r24, 0x018C
    16a2:	90 91 8d 01 	lds	r25, 0x018D
    16a6:	a0 91 8e 01 	lds	r26, 0x018E
    16aa:	b0 91 8f 01 	lds	r27, 0x018F
    16ae:	01 96       	adiw	r24, 0x01	; 1
    16b0:	a1 1d       	adc	r26, r1
    16b2:	b1 1d       	adc	r27, r1
    16b4:	80 93 8c 01 	sts	0x018C, r24
    16b8:	90 93 8d 01 	sts	0x018D, r25
    16bc:	a0 93 8e 01 	sts	0x018E, r26
    16c0:	b0 93 8f 01 	sts	0x018F, r27

	if(static_u32OverFlowsCntr == global_u32OverFlows){
    16c4:	20 91 8c 01 	lds	r18, 0x018C
    16c8:	30 91 8d 01 	lds	r19, 0x018D
    16cc:	40 91 8e 01 	lds	r20, 0x018E
    16d0:	50 91 8f 01 	lds	r21, 0x018F
    16d4:	80 91 96 01 	lds	r24, 0x0196
    16d8:	90 91 97 01 	lds	r25, 0x0197
    16dc:	a0 91 98 01 	lds	r26, 0x0198
    16e0:	b0 91 99 01 	lds	r27, 0x0199
    16e4:	28 17       	cp	r18, r24
    16e6:	39 07       	cpc	r19, r25
    16e8:	4a 07       	cpc	r20, r26
    16ea:	5b 07       	cpc	r21, r27
    16ec:	69 f4       	brne	.+26     	; 0x1708 <__vector_10+0x94>
		TMR0_CallBack();
    16ee:	e0 91 8a 01 	lds	r30, 0x018A
    16f2:	f0 91 8b 01 	lds	r31, 0x018B
    16f6:	09 95       	icall
		static_u32OverFlowsCntr=0;
    16f8:	10 92 8c 01 	sts	0x018C, r1
    16fc:	10 92 8d 01 	sts	0x018D, r1
    1700:	10 92 8e 01 	sts	0x018E, r1
    1704:	10 92 8f 01 	sts	0x018F, r1
	}
}
    1708:	cf 91       	pop	r28
    170a:	df 91       	pop	r29
    170c:	ff 91       	pop	r31
    170e:	ef 91       	pop	r30
    1710:	bf 91       	pop	r27
    1712:	af 91       	pop	r26
    1714:	9f 91       	pop	r25
    1716:	8f 91       	pop	r24
    1718:	7f 91       	pop	r23
    171a:	6f 91       	pop	r22
    171c:	5f 91       	pop	r21
    171e:	4f 91       	pop	r20
    1720:	3f 91       	pop	r19
    1722:	2f 91       	pop	r18
    1724:	0f 90       	pop	r0
    1726:	0f be       	out	0x3f, r0	; 63
    1728:	0f 90       	pop	r0
    172a:	1f 90       	pop	r1
    172c:	18 95       	reti

0000172e <__vector_11>:

/**** Timer_0 ISR ****/
void __vector_11() __attribute__((signal));
void __vector_11(){
    172e:	1f 92       	push	r1
    1730:	0f 92       	push	r0
    1732:	0f b6       	in	r0, 0x3f	; 63
    1734:	0f 92       	push	r0
    1736:	11 24       	eor	r1, r1
    1738:	2f 93       	push	r18
    173a:	3f 93       	push	r19
    173c:	4f 93       	push	r20
    173e:	5f 93       	push	r21
    1740:	6f 93       	push	r22
    1742:	7f 93       	push	r23
    1744:	8f 93       	push	r24
    1746:	9f 93       	push	r25
    1748:	af 93       	push	r26
    174a:	bf 93       	push	r27
    174c:	ef 93       	push	r30
    174e:	ff 93       	push	r31
    1750:	df 93       	push	r29
    1752:	cf 93       	push	r28
    1754:	cd b7       	in	r28, 0x3d	; 61
    1756:	de b7       	in	r29, 0x3e	; 62
	static u32 static_u32OverFlowsCntr=0;
	static_u32OverFlowsCntr++;
    1758:	80 91 90 01 	lds	r24, 0x0190
    175c:	90 91 91 01 	lds	r25, 0x0191
    1760:	a0 91 92 01 	lds	r26, 0x0192
    1764:	b0 91 93 01 	lds	r27, 0x0193
    1768:	01 96       	adiw	r24, 0x01	; 1
    176a:	a1 1d       	adc	r26, r1
    176c:	b1 1d       	adc	r27, r1
    176e:	80 93 90 01 	sts	0x0190, r24
    1772:	90 93 91 01 	sts	0x0191, r25
    1776:	a0 93 92 01 	sts	0x0192, r26
    177a:	b0 93 93 01 	sts	0x0193, r27

	if(static_u32OverFlowsCntr==global_u32OverFlows){
    177e:	20 91 90 01 	lds	r18, 0x0190
    1782:	30 91 91 01 	lds	r19, 0x0191
    1786:	40 91 92 01 	lds	r20, 0x0192
    178a:	50 91 93 01 	lds	r21, 0x0193
    178e:	80 91 96 01 	lds	r24, 0x0196
    1792:	90 91 97 01 	lds	r25, 0x0197
    1796:	a0 91 98 01 	lds	r26, 0x0198
    179a:	b0 91 99 01 	lds	r27, 0x0199
    179e:	28 17       	cp	r18, r24
    17a0:	39 07       	cpc	r19, r25
    17a2:	4a 07       	cpc	r20, r26
    17a4:	5b 07       	cpc	r21, r27
    17a6:	a1 f4       	brne	.+40     	; 0x17d0 <__vector_11+0xa2>
		TMR0_CallBack();
    17a8:	e0 91 8a 01 	lds	r30, 0x018A
    17ac:	f0 91 8b 01 	lds	r31, 0x018B
    17b0:	09 95       	icall
		static_u32OverFlowsCntr=0;
    17b2:	10 92 90 01 	sts	0x0190, r1
    17b6:	10 92 91 01 	sts	0x0191, r1
    17ba:	10 92 92 01 	sts	0x0192, r1
    17be:	10 92 93 01 	sts	0x0193, r1
		TCNT0_REG = global_u16Preload;
    17c2:	e2 e5       	ldi	r30, 0x52	; 82
    17c4:	f0 e0       	ldi	r31, 0x00	; 0
    17c6:	80 91 9a 01 	lds	r24, 0x019A
    17ca:	90 91 9b 01 	lds	r25, 0x019B
    17ce:	80 83       	st	Z, r24
	}
}
    17d0:	cf 91       	pop	r28
    17d2:	df 91       	pop	r29
    17d4:	ff 91       	pop	r31
    17d6:	ef 91       	pop	r30
    17d8:	bf 91       	pop	r27
    17da:	af 91       	pop	r26
    17dc:	9f 91       	pop	r25
    17de:	8f 91       	pop	r24
    17e0:	7f 91       	pop	r23
    17e2:	6f 91       	pop	r22
    17e4:	5f 91       	pop	r21
    17e6:	4f 91       	pop	r20
    17e8:	3f 91       	pop	r19
    17ea:	2f 91       	pop	r18
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63
    17f0:	0f 90       	pop	r0
    17f2:	1f 90       	pop	r1
    17f4:	18 95       	reti

000017f6 <SPI_voidInit>:
#include "SPI_Config.h"
#include "SPI_Interface.h"

#include "../../HAL/LED/LED_Interface.h"

void SPI_voidInit(void){
    17f6:	df 93       	push	r29
    17f8:	cf 93       	push	r28
    17fa:	cd b7       	in	r28, 0x3d	; 61
    17fc:	de b7       	in	r29, 0x3e	; 62
#if SPI_MODE == MASTER
	SET_BIT(SPCR_REG, SPCR_MSTR); //Master mode
    17fe:	ad e2       	ldi	r26, 0x2D	; 45
    1800:	b0 e0       	ldi	r27, 0x00	; 0
    1802:	ed e2       	ldi	r30, 0x2D	; 45
    1804:	f0 e0       	ldi	r31, 0x00	; 0
    1806:	80 81       	ld	r24, Z
    1808:	80 61       	ori	r24, 0x10	; 16
    180a:	8c 93       	st	X, r24
	CLR_BIT(SPCR_REG, SPCR_DORD); //MSB
    180c:	ad e2       	ldi	r26, 0x2D	; 45
    180e:	b0 e0       	ldi	r27, 0x00	; 0
    1810:	ed e2       	ldi	r30, 0x2D	; 45
    1812:	f0 e0       	ldi	r31, 0x00	; 0
    1814:	80 81       	ld	r24, Z
    1816:	8f 7d       	andi	r24, 0xDF	; 223
    1818:	8c 93       	st	X, r24
	/*** Prescaler=16 ***/
	SET_BIT(SPCR_REG,SPCR_SPR0);
    181a:	ad e2       	ldi	r26, 0x2D	; 45
    181c:	b0 e0       	ldi	r27, 0x00	; 0
    181e:	ed e2       	ldi	r30, 0x2D	; 45
    1820:	f0 e0       	ldi	r31, 0x00	; 0
    1822:	80 81       	ld	r24, Z
    1824:	81 60       	ori	r24, 0x01	; 1
    1826:	8c 93       	st	X, r24
	/***Pin Configuration***/
	DIO_voidSetPinDirection(SPI_PORT,SS,  PIN_OUTPUT);
    1828:	81 e0       	ldi	r24, 0x01	; 1
    182a:	64 e0       	ldi	r22, 0x04	; 4
    182c:	41 e0       	ldi	r20, 0x01	; 1
    182e:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(SPI_PORT,MOSI,PIN_OUTPUT);
    1832:	81 e0       	ldi	r24, 0x01	; 1
    1834:	65 e0       	ldi	r22, 0x05	; 5
    1836:	41 e0       	ldi	r20, 0x01	; 1
    1838:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(SPI_PORT,MISO,PIN_INPUT);
    183c:	81 e0       	ldi	r24, 0x01	; 1
    183e:	66 e0       	ldi	r22, 0x06	; 6
    1840:	40 e0       	ldi	r20, 0x00	; 0
    1842:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(SPI_PORT,SCK, PIN_OUTPUT);
    1846:	81 e0       	ldi	r24, 0x01	; 1
    1848:	67 e0       	ldi	r22, 0x07	; 7
    184a:	41 e0       	ldi	r20, 0x01	; 1
    184c:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinValue(SPI_PORT,SS, PIN_LOW);
    1850:	81 e0       	ldi	r24, 0x01	; 1
    1852:	64 e0       	ldi	r22, 0x04	; 4
    1854:	40 e0       	ldi	r20, 0x00	; 0
    1856:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	/***SPI Enable ***/
	SET_BIT(SPCR_REG, SPCR_SPE);
    185a:	ad e2       	ldi	r26, 0x2D	; 45
    185c:	b0 e0       	ldi	r27, 0x00	; 0
    185e:	ed e2       	ldi	r30, 0x2D	; 45
    1860:	f0 e0       	ldi	r31, 0x00	; 0
    1862:	80 81       	ld	r24, Z
    1864:	80 64       	ori	r24, 0x40	; 64
    1866:	8c 93       	st	X, r24
	DIO_voidSetPinDirection(SPI_PORT,MISO,PIN_OUTPUT);
	DIO_voidSetPinDirection(SPI_PORT,SCK, PIN_INPUT);
	/***SPI Enable ***/
	SET_BIT(SPCR_REG, SPCR_SPE);
#endif
}
    1868:	cf 91       	pop	r28
    186a:	df 91       	pop	r29
    186c:	08 95       	ret

0000186e <SPI_voidTransmitAndReceive>:

u8 SPI_voidTransmitAndReceive(u8 copy_u8Data){
    186e:	df 93       	push	r29
    1870:	cf 93       	push	r28
    1872:	0f 92       	push	r0
    1874:	cd b7       	in	r28, 0x3d	; 61
    1876:	de b7       	in	r29, 0x3e	; 62
    1878:	89 83       	std	Y+1, r24	; 0x01
	SPDR_REG = copy_u8Data;
    187a:	ef e2       	ldi	r30, 0x2F	; 47
    187c:	f0 e0       	ldi	r31, 0x00	; 0
    187e:	89 81       	ldd	r24, Y+1	; 0x01
    1880:	80 83       	st	Z, r24
	while(!GET_BIT(SPSR_REG,SPSR_SPIF));
    1882:	ee e2       	ldi	r30, 0x2E	; 46
    1884:	f0 e0       	ldi	r31, 0x00	; 0
    1886:	80 81       	ld	r24, Z
    1888:	88 23       	and	r24, r24
    188a:	dc f7       	brge	.-10     	; 0x1882 <SPI_voidTransmitAndReceive+0x14>
	return SPDR_REG;
    188c:	ef e2       	ldi	r30, 0x2F	; 47
    188e:	f0 e0       	ldi	r31, 0x00	; 0
    1890:	80 81       	ld	r24, Z
}
    1892:	0f 90       	pop	r0
    1894:	cf 91       	pop	r28
    1896:	df 91       	pop	r29
    1898:	08 95       	ret

0000189a <I2C_voidMastrInit>:
/****I2C****/
#include "I2C_Interface.h"
#include "I2C_Private.h"
#include "I2C_Config.h"

void I2C_voidMastrInit(void){
    189a:	df 93       	push	r29
    189c:	cf 93       	push	r28
    189e:	cd b7       	in	r28, 0x3d	; 61
    18a0:	de b7       	in	r29, 0x3e	; 62

	/*		Set the Bit Rate = 100KHz			*/
	TWBR_REG = 72;
    18a2:	e0 e2       	ldi	r30, 0x20	; 32
    18a4:	f0 e0       	ldi	r31, 0x00	; 0
    18a6:	88 e4       	ldi	r24, 0x48	; 72
    18a8:	80 83       	st	Z, r24
	/*		Enable I2C							*/
	SET_BIT(TWCR_REG, TWCR_TWEN);
    18aa:	a6 e5       	ldi	r26, 0x56	; 86
    18ac:	b0 e0       	ldi	r27, 0x00	; 0
    18ae:	e6 e5       	ldi	r30, 0x56	; 86
    18b0:	f0 e0       	ldi	r31, 0x00	; 0
    18b2:	80 81       	ld	r24, Z
    18b4:	84 60       	ori	r24, 0x04	; 4
    18b6:	8c 93       	st	X, r24
	/*		Enable ACK							*/
	SET_BIT(TWCR_REG, TWCR_TWEA);
    18b8:	a6 e5       	ldi	r26, 0x56	; 86
    18ba:	b0 e0       	ldi	r27, 0x00	; 0
    18bc:	e6 e5       	ldi	r30, 0x56	; 86
    18be:	f0 e0       	ldi	r31, 0x00	; 0
    18c0:	80 81       	ld	r24, Z
    18c2:	80 64       	ori	r24, 0x40	; 64
    18c4:	8c 93       	st	X, r24
	/*		Assign the master Address			*/
	TWAR_REG = (MASTER_ADD<<1);
    18c6:	e2 e2       	ldi	r30, 0x22	; 34
    18c8:	f0 e0       	ldi	r31, 0x00	; 0
    18ca:	80 e4       	ldi	r24, 0x40	; 64
    18cc:	80 83       	st	Z, r24

}
    18ce:	cf 91       	pop	r28
    18d0:	df 91       	pop	r29
    18d2:	08 95       	ret

000018d4 <I2C_voidSlaveInit>:

void I2C_voidSlaveInit(u8 Copy_u8SlaveAdd){
    18d4:	df 93       	push	r29
    18d6:	cf 93       	push	r28
    18d8:	0f 92       	push	r0
    18da:	cd b7       	in	r28, 0x3d	; 61
    18dc:	de b7       	in	r29, 0x3e	; 62
    18de:	89 83       	std	Y+1, r24	; 0x01

	/*		Enable I2C							*/
	SET_BIT(TWCR_REG, TWCR_TWEN);
    18e0:	a6 e5       	ldi	r26, 0x56	; 86
    18e2:	b0 e0       	ldi	r27, 0x00	; 0
    18e4:	e6 e5       	ldi	r30, 0x56	; 86
    18e6:	f0 e0       	ldi	r31, 0x00	; 0
    18e8:	80 81       	ld	r24, Z
    18ea:	84 60       	ori	r24, 0x04	; 4
    18ec:	8c 93       	st	X, r24
	/*		Enable ACK							*/
	SET_BIT(TWCR_REG, TWCR_TWEA);
    18ee:	a6 e5       	ldi	r26, 0x56	; 86
    18f0:	b0 e0       	ldi	r27, 0x00	; 0
    18f2:	e6 e5       	ldi	r30, 0x56	; 86
    18f4:	f0 e0       	ldi	r31, 0x00	; 0
    18f6:	80 81       	ld	r24, Z
    18f8:	80 64       	ori	r24, 0x40	; 64
    18fa:	8c 93       	st	X, r24
	/*		Assign the Slave Address			*/
	TWAR_REG = (Copy_u8SlaveAdd<<1);
    18fc:	e2 e2       	ldi	r30, 0x22	; 34
    18fe:	f0 e0       	ldi	r31, 0x00	; 0
    1900:	89 81       	ldd	r24, Y+1	; 0x01
    1902:	88 0f       	add	r24, r24
    1904:	80 83       	st	Z, r24

}
    1906:	0f 90       	pop	r0
    1908:	cf 91       	pop	r28
    190a:	df 91       	pop	r29
    190c:	08 95       	ret

0000190e <I2C_enuSendStrCond>:


I2C_Error I2C_enuSendStrCond(void){
    190e:	df 93       	push	r29
    1910:	cf 93       	push	r28
    1912:	0f 92       	push	r0
    1914:	cd b7       	in	r28, 0x3d	; 61
    1916:	de b7       	in	r29, 0x3e	; 62

	I2C_Error local_enuErr = I2C_NOK;
    1918:	81 e0       	ldi	r24, 0x01	; 1
    191a:	89 83       	std	Y+1, r24	; 0x01
	/*         Clear Interrupt Flag            */
	SET_BIT(TWCR_REG, TWCR_TWINT);
    191c:	a6 e5       	ldi	r26, 0x56	; 86
    191e:	b0 e0       	ldi	r27, 0x00	; 0
    1920:	e6 e5       	ldi	r30, 0x56	; 86
    1922:	f0 e0       	ldi	r31, 0x00	; 0
    1924:	80 81       	ld	r24, Z
    1926:	80 68       	ori	r24, 0x80	; 128
    1928:	8c 93       	st	X, r24
	/*         Send Start Condition                 */
	SET_BIT(TWCR_REG, TWCR_TWSTA);
    192a:	a6 e5       	ldi	r26, 0x56	; 86
    192c:	b0 e0       	ldi	r27, 0x00	; 0
    192e:	e6 e5       	ldi	r30, 0x56	; 86
    1930:	f0 e0       	ldi	r31, 0x00	; 0
    1932:	80 81       	ld	r24, Z
    1934:	80 62       	ori	r24, 0x20	; 32
    1936:	8c 93       	st	X, r24
	/*         Wait for Flag                   */
	while(!GET_BIT(TWCR_REG, TWCR_TWINT));
    1938:	e6 e5       	ldi	r30, 0x56	; 86
    193a:	f0 e0       	ldi	r31, 0x00	; 0
    193c:	80 81       	ld	r24, Z
    193e:	88 23       	and	r24, r24
    1940:	dc f7       	brge	.-10     	; 0x1938 <I2C_enuSendStrCond+0x2a>
	/*         Check for error                 */
	if((TWSR_REG & 0xF8) == START_COD_OK){
    1942:	e1 e2       	ldi	r30, 0x21	; 33
    1944:	f0 e0       	ldi	r31, 0x00	; 0
    1946:	80 81       	ld	r24, Z
    1948:	88 2f       	mov	r24, r24
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	88 7f       	andi	r24, 0xF8	; 248
    194e:	90 70       	andi	r25, 0x00	; 0
    1950:	88 30       	cpi	r24, 0x08	; 8
    1952:	91 05       	cpc	r25, r1
    1954:	11 f4       	brne	.+4      	; 0x195a <I2C_enuSendStrCond+0x4c>
		local_enuErr = I2C_OK;
    1956:	19 82       	std	Y+1, r1	; 0x01
    1958:	02 c0       	rjmp	.+4      	; 0x195e <I2C_enuSendStrCond+0x50>
	}
	else{
		local_enuErr = START_COD_ERR;
    195a:	82 e0       	ldi	r24, 0x02	; 2
    195c:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_enuErr;
    195e:	89 81       	ldd	r24, Y+1	; 0x01

}
    1960:	0f 90       	pop	r0
    1962:	cf 91       	pop	r28
    1964:	df 91       	pop	r29
    1966:	08 95       	ret

00001968 <I2C_enuSendStopCond>:

I2C_Error I2C_enuSendStopCond(void){
    1968:	df 93       	push	r29
    196a:	cf 93       	push	r28
    196c:	00 d0       	rcall	.+0      	; 0x196e <I2C_enuSendStopCond+0x6>
    196e:	00 d0       	rcall	.+0      	; 0x1970 <I2C_enuSendStopCond+0x8>
    1970:	0f 92       	push	r0
    1972:	cd b7       	in	r28, 0x3d	; 61
    1974:	de b7       	in	r29, 0x3e	; 62

	u32 local_u32timeOut = 0;
    1976:	1a 82       	std	Y+2, r1	; 0x02
    1978:	1b 82       	std	Y+3, r1	; 0x03
    197a:	1c 82       	std	Y+4, r1	; 0x04
    197c:	1d 82       	std	Y+5, r1	; 0x05
	I2C_Error local_enuErr = I2C_NOK;
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	89 83       	std	Y+1, r24	; 0x01
	/*         Clear Interrupt Flag            */
	SET_BIT(TWCR_REG, TWCR_TWINT);
    1982:	a6 e5       	ldi	r26, 0x56	; 86
    1984:	b0 e0       	ldi	r27, 0x00	; 0
    1986:	e6 e5       	ldi	r30, 0x56	; 86
    1988:	f0 e0       	ldi	r31, 0x00	; 0
    198a:	80 81       	ld	r24, Z
    198c:	80 68       	ori	r24, 0x80	; 128
    198e:	8c 93       	st	X, r24
	/*         Send Stop Condition             */
	SET_BIT(TWCR_REG, TWCR_TWSTO);
    1990:	a6 e5       	ldi	r26, 0x56	; 86
    1992:	b0 e0       	ldi	r27, 0x00	; 0
    1994:	e6 e5       	ldi	r30, 0x56	; 86
    1996:	f0 e0       	ldi	r31, 0x00	; 0
    1998:	80 81       	ld	r24, Z
    199a:	80 61       	ori	r24, 0x10	; 16
    199c:	8c 93       	st	X, r24
    199e:	0b c0       	rjmp	.+22     	; 0x19b6 <I2C_enuSendStopCond+0x4e>
	/*         Wait for Flag                   */
	while(!GET_BIT(TWCR_REG, TWCR_TWINT) && local_u32timeOut<=1000000UL){
		 local_u32timeOut++;
    19a0:	8a 81       	ldd	r24, Y+2	; 0x02
    19a2:	9b 81       	ldd	r25, Y+3	; 0x03
    19a4:	ac 81       	ldd	r26, Y+4	; 0x04
    19a6:	bd 81       	ldd	r27, Y+5	; 0x05
    19a8:	01 96       	adiw	r24, 0x01	; 1
    19aa:	a1 1d       	adc	r26, r1
    19ac:	b1 1d       	adc	r27, r1
    19ae:	8a 83       	std	Y+2, r24	; 0x02
    19b0:	9b 83       	std	Y+3, r25	; 0x03
    19b2:	ac 83       	std	Y+4, r26	; 0x04
    19b4:	bd 83       	std	Y+5, r27	; 0x05
	/*         Clear Interrupt Flag            */
	SET_BIT(TWCR_REG, TWCR_TWINT);
	/*         Send Stop Condition             */
	SET_BIT(TWCR_REG, TWCR_TWSTO);
	/*         Wait for Flag                   */
	while(!GET_BIT(TWCR_REG, TWCR_TWINT) && local_u32timeOut<=1000000UL){
    19b6:	e6 e5       	ldi	r30, 0x56	; 86
    19b8:	f0 e0       	ldi	r31, 0x00	; 0
    19ba:	80 81       	ld	r24, Z
    19bc:	88 23       	and	r24, r24
    19be:	64 f0       	brlt	.+24     	; 0x19d8 <I2C_enuSendStopCond+0x70>
    19c0:	8a 81       	ldd	r24, Y+2	; 0x02
    19c2:	9b 81       	ldd	r25, Y+3	; 0x03
    19c4:	ac 81       	ldd	r26, Y+4	; 0x04
    19c6:	bd 81       	ldd	r27, Y+5	; 0x05
    19c8:	81 34       	cpi	r24, 0x41	; 65
    19ca:	22 e4       	ldi	r18, 0x42	; 66
    19cc:	92 07       	cpc	r25, r18
    19ce:	2f e0       	ldi	r18, 0x0F	; 15
    19d0:	a2 07       	cpc	r26, r18
    19d2:	20 e0       	ldi	r18, 0x00	; 0
    19d4:	b2 07       	cpc	r27, r18
    19d6:	20 f3       	brcs	.-56     	; 0x19a0 <I2C_enuSendStopCond+0x38>
		 local_u32timeOut++;
	}
	/*         Check for error                 */
	if(local_u32timeOut>=1000000UL){
    19d8:	8a 81       	ldd	r24, Y+2	; 0x02
    19da:	9b 81       	ldd	r25, Y+3	; 0x03
    19dc:	ac 81       	ldd	r26, Y+4	; 0x04
    19de:	bd 81       	ldd	r27, Y+5	; 0x05
    19e0:	80 34       	cpi	r24, 0x40	; 64
    19e2:	22 e4       	ldi	r18, 0x42	; 66
    19e4:	92 07       	cpc	r25, r18
    19e6:	2f e0       	ldi	r18, 0x0F	; 15
    19e8:	a2 07       	cpc	r26, r18
    19ea:	20 e0       	ldi	r18, 0x00	; 0
    19ec:	b2 07       	cpc	r27, r18
    19ee:	18 f0       	brcs	.+6      	; 0x19f6 <I2C_enuSendStopCond+0x8e>
		local_enuErr = TIMEOUT_ERR;
    19f0:	8a e0       	ldi	r24, 0x0A	; 10
    19f2:	89 83       	std	Y+1, r24	; 0x01
    19f4:	0e c0       	rjmp	.+28     	; 0x1a12 <I2C_enuSendStopCond+0xaa>
	}
	else if((TWSR_REG & 0xF8) == STOP_COD_OK){
    19f6:	e1 e2       	ldi	r30, 0x21	; 33
    19f8:	f0 e0       	ldi	r31, 0x00	; 0
    19fa:	80 81       	ld	r24, Z
    19fc:	88 2f       	mov	r24, r24
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	88 7f       	andi	r24, 0xF8	; 248
    1a02:	90 70       	andi	r25, 0x00	; 0
    1a04:	80 3a       	cpi	r24, 0xA0	; 160
    1a06:	91 05       	cpc	r25, r1
    1a08:	11 f4       	brne	.+4      	; 0x1a0e <I2C_enuSendStopCond+0xa6>
		local_enuErr = I2C_OK;
    1a0a:	19 82       	std	Y+1, r1	; 0x01
    1a0c:	02 c0       	rjmp	.+4      	; 0x1a12 <I2C_enuSendStopCond+0xaa>
	}
	else{
		local_enuErr = STOP_COD_ERR;
    1a0e:	83 e0       	ldi	r24, 0x03	; 3
    1a10:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_enuErr;
    1a12:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a14:	0f 90       	pop	r0
    1a16:	0f 90       	pop	r0
    1a18:	0f 90       	pop	r0
    1a1a:	0f 90       	pop	r0
    1a1c:	0f 90       	pop	r0
    1a1e:	cf 91       	pop	r28
    1a20:	df 91       	pop	r29
    1a22:	08 95       	ret

00001a24 <I2C_enuSendSlAWrite>:

I2C_Error I2C_enuSendSlAWrite(u8 Copy_u8SlaveAdd){
    1a24:	df 93       	push	r29
    1a26:	cf 93       	push	r28
    1a28:	00 d0       	rcall	.+0      	; 0x1a2a <I2C_enuSendSlAWrite+0x6>
    1a2a:	cd b7       	in	r28, 0x3d	; 61
    1a2c:	de b7       	in	r29, 0x3e	; 62
    1a2e:	8a 83       	std	Y+2, r24	; 0x02

	I2C_Error local_enuErr = I2C_NOK;
    1a30:	81 e0       	ldi	r24, 0x01	; 1
    1a32:	89 83       	std	Y+1, r24	; 0x01
	/*         Put Address on Data Register    */
	TWDR_REG = (Copy_u8SlaveAdd<<1);
    1a34:	e3 e2       	ldi	r30, 0x23	; 35
    1a36:	f0 e0       	ldi	r31, 0x00	; 0
    1a38:	8a 81       	ldd	r24, Y+2	; 0x02
    1a3a:	88 0f       	add	r24, r24
    1a3c:	80 83       	st	Z, r24

	/*         Clear Start Condition           */
	CLR_BIT(TWCR_REG, TWCR_TWSTA);
    1a3e:	a6 e5       	ldi	r26, 0x56	; 86
    1a40:	b0 e0       	ldi	r27, 0x00	; 0
    1a42:	e6 e5       	ldi	r30, 0x56	; 86
    1a44:	f0 e0       	ldi	r31, 0x00	; 0
    1a46:	80 81       	ld	r24, Z
    1a48:	8f 7d       	andi	r24, 0xDF	; 223
    1a4a:	8c 93       	st	X, r24

	/*         Clear Interrupt Flag            */
	SET_BIT(TWCR_REG, TWCR_TWINT);
    1a4c:	a6 e5       	ldi	r26, 0x56	; 86
    1a4e:	b0 e0       	ldi	r27, 0x00	; 0
    1a50:	e6 e5       	ldi	r30, 0x56	; 86
    1a52:	f0 e0       	ldi	r31, 0x00	; 0
    1a54:	80 81       	ld	r24, Z
    1a56:	80 68       	ori	r24, 0x80	; 128
    1a58:	8c 93       	st	X, r24

	/*         Wait for Flag                   */
	while(!GET_BIT(TWCR_REG, TWCR_TWINT));
    1a5a:	e6 e5       	ldi	r30, 0x56	; 86
    1a5c:	f0 e0       	ldi	r31, 0x00	; 0
    1a5e:	80 81       	ld	r24, Z
    1a60:	88 23       	and	r24, r24
    1a62:	dc f7       	brge	.-10     	; 0x1a5a <I2C_enuSendSlAWrite+0x36>

	/*         Check for error                 */
	if((TWSR_REG & 0xF8) == SLA_W_OK){
    1a64:	e1 e2       	ldi	r30, 0x21	; 33
    1a66:	f0 e0       	ldi	r31, 0x00	; 0
    1a68:	80 81       	ld	r24, Z
    1a6a:	88 2f       	mov	r24, r24
    1a6c:	90 e0       	ldi	r25, 0x00	; 0
    1a6e:	88 7f       	andi	r24, 0xF8	; 248
    1a70:	90 70       	andi	r25, 0x00	; 0
    1a72:	88 31       	cpi	r24, 0x18	; 24
    1a74:	91 05       	cpc	r25, r1
    1a76:	11 f4       	brne	.+4      	; 0x1a7c <I2C_enuSendSlAWrite+0x58>
		local_enuErr = I2C_OK;
    1a78:	19 82       	std	Y+1, r1	; 0x01
    1a7a:	02 c0       	rjmp	.+4      	; 0x1a80 <I2C_enuSendSlAWrite+0x5c>
	}
	else{
		local_enuErr = SLA_W_ERR;
    1a7c:	84 e0       	ldi	r24, 0x04	; 4
    1a7e:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_enuErr;
    1a80:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a82:	0f 90       	pop	r0
    1a84:	0f 90       	pop	r0
    1a86:	cf 91       	pop	r28
    1a88:	df 91       	pop	r29
    1a8a:	08 95       	ret

00001a8c <I2C_enuSendSlARead>:

I2C_Error I2C_enuSendSlARead(u8 Copy_u8SlaveAdd){
    1a8c:	df 93       	push	r29
    1a8e:	cf 93       	push	r28
    1a90:	00 d0       	rcall	.+0      	; 0x1a92 <I2C_enuSendSlARead+0x6>
    1a92:	cd b7       	in	r28, 0x3d	; 61
    1a94:	de b7       	in	r29, 0x3e	; 62
    1a96:	8a 83       	std	Y+2, r24	; 0x02

	I2C_Error local_enuErr = I2C_NOK;
    1a98:	81 e0       	ldi	r24, 0x01	; 1
    1a9a:	89 83       	std	Y+1, r24	; 0x01
	/*         Put Address on Data Register    */
	TWDR_REG = ((Copy_u8SlaveAdd<<1) | 0x01) ; //ORed with one for read
    1a9c:	e3 e2       	ldi	r30, 0x23	; 35
    1a9e:	f0 e0       	ldi	r31, 0x00	; 0
    1aa0:	8a 81       	ldd	r24, Y+2	; 0x02
    1aa2:	88 2f       	mov	r24, r24
    1aa4:	90 e0       	ldi	r25, 0x00	; 0
    1aa6:	88 0f       	add	r24, r24
    1aa8:	99 1f       	adc	r25, r25
    1aaa:	81 60       	ori	r24, 0x01	; 1
    1aac:	80 83       	st	Z, r24

	/*         Clear Start Condition           */
	CLR_BIT(TWCR_REG, TWCR_TWSTA);
    1aae:	a6 e5       	ldi	r26, 0x56	; 86
    1ab0:	b0 e0       	ldi	r27, 0x00	; 0
    1ab2:	e6 e5       	ldi	r30, 0x56	; 86
    1ab4:	f0 e0       	ldi	r31, 0x00	; 0
    1ab6:	80 81       	ld	r24, Z
    1ab8:	8f 7d       	andi	r24, 0xDF	; 223
    1aba:	8c 93       	st	X, r24

	/*         Clear Interrupt Flag            */
	SET_BIT(TWCR_REG, TWCR_TWINT);
    1abc:	a6 e5       	ldi	r26, 0x56	; 86
    1abe:	b0 e0       	ldi	r27, 0x00	; 0
    1ac0:	e6 e5       	ldi	r30, 0x56	; 86
    1ac2:	f0 e0       	ldi	r31, 0x00	; 0
    1ac4:	80 81       	ld	r24, Z
    1ac6:	80 68       	ori	r24, 0x80	; 128
    1ac8:	8c 93       	st	X, r24

	/*         Wait for Flag                   */
	while(!GET_BIT(TWCR_REG, TWCR_TWINT));
    1aca:	e6 e5       	ldi	r30, 0x56	; 86
    1acc:	f0 e0       	ldi	r31, 0x00	; 0
    1ace:	80 81       	ld	r24, Z
    1ad0:	88 23       	and	r24, r24
    1ad2:	dc f7       	brge	.-10     	; 0x1aca <I2C_enuSendSlARead+0x3e>

	/*         Check for error                 */
	if((TWSR_REG & 0xF8) == SLA_R_OK){
    1ad4:	e1 e2       	ldi	r30, 0x21	; 33
    1ad6:	f0 e0       	ldi	r31, 0x00	; 0
    1ad8:	80 81       	ld	r24, Z
    1ada:	88 2f       	mov	r24, r24
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	88 7f       	andi	r24, 0xF8	; 248
    1ae0:	90 70       	andi	r25, 0x00	; 0
    1ae2:	80 34       	cpi	r24, 0x40	; 64
    1ae4:	91 05       	cpc	r25, r1
    1ae6:	11 f4       	brne	.+4      	; 0x1aec <I2C_enuSendSlARead+0x60>
		local_enuErr = I2C_OK;
    1ae8:	19 82       	std	Y+1, r1	; 0x01
    1aea:	02 c0       	rjmp	.+4      	; 0x1af0 <I2C_enuSendSlARead+0x64>
	}
	else{
		local_enuErr = SLA_R_ERR;
    1aec:	85 e0       	ldi	r24, 0x05	; 5
    1aee:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_enuErr;
    1af0:	89 81       	ldd	r24, Y+1	; 0x01

}
    1af2:	0f 90       	pop	r0
    1af4:	0f 90       	pop	r0
    1af6:	cf 91       	pop	r28
    1af8:	df 91       	pop	r29
    1afa:	08 95       	ret

00001afc <I2C_enuSendDataMstr>:

I2C_Error I2C_enuSendDataMstr(u8 Copy_u8Data){
    1afc:	df 93       	push	r29
    1afe:	cf 93       	push	r28
    1b00:	00 d0       	rcall	.+0      	; 0x1b02 <I2C_enuSendDataMstr+0x6>
    1b02:	cd b7       	in	r28, 0x3d	; 61
    1b04:	de b7       	in	r29, 0x3e	; 62
    1b06:	8a 83       	std	Y+2, r24	; 0x02

	I2C_Error local_enuErr = I2C_NOK;
    1b08:	81 e0       	ldi	r24, 0x01	; 1
    1b0a:	89 83       	std	Y+1, r24	; 0x01
	/*         Put Data on Data Register    */
	TWDR_REG = Copy_u8Data;
    1b0c:	e3 e2       	ldi	r30, 0x23	; 35
    1b0e:	f0 e0       	ldi	r31, 0x00	; 0
    1b10:	8a 81       	ldd	r24, Y+2	; 0x02
    1b12:	80 83       	st	Z, r24

	/*         Clear Interrupt Flag         */
	SET_BIT(TWCR_REG, TWCR_TWINT);
    1b14:	a6 e5       	ldi	r26, 0x56	; 86
    1b16:	b0 e0       	ldi	r27, 0x00	; 0
    1b18:	e6 e5       	ldi	r30, 0x56	; 86
    1b1a:	f0 e0       	ldi	r31, 0x00	; 0
    1b1c:	80 81       	ld	r24, Z
    1b1e:	80 68       	ori	r24, 0x80	; 128
    1b20:	8c 93       	st	X, r24

	/*         Wait for Flag                */
	while(!GET_BIT(TWCR_REG, TWCR_TWINT));
    1b22:	e6 e5       	ldi	r30, 0x56	; 86
    1b24:	f0 e0       	ldi	r31, 0x00	; 0
    1b26:	80 81       	ld	r24, Z
    1b28:	88 23       	and	r24, r24
    1b2a:	dc f7       	brge	.-10     	; 0x1b22 <I2C_enuSendDataMstr+0x26>

	/*         Check for error              */
	if((TWSR_REG & 0xF8) == DATA_MSTR_S_OK){
    1b2c:	e1 e2       	ldi	r30, 0x21	; 33
    1b2e:	f0 e0       	ldi	r31, 0x00	; 0
    1b30:	80 81       	ld	r24, Z
    1b32:	88 2f       	mov	r24, r24
    1b34:	90 e0       	ldi	r25, 0x00	; 0
    1b36:	88 7f       	andi	r24, 0xF8	; 248
    1b38:	90 70       	andi	r25, 0x00	; 0
    1b3a:	88 32       	cpi	r24, 0x28	; 40
    1b3c:	91 05       	cpc	r25, r1
    1b3e:	11 f4       	brne	.+4      	; 0x1b44 <I2C_enuSendDataMstr+0x48>
		local_enuErr = I2C_OK;
    1b40:	19 82       	std	Y+1, r1	; 0x01
    1b42:	02 c0       	rjmp	.+4      	; 0x1b48 <I2C_enuSendDataMstr+0x4c>
	}
	else{
		local_enuErr = DATA_MSTR_S_ERR;
    1b44:	86 e0       	ldi	r24, 0x06	; 6
    1b46:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_enuErr;
    1b48:	89 81       	ldd	r24, Y+1	; 0x01

}
    1b4a:	0f 90       	pop	r0
    1b4c:	0f 90       	pop	r0
    1b4e:	cf 91       	pop	r28
    1b50:	df 91       	pop	r29
    1b52:	08 95       	ret

00001b54 <I2C_enuReceiveDataMstr>:

I2C_Error I2C_enuReceiveDataMstr(u8 * Copy_u8Data){
    1b54:	df 93       	push	r29
    1b56:	cf 93       	push	r28
    1b58:	00 d0       	rcall	.+0      	; 0x1b5a <I2C_enuReceiveDataMstr+0x6>
    1b5a:	0f 92       	push	r0
    1b5c:	cd b7       	in	r28, 0x3d	; 61
    1b5e:	de b7       	in	r29, 0x3e	; 62
    1b60:	9b 83       	std	Y+3, r25	; 0x03
    1b62:	8a 83       	std	Y+2, r24	; 0x02

	I2C_Error local_enuErr = I2C_NOK;
    1b64:	81 e0       	ldi	r24, 0x01	; 1
    1b66:	89 83       	std	Y+1, r24	; 0x01
	/*         Clear Interrupt Flag            */
	SET_BIT(TWCR_REG, TWCR_TWINT);
    1b68:	a6 e5       	ldi	r26, 0x56	; 86
    1b6a:	b0 e0       	ldi	r27, 0x00	; 0
    1b6c:	e6 e5       	ldi	r30, 0x56	; 86
    1b6e:	f0 e0       	ldi	r31, 0x00	; 0
    1b70:	80 81       	ld	r24, Z
    1b72:	80 68       	ori	r24, 0x80	; 128
    1b74:	8c 93       	st	X, r24
	/*         Wait for Flag                   */
	while(!GET_BIT(TWCR_REG, TWCR_TWINT));
    1b76:	e6 e5       	ldi	r30, 0x56	; 86
    1b78:	f0 e0       	ldi	r31, 0x00	; 0
    1b7a:	80 81       	ld	r24, Z
    1b7c:	88 23       	and	r24, r24
    1b7e:	dc f7       	brge	.-10     	; 0x1b76 <I2C_enuReceiveDataMstr+0x22>
	/*         Check for error                 */
	if((TWSR_REG & 0xF8) == DATA_MSTR_R_OK){
    1b80:	e1 e2       	ldi	r30, 0x21	; 33
    1b82:	f0 e0       	ldi	r31, 0x00	; 0
    1b84:	80 81       	ld	r24, Z
    1b86:	88 2f       	mov	r24, r24
    1b88:	90 e0       	ldi	r25, 0x00	; 0
    1b8a:	88 7f       	andi	r24, 0xF8	; 248
    1b8c:	90 70       	andi	r25, 0x00	; 0
    1b8e:	80 35       	cpi	r24, 0x50	; 80
    1b90:	91 05       	cpc	r25, r1
    1b92:	41 f4       	brne	.+16     	; 0x1ba4 <I2C_enuReceiveDataMstr+0x50>
		local_enuErr = I2C_OK;
    1b94:	19 82       	std	Y+1, r1	; 0x01
		/*         Get Data from data Register     */
		*Copy_u8Data = TWDR_REG;
    1b96:	e3 e2       	ldi	r30, 0x23	; 35
    1b98:	f0 e0       	ldi	r31, 0x00	; 0
    1b9a:	80 81       	ld	r24, Z
    1b9c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b9e:	fb 81       	ldd	r31, Y+3	; 0x03
    1ba0:	80 83       	st	Z, r24
    1ba2:	02 c0       	rjmp	.+4      	; 0x1ba8 <I2C_enuReceiveDataMstr+0x54>
	}
	else{
		local_enuErr = DATA_MSTR_R_ERR;
    1ba4:	87 e0       	ldi	r24, 0x07	; 7
    1ba6:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_enuErr;
    1ba8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1baa:	0f 90       	pop	r0
    1bac:	0f 90       	pop	r0
    1bae:	0f 90       	pop	r0
    1bb0:	cf 91       	pop	r28
    1bb2:	df 91       	pop	r29
    1bb4:	08 95       	ret

00001bb6 <I2C_enuSendDataSl>:

I2C_Error I2C_enuSendDataSl(u8 Copy_u8Data){
    1bb6:	df 93       	push	r29
    1bb8:	cf 93       	push	r28
    1bba:	00 d0       	rcall	.+0      	; 0x1bbc <I2C_enuSendDataSl+0x6>
    1bbc:	cd b7       	in	r28, 0x3d	; 61
    1bbe:	de b7       	in	r29, 0x3e	; 62
    1bc0:	8a 83       	std	Y+2, r24	; 0x02

	I2C_Error local_enuErr = I2C_NOK;
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	89 83       	std	Y+1, r24	; 0x01
	/*         Put Data on Data Register       */
	TWDR_REG = Copy_u8Data;
    1bc6:	e3 e2       	ldi	r30, 0x23	; 35
    1bc8:	f0 e0       	ldi	r31, 0x00	; 0
    1bca:	8a 81       	ldd	r24, Y+2	; 0x02
    1bcc:	80 83       	st	Z, r24
	/*         Clear Interrupt Flag            */
	SET_BIT(TWCR_REG, TWCR_TWINT);
    1bce:	a6 e5       	ldi	r26, 0x56	; 86
    1bd0:	b0 e0       	ldi	r27, 0x00	; 0
    1bd2:	e6 e5       	ldi	r30, 0x56	; 86
    1bd4:	f0 e0       	ldi	r31, 0x00	; 0
    1bd6:	80 81       	ld	r24, Z
    1bd8:	80 68       	ori	r24, 0x80	; 128
    1bda:	8c 93       	st	X, r24
	/*         Wait for Flag                   */
	while(!GET_BIT(TWCR_REG, TWCR_TWINT));
    1bdc:	e6 e5       	ldi	r30, 0x56	; 86
    1bde:	f0 e0       	ldi	r31, 0x00	; 0
    1be0:	80 81       	ld	r24, Z
    1be2:	88 23       	and	r24, r24
    1be4:	dc f7       	brge	.-10     	; 0x1bdc <I2C_enuSendDataSl+0x26>
	/*         Check for error                 */
	if((TWSR_REG & 0xF8) == DATA_SL_S_OK){
    1be6:	e1 e2       	ldi	r30, 0x21	; 33
    1be8:	f0 e0       	ldi	r31, 0x00	; 0
    1bea:	80 81       	ld	r24, Z
    1bec:	88 2f       	mov	r24, r24
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	88 7f       	andi	r24, 0xF8	; 248
    1bf2:	90 70       	andi	r25, 0x00	; 0
    1bf4:	88 3b       	cpi	r24, 0xB8	; 184
    1bf6:	91 05       	cpc	r25, r1
    1bf8:	11 f4       	brne	.+4      	; 0x1bfe <I2C_enuSendDataSl+0x48>
		local_enuErr = I2C_OK;
    1bfa:	19 82       	std	Y+1, r1	; 0x01
    1bfc:	02 c0       	rjmp	.+4      	; 0x1c02 <I2C_enuSendDataSl+0x4c>
	}
	else{
		local_enuErr = DATA_SL_S_ERR;
    1bfe:	88 e0       	ldi	r24, 0x08	; 8
    1c00:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_enuErr;
    1c02:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c04:	0f 90       	pop	r0
    1c06:	0f 90       	pop	r0
    1c08:	cf 91       	pop	r28
    1c0a:	df 91       	pop	r29
    1c0c:	08 95       	ret

00001c0e <I2C_enuReceiveDataSl>:

I2C_Error I2C_enuReceiveDataSl(u8 * Copy_u8Data){
    1c0e:	df 93       	push	r29
    1c10:	cf 93       	push	r28
    1c12:	00 d0       	rcall	.+0      	; 0x1c14 <I2C_enuReceiveDataSl+0x6>
    1c14:	0f 92       	push	r0
    1c16:	cd b7       	in	r28, 0x3d	; 61
    1c18:	de b7       	in	r29, 0x3e	; 62
    1c1a:	9b 83       	std	Y+3, r25	; 0x03
    1c1c:	8a 83       	std	Y+2, r24	; 0x02

	I2C_Error local_enuErr = I2C_NOK;
    1c1e:	81 e0       	ldi	r24, 0x01	; 1
    1c20:	89 83       	std	Y+1, r24	; 0x01
	/*         Clear Interrupt Flag            */
	SET_BIT(TWCR_REG, TWCR_TWINT);
    1c22:	a6 e5       	ldi	r26, 0x56	; 86
    1c24:	b0 e0       	ldi	r27, 0x00	; 0
    1c26:	e6 e5       	ldi	r30, 0x56	; 86
    1c28:	f0 e0       	ldi	r31, 0x00	; 0
    1c2a:	80 81       	ld	r24, Z
    1c2c:	80 68       	ori	r24, 0x80	; 128
    1c2e:	8c 93       	st	X, r24
	/*         Wait for Flag                   */
	while(!GET_BIT(TWCR_REG, TWCR_TWINT));
    1c30:	e6 e5       	ldi	r30, 0x56	; 86
    1c32:	f0 e0       	ldi	r31, 0x00	; 0
    1c34:	80 81       	ld	r24, Z
    1c36:	88 23       	and	r24, r24
    1c38:	dc f7       	brge	.-10     	; 0x1c30 <I2C_enuReceiveDataSl+0x22>
	/*         Check for error                 */
	if((TWSR_REG & 0xF8) == DATA_SL_R_OK){
    1c3a:	e1 e2       	ldi	r30, 0x21	; 33
    1c3c:	f0 e0       	ldi	r31, 0x00	; 0
    1c3e:	80 81       	ld	r24, Z
    1c40:	88 2f       	mov	r24, r24
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	88 7f       	andi	r24, 0xF8	; 248
    1c46:	90 70       	andi	r25, 0x00	; 0
    1c48:	80 38       	cpi	r24, 0x80	; 128
    1c4a:	91 05       	cpc	r25, r1
    1c4c:	41 f4       	brne	.+16     	; 0x1c5e <I2C_enuReceiveDataSl+0x50>
		local_enuErr = I2C_OK;
    1c4e:	19 82       	std	Y+1, r1	; 0x01
		/*         Get Data from data Register     */
		*Copy_u8Data = TWDR_REG;
    1c50:	e3 e2       	ldi	r30, 0x23	; 35
    1c52:	f0 e0       	ldi	r31, 0x00	; 0
    1c54:	80 81       	ld	r24, Z
    1c56:	ea 81       	ldd	r30, Y+2	; 0x02
    1c58:	fb 81       	ldd	r31, Y+3	; 0x03
    1c5a:	80 83       	st	Z, r24
    1c5c:	02 c0       	rjmp	.+4      	; 0x1c62 <I2C_enuReceiveDataSl+0x54>
	}
	else{
		local_enuErr = DATA_SL_R_ERR;
    1c5e:	89 e0       	ldi	r24, 0x09	; 9
    1c60:	89 83       	std	Y+1, r24	; 0x01
	}
	return local_enuErr;
    1c62:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c64:	0f 90       	pop	r0
    1c66:	0f 90       	pop	r0
    1c68:	0f 90       	pop	r0
    1c6a:	cf 91       	pop	r28
    1c6c:	df 91       	pop	r29
    1c6e:	08 95       	ret

00001c70 <GINT_voidEnableGlobalInterupt>:
/***GINT***/
#include "GINT_Interface.h"
#include "GINT_Private.h"
#include "GINT_Config.h"

void GINT_voidEnableGlobalInterupt(){
    1c70:	df 93       	push	r29
    1c72:	cf 93       	push	r28
    1c74:	cd b7       	in	r28, 0x3d	; 61
    1c76:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG_REG,SREG_I);
    1c78:	af e5       	ldi	r26, 0x5F	; 95
    1c7a:	b0 e0       	ldi	r27, 0x00	; 0
    1c7c:	ef e5       	ldi	r30, 0x5F	; 95
    1c7e:	f0 e0       	ldi	r31, 0x00	; 0
    1c80:	80 81       	ld	r24, Z
    1c82:	80 68       	ori	r24, 0x80	; 128
    1c84:	8c 93       	st	X, r24
}
    1c86:	cf 91       	pop	r28
    1c88:	df 91       	pop	r29
    1c8a:	08 95       	ret

00001c8c <GINT_voidDisableGlobalInterupt>:

void GINT_voidDisableGlobalInterupt(){
    1c8c:	df 93       	push	r29
    1c8e:	cf 93       	push	r28
    1c90:	cd b7       	in	r28, 0x3d	; 61
    1c92:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG_REG,SREG_I);
    1c94:	af e5       	ldi	r26, 0x5F	; 95
    1c96:	b0 e0       	ldi	r27, 0x00	; 0
    1c98:	ef e5       	ldi	r30, 0x5F	; 95
    1c9a:	f0 e0       	ldi	r31, 0x00	; 0
    1c9c:	80 81       	ld	r24, Z
    1c9e:	8f 77       	andi	r24, 0x7F	; 127
    1ca0:	8c 93       	st	X, r24
}
    1ca2:	cf 91       	pop	r28
    1ca4:	df 91       	pop	r29
    1ca6:	08 95       	ret

00001ca8 <EXT_u8BtnDebounce>:
#include "EXT_Config.h"


static void(*EXT_CallBacks[])(void) = {NULL_PTR,NULL_PTR,NULL_PTR};

static u8 EXT_u8BtnDebounce(EXT_EI_NUM_TYPE copy_u8EiNum){
    1ca8:	df 93       	push	r29
    1caa:	cf 93       	push	r28
    1cac:	cd b7       	in	r28, 0x3d	; 61
    1cae:	de b7       	in	r29, 0x3e	; 62
    1cb0:	ae 97       	sbiw	r28, 0x2e	; 46
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	f8 94       	cli
    1cb6:	de bf       	out	0x3e, r29	; 62
    1cb8:	0f be       	out	0x3f, r0	; 63
    1cba:	cd bf       	out	0x3d, r28	; 61
    1cbc:	8b a7       	std	Y+43, r24	; 0x2b

		switch(copy_u8EiNum){
    1cbe:	8b a5       	ldd	r24, Y+43	; 0x2b
    1cc0:	28 2f       	mov	r18, r24
    1cc2:	30 e0       	ldi	r19, 0x00	; 0
    1cc4:	3e a7       	std	Y+46, r19	; 0x2e
    1cc6:	2d a7       	std	Y+45, r18	; 0x2d
    1cc8:	8d a5       	ldd	r24, Y+45	; 0x2d
    1cca:	9e a5       	ldd	r25, Y+46	; 0x2e
    1ccc:	81 30       	cpi	r24, 0x01	; 1
    1cce:	91 05       	cpc	r25, r1
    1cd0:	09 f4       	brne	.+2      	; 0x1cd4 <EXT_u8BtnDebounce+0x2c>
    1cd2:	83 c0       	rjmp	.+262    	; 0x1dda <EXT_u8BtnDebounce+0x132>
    1cd4:	2d a5       	ldd	r18, Y+45	; 0x2d
    1cd6:	3e a5       	ldd	r19, Y+46	; 0x2e
    1cd8:	22 30       	cpi	r18, 0x02	; 2
    1cda:	31 05       	cpc	r19, r1
    1cdc:	09 f4       	brne	.+2      	; 0x1ce0 <EXT_u8BtnDebounce+0x38>
    1cde:	f5 c0       	rjmp	.+490    	; 0x1eca <EXT_u8BtnDebounce+0x222>
    1ce0:	8d a5       	ldd	r24, Y+45	; 0x2d
    1ce2:	9e a5       	ldd	r25, Y+46	; 0x2e
    1ce4:	00 97       	sbiw	r24, 0x00	; 0
    1ce6:	09 f0       	breq	.+2      	; 0x1cea <EXT_u8BtnDebounce+0x42>
    1ce8:	68 c1       	rjmp	.+720    	; 0x1fba <EXT_u8BtnDebounce+0x312>
    1cea:	80 e0       	ldi	r24, 0x00	; 0
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	a0 e2       	ldi	r26, 0x20	; 32
    1cf0:	b2 e4       	ldi	r27, 0x42	; 66
    1cf2:	8f a3       	std	Y+39, r24	; 0x27
    1cf4:	98 a7       	std	Y+40, r25	; 0x28
    1cf6:	a9 a7       	std	Y+41, r26	; 0x29
    1cf8:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1cfa:	6f a1       	ldd	r22, Y+39	; 0x27
    1cfc:	78 a5       	ldd	r23, Y+40	; 0x28
    1cfe:	89 a5       	ldd	r24, Y+41	; 0x29
    1d00:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d02:	20 e0       	ldi	r18, 0x00	; 0
    1d04:	30 e0       	ldi	r19, 0x00	; 0
    1d06:	4a e7       	ldi	r20, 0x7A	; 122
    1d08:	55 e4       	ldi	r21, 0x45	; 69
    1d0a:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    1d0e:	dc 01       	movw	r26, r24
    1d10:	cb 01       	movw	r24, r22
    1d12:	8b a3       	std	Y+35, r24	; 0x23
    1d14:	9c a3       	std	Y+36, r25	; 0x24
    1d16:	ad a3       	std	Y+37, r26	; 0x25
    1d18:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1d1a:	6b a1       	ldd	r22, Y+35	; 0x23
    1d1c:	7c a1       	ldd	r23, Y+36	; 0x24
    1d1e:	8d a1       	ldd	r24, Y+37	; 0x25
    1d20:	9e a1       	ldd	r25, Y+38	; 0x26
    1d22:	20 e0       	ldi	r18, 0x00	; 0
    1d24:	30 e0       	ldi	r19, 0x00	; 0
    1d26:	40 e8       	ldi	r20, 0x80	; 128
    1d28:	5f e3       	ldi	r21, 0x3F	; 63
    1d2a:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    1d2e:	88 23       	and	r24, r24
    1d30:	2c f4       	brge	.+10     	; 0x1d3c <EXT_u8BtnDebounce+0x94>
		__ticks = 1;
    1d32:	81 e0       	ldi	r24, 0x01	; 1
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	9a a3       	std	Y+34, r25	; 0x22
    1d38:	89 a3       	std	Y+33, r24	; 0x21
    1d3a:	3f c0       	rjmp	.+126    	; 0x1dba <EXT_u8BtnDebounce+0x112>
	else if (__tmp > 65535)
    1d3c:	6b a1       	ldd	r22, Y+35	; 0x23
    1d3e:	7c a1       	ldd	r23, Y+36	; 0x24
    1d40:	8d a1       	ldd	r24, Y+37	; 0x25
    1d42:	9e a1       	ldd	r25, Y+38	; 0x26
    1d44:	20 e0       	ldi	r18, 0x00	; 0
    1d46:	3f ef       	ldi	r19, 0xFF	; 255
    1d48:	4f e7       	ldi	r20, 0x7F	; 127
    1d4a:	57 e4       	ldi	r21, 0x47	; 71
    1d4c:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    1d50:	18 16       	cp	r1, r24
    1d52:	4c f5       	brge	.+82     	; 0x1da6 <EXT_u8BtnDebounce+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d54:	6f a1       	ldd	r22, Y+39	; 0x27
    1d56:	78 a5       	ldd	r23, Y+40	; 0x28
    1d58:	89 a5       	ldd	r24, Y+41	; 0x29
    1d5a:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d5c:	20 e0       	ldi	r18, 0x00	; 0
    1d5e:	30 e0       	ldi	r19, 0x00	; 0
    1d60:	40 e2       	ldi	r20, 0x20	; 32
    1d62:	51 e4       	ldi	r21, 0x41	; 65
    1d64:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    1d68:	dc 01       	movw	r26, r24
    1d6a:	cb 01       	movw	r24, r22
    1d6c:	bc 01       	movw	r22, r24
    1d6e:	cd 01       	movw	r24, r26
    1d70:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d74:	dc 01       	movw	r26, r24
    1d76:	cb 01       	movw	r24, r22
    1d78:	9a a3       	std	Y+34, r25	; 0x22
    1d7a:	89 a3       	std	Y+33, r24	; 0x21
    1d7c:	0f c0       	rjmp	.+30     	; 0x1d9c <EXT_u8BtnDebounce+0xf4>
    1d7e:	80 e9       	ldi	r24, 0x90	; 144
    1d80:	91 e0       	ldi	r25, 0x01	; 1
    1d82:	98 a3       	std	Y+32, r25	; 0x20
    1d84:	8f 8f       	std	Y+31, r24	; 0x1f
    1d86:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1d88:	98 a1       	ldd	r25, Y+32	; 0x20
    1d8a:	01 97       	sbiw	r24, 0x01	; 1
    1d8c:	f1 f7       	brne	.-4      	; 0x1d8a <EXT_u8BtnDebounce+0xe2>
    1d8e:	98 a3       	std	Y+32, r25	; 0x20
    1d90:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d92:	89 a1       	ldd	r24, Y+33	; 0x21
    1d94:	9a a1       	ldd	r25, Y+34	; 0x22
    1d96:	01 97       	sbiw	r24, 0x01	; 1
    1d98:	9a a3       	std	Y+34, r25	; 0x22
    1d9a:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d9c:	89 a1       	ldd	r24, Y+33	; 0x21
    1d9e:	9a a1       	ldd	r25, Y+34	; 0x22
    1da0:	00 97       	sbiw	r24, 0x00	; 0
    1da2:	69 f7       	brne	.-38     	; 0x1d7e <EXT_u8BtnDebounce+0xd6>
    1da4:	14 c0       	rjmp	.+40     	; 0x1dce <EXT_u8BtnDebounce+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1da6:	6b a1       	ldd	r22, Y+35	; 0x23
    1da8:	7c a1       	ldd	r23, Y+36	; 0x24
    1daa:	8d a1       	ldd	r24, Y+37	; 0x25
    1dac:	9e a1       	ldd	r25, Y+38	; 0x26
    1dae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1db2:	dc 01       	movw	r26, r24
    1db4:	cb 01       	movw	r24, r22
    1db6:	9a a3       	std	Y+34, r25	; 0x22
    1db8:	89 a3       	std	Y+33, r24	; 0x21
    1dba:	89 a1       	ldd	r24, Y+33	; 0x21
    1dbc:	9a a1       	ldd	r25, Y+34	; 0x22
    1dbe:	9e 8f       	std	Y+30, r25	; 0x1e
    1dc0:	8d 8f       	std	Y+29, r24	; 0x1d
    1dc2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1dc4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1dc6:	01 97       	sbiw	r24, 0x01	; 1
    1dc8:	f1 f7       	brne	.-4      	; 0x1dc6 <EXT_u8BtnDebounce+0x11e>
    1dca:	9e 8f       	std	Y+30, r25	; 0x1e
    1dcc:	8d 8f       	std	Y+29, r24	; 0x1d
			case EXT0:
				_delay_ms(DEBOUNCE_DELAY);
				return DIO_voidGetPinValue(EXT_INT0_REG, EXT_INT0_PIN);
    1dce:	83 e0       	ldi	r24, 0x03	; 3
    1dd0:	62 e0       	ldi	r22, 0x02	; 2
    1dd2:	0e 94 07 14 	call	0x280e	; 0x280e <DIO_voidGetPinValue>
    1dd6:	8c a7       	std	Y+44, r24	; 0x2c
    1dd8:	f2 c0       	rjmp	.+484    	; 0x1fbe <EXT_u8BtnDebounce+0x316>
    1dda:	80 e0       	ldi	r24, 0x00	; 0
    1ddc:	90 e0       	ldi	r25, 0x00	; 0
    1dde:	a0 e2       	ldi	r26, 0x20	; 32
    1de0:	b2 e4       	ldi	r27, 0x42	; 66
    1de2:	89 8f       	std	Y+25, r24	; 0x19
    1de4:	9a 8f       	std	Y+26, r25	; 0x1a
    1de6:	ab 8f       	std	Y+27, r26	; 0x1b
    1de8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1dea:	69 8d       	ldd	r22, Y+25	; 0x19
    1dec:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1dee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1df0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1df2:	20 e0       	ldi	r18, 0x00	; 0
    1df4:	30 e0       	ldi	r19, 0x00	; 0
    1df6:	4a e7       	ldi	r20, 0x7A	; 122
    1df8:	55 e4       	ldi	r21, 0x45	; 69
    1dfa:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    1dfe:	dc 01       	movw	r26, r24
    1e00:	cb 01       	movw	r24, r22
    1e02:	8d 8b       	std	Y+21, r24	; 0x15
    1e04:	9e 8b       	std	Y+22, r25	; 0x16
    1e06:	af 8b       	std	Y+23, r26	; 0x17
    1e08:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1e0a:	6d 89       	ldd	r22, Y+21	; 0x15
    1e0c:	7e 89       	ldd	r23, Y+22	; 0x16
    1e0e:	8f 89       	ldd	r24, Y+23	; 0x17
    1e10:	98 8d       	ldd	r25, Y+24	; 0x18
    1e12:	20 e0       	ldi	r18, 0x00	; 0
    1e14:	30 e0       	ldi	r19, 0x00	; 0
    1e16:	40 e8       	ldi	r20, 0x80	; 128
    1e18:	5f e3       	ldi	r21, 0x3F	; 63
    1e1a:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    1e1e:	88 23       	and	r24, r24
    1e20:	2c f4       	brge	.+10     	; 0x1e2c <EXT_u8BtnDebounce+0x184>
		__ticks = 1;
    1e22:	81 e0       	ldi	r24, 0x01	; 1
    1e24:	90 e0       	ldi	r25, 0x00	; 0
    1e26:	9c 8b       	std	Y+20, r25	; 0x14
    1e28:	8b 8b       	std	Y+19, r24	; 0x13
    1e2a:	3f c0       	rjmp	.+126    	; 0x1eaa <EXT_u8BtnDebounce+0x202>
	else if (__tmp > 65535)
    1e2c:	6d 89       	ldd	r22, Y+21	; 0x15
    1e2e:	7e 89       	ldd	r23, Y+22	; 0x16
    1e30:	8f 89       	ldd	r24, Y+23	; 0x17
    1e32:	98 8d       	ldd	r25, Y+24	; 0x18
    1e34:	20 e0       	ldi	r18, 0x00	; 0
    1e36:	3f ef       	ldi	r19, 0xFF	; 255
    1e38:	4f e7       	ldi	r20, 0x7F	; 127
    1e3a:	57 e4       	ldi	r21, 0x47	; 71
    1e3c:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    1e40:	18 16       	cp	r1, r24
    1e42:	4c f5       	brge	.+82     	; 0x1e96 <EXT_u8BtnDebounce+0x1ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e44:	69 8d       	ldd	r22, Y+25	; 0x19
    1e46:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1e48:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e4a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e4c:	20 e0       	ldi	r18, 0x00	; 0
    1e4e:	30 e0       	ldi	r19, 0x00	; 0
    1e50:	40 e2       	ldi	r20, 0x20	; 32
    1e52:	51 e4       	ldi	r21, 0x41	; 65
    1e54:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    1e58:	dc 01       	movw	r26, r24
    1e5a:	cb 01       	movw	r24, r22
    1e5c:	bc 01       	movw	r22, r24
    1e5e:	cd 01       	movw	r24, r26
    1e60:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e64:	dc 01       	movw	r26, r24
    1e66:	cb 01       	movw	r24, r22
    1e68:	9c 8b       	std	Y+20, r25	; 0x14
    1e6a:	8b 8b       	std	Y+19, r24	; 0x13
    1e6c:	0f c0       	rjmp	.+30     	; 0x1e8c <EXT_u8BtnDebounce+0x1e4>
    1e6e:	80 e9       	ldi	r24, 0x90	; 144
    1e70:	91 e0       	ldi	r25, 0x01	; 1
    1e72:	9a 8b       	std	Y+18, r25	; 0x12
    1e74:	89 8b       	std	Y+17, r24	; 0x11
    1e76:	89 89       	ldd	r24, Y+17	; 0x11
    1e78:	9a 89       	ldd	r25, Y+18	; 0x12
    1e7a:	01 97       	sbiw	r24, 0x01	; 1
    1e7c:	f1 f7       	brne	.-4      	; 0x1e7a <EXT_u8BtnDebounce+0x1d2>
    1e7e:	9a 8b       	std	Y+18, r25	; 0x12
    1e80:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e82:	8b 89       	ldd	r24, Y+19	; 0x13
    1e84:	9c 89       	ldd	r25, Y+20	; 0x14
    1e86:	01 97       	sbiw	r24, 0x01	; 1
    1e88:	9c 8b       	std	Y+20, r25	; 0x14
    1e8a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e8c:	8b 89       	ldd	r24, Y+19	; 0x13
    1e8e:	9c 89       	ldd	r25, Y+20	; 0x14
    1e90:	00 97       	sbiw	r24, 0x00	; 0
    1e92:	69 f7       	brne	.-38     	; 0x1e6e <EXT_u8BtnDebounce+0x1c6>
    1e94:	14 c0       	rjmp	.+40     	; 0x1ebe <EXT_u8BtnDebounce+0x216>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e96:	6d 89       	ldd	r22, Y+21	; 0x15
    1e98:	7e 89       	ldd	r23, Y+22	; 0x16
    1e9a:	8f 89       	ldd	r24, Y+23	; 0x17
    1e9c:	98 8d       	ldd	r25, Y+24	; 0x18
    1e9e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ea2:	dc 01       	movw	r26, r24
    1ea4:	cb 01       	movw	r24, r22
    1ea6:	9c 8b       	std	Y+20, r25	; 0x14
    1ea8:	8b 8b       	std	Y+19, r24	; 0x13
    1eaa:	8b 89       	ldd	r24, Y+19	; 0x13
    1eac:	9c 89       	ldd	r25, Y+20	; 0x14
    1eae:	98 8b       	std	Y+16, r25	; 0x10
    1eb0:	8f 87       	std	Y+15, r24	; 0x0f
    1eb2:	8f 85       	ldd	r24, Y+15	; 0x0f
    1eb4:	98 89       	ldd	r25, Y+16	; 0x10
    1eb6:	01 97       	sbiw	r24, 0x01	; 1
    1eb8:	f1 f7       	brne	.-4      	; 0x1eb6 <EXT_u8BtnDebounce+0x20e>
    1eba:	98 8b       	std	Y+16, r25	; 0x10
    1ebc:	8f 87       	std	Y+15, r24	; 0x0f
				break;
			case EXT1:
				_delay_ms(DEBOUNCE_DELAY);
				return DIO_voidGetPinValue(EXT_INT1_REG, EXT_INT1_PIN);
    1ebe:	83 e0       	ldi	r24, 0x03	; 3
    1ec0:	63 e0       	ldi	r22, 0x03	; 3
    1ec2:	0e 94 07 14 	call	0x280e	; 0x280e <DIO_voidGetPinValue>
    1ec6:	8c a7       	std	Y+44, r24	; 0x2c
    1ec8:	7a c0       	rjmp	.+244    	; 0x1fbe <EXT_u8BtnDebounce+0x316>
    1eca:	80 e0       	ldi	r24, 0x00	; 0
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	a0 e2       	ldi	r26, 0x20	; 32
    1ed0:	b2 e4       	ldi	r27, 0x42	; 66
    1ed2:	8b 87       	std	Y+11, r24	; 0x0b
    1ed4:	9c 87       	std	Y+12, r25	; 0x0c
    1ed6:	ad 87       	std	Y+13, r26	; 0x0d
    1ed8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1eda:	6b 85       	ldd	r22, Y+11	; 0x0b
    1edc:	7c 85       	ldd	r23, Y+12	; 0x0c
    1ede:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ee0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ee2:	20 e0       	ldi	r18, 0x00	; 0
    1ee4:	30 e0       	ldi	r19, 0x00	; 0
    1ee6:	4a e7       	ldi	r20, 0x7A	; 122
    1ee8:	55 e4       	ldi	r21, 0x45	; 69
    1eea:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    1eee:	dc 01       	movw	r26, r24
    1ef0:	cb 01       	movw	r24, r22
    1ef2:	8f 83       	std	Y+7, r24	; 0x07
    1ef4:	98 87       	std	Y+8, r25	; 0x08
    1ef6:	a9 87       	std	Y+9, r26	; 0x09
    1ef8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1efa:	6f 81       	ldd	r22, Y+7	; 0x07
    1efc:	78 85       	ldd	r23, Y+8	; 0x08
    1efe:	89 85       	ldd	r24, Y+9	; 0x09
    1f00:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f02:	20 e0       	ldi	r18, 0x00	; 0
    1f04:	30 e0       	ldi	r19, 0x00	; 0
    1f06:	40 e8       	ldi	r20, 0x80	; 128
    1f08:	5f e3       	ldi	r21, 0x3F	; 63
    1f0a:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    1f0e:	88 23       	and	r24, r24
    1f10:	2c f4       	brge	.+10     	; 0x1f1c <EXT_u8BtnDebounce+0x274>
		__ticks = 1;
    1f12:	81 e0       	ldi	r24, 0x01	; 1
    1f14:	90 e0       	ldi	r25, 0x00	; 0
    1f16:	9e 83       	std	Y+6, r25	; 0x06
    1f18:	8d 83       	std	Y+5, r24	; 0x05
    1f1a:	3f c0       	rjmp	.+126    	; 0x1f9a <EXT_u8BtnDebounce+0x2f2>
	else if (__tmp > 65535)
    1f1c:	6f 81       	ldd	r22, Y+7	; 0x07
    1f1e:	78 85       	ldd	r23, Y+8	; 0x08
    1f20:	89 85       	ldd	r24, Y+9	; 0x09
    1f22:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f24:	20 e0       	ldi	r18, 0x00	; 0
    1f26:	3f ef       	ldi	r19, 0xFF	; 255
    1f28:	4f e7       	ldi	r20, 0x7F	; 127
    1f2a:	57 e4       	ldi	r21, 0x47	; 71
    1f2c:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    1f30:	18 16       	cp	r1, r24
    1f32:	4c f5       	brge	.+82     	; 0x1f86 <EXT_u8BtnDebounce+0x2de>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f34:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f36:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f38:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f3a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f3c:	20 e0       	ldi	r18, 0x00	; 0
    1f3e:	30 e0       	ldi	r19, 0x00	; 0
    1f40:	40 e2       	ldi	r20, 0x20	; 32
    1f42:	51 e4       	ldi	r21, 0x41	; 65
    1f44:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    1f48:	dc 01       	movw	r26, r24
    1f4a:	cb 01       	movw	r24, r22
    1f4c:	bc 01       	movw	r22, r24
    1f4e:	cd 01       	movw	r24, r26
    1f50:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f54:	dc 01       	movw	r26, r24
    1f56:	cb 01       	movw	r24, r22
    1f58:	9e 83       	std	Y+6, r25	; 0x06
    1f5a:	8d 83       	std	Y+5, r24	; 0x05
    1f5c:	0f c0       	rjmp	.+30     	; 0x1f7c <EXT_u8BtnDebounce+0x2d4>
    1f5e:	80 e9       	ldi	r24, 0x90	; 144
    1f60:	91 e0       	ldi	r25, 0x01	; 1
    1f62:	9c 83       	std	Y+4, r25	; 0x04
    1f64:	8b 83       	std	Y+3, r24	; 0x03
    1f66:	8b 81       	ldd	r24, Y+3	; 0x03
    1f68:	9c 81       	ldd	r25, Y+4	; 0x04
    1f6a:	01 97       	sbiw	r24, 0x01	; 1
    1f6c:	f1 f7       	brne	.-4      	; 0x1f6a <EXT_u8BtnDebounce+0x2c2>
    1f6e:	9c 83       	std	Y+4, r25	; 0x04
    1f70:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f72:	8d 81       	ldd	r24, Y+5	; 0x05
    1f74:	9e 81       	ldd	r25, Y+6	; 0x06
    1f76:	01 97       	sbiw	r24, 0x01	; 1
    1f78:	9e 83       	std	Y+6, r25	; 0x06
    1f7a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f80:	00 97       	sbiw	r24, 0x00	; 0
    1f82:	69 f7       	brne	.-38     	; 0x1f5e <EXT_u8BtnDebounce+0x2b6>
    1f84:	14 c0       	rjmp	.+40     	; 0x1fae <EXT_u8BtnDebounce+0x306>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f86:	6f 81       	ldd	r22, Y+7	; 0x07
    1f88:	78 85       	ldd	r23, Y+8	; 0x08
    1f8a:	89 85       	ldd	r24, Y+9	; 0x09
    1f8c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f8e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f92:	dc 01       	movw	r26, r24
    1f94:	cb 01       	movw	r24, r22
    1f96:	9e 83       	std	Y+6, r25	; 0x06
    1f98:	8d 83       	std	Y+5, r24	; 0x05
    1f9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1f9e:	9a 83       	std	Y+2, r25	; 0x02
    1fa0:	89 83       	std	Y+1, r24	; 0x01
    1fa2:	89 81       	ldd	r24, Y+1	; 0x01
    1fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fa6:	01 97       	sbiw	r24, 0x01	; 1
    1fa8:	f1 f7       	brne	.-4      	; 0x1fa6 <EXT_u8BtnDebounce+0x2fe>
    1faa:	9a 83       	std	Y+2, r25	; 0x02
    1fac:	89 83       	std	Y+1, r24	; 0x01
				break;
			case EXT2:
				_delay_ms(DEBOUNCE_DELAY);
				return DIO_voidGetPinValue(EXT_INT2_REG, EXT_INT2_PIN);
    1fae:	81 e0       	ldi	r24, 0x01	; 1
    1fb0:	62 e0       	ldi	r22, 0x02	; 2
    1fb2:	0e 94 07 14 	call	0x280e	; 0x280e <DIO_voidGetPinValue>
    1fb6:	8c a7       	std	Y+44, r24	; 0x2c
    1fb8:	02 c0       	rjmp	.+4      	; 0x1fbe <EXT_u8BtnDebounce+0x316>
				break;
			default:
				return PIN_HIGH;
    1fba:	91 e0       	ldi	r25, 0x01	; 1
    1fbc:	9c a7       	std	Y+44, r25	; 0x2c
    1fbe:	8c a5       	ldd	r24, Y+44	; 0x2c
				break;
		}
}
    1fc0:	ae 96       	adiw	r28, 0x2e	; 46
    1fc2:	0f b6       	in	r0, 0x3f	; 63
    1fc4:	f8 94       	cli
    1fc6:	de bf       	out	0x3e, r29	; 62
    1fc8:	0f be       	out	0x3f, r0	; 63
    1fca:	cd bf       	out	0x3d, r28	; 61
    1fcc:	cf 91       	pop	r28
    1fce:	df 91       	pop	r29
    1fd0:	08 95       	ret

00001fd2 <EXT_u8IsBtnPressed>:

static u8 EXT_u8IsBtnPressed(EXT_EI_NUM_TYPE copy_u8EiNum){
    1fd2:	df 93       	push	r29
    1fd4:	cf 93       	push	r28
    1fd6:	00 d0       	rcall	.+0      	; 0x1fd8 <EXT_u8IsBtnPressed+0x6>
    1fd8:	00 d0       	rcall	.+0      	; 0x1fda <EXT_u8IsBtnPressed+0x8>
    1fda:	cd b7       	in	r28, 0x3d	; 61
    1fdc:	de b7       	in	r29, 0x3e	; 62
    1fde:	89 83       	std	Y+1, r24	; 0x01

	switch(copy_u8EiNum){
    1fe0:	89 81       	ldd	r24, Y+1	; 0x01
    1fe2:	28 2f       	mov	r18, r24
    1fe4:	30 e0       	ldi	r19, 0x00	; 0
    1fe6:	3c 83       	std	Y+4, r19	; 0x04
    1fe8:	2b 83       	std	Y+3, r18	; 0x03
    1fea:	8b 81       	ldd	r24, Y+3	; 0x03
    1fec:	9c 81       	ldd	r25, Y+4	; 0x04
    1fee:	81 30       	cpi	r24, 0x01	; 1
    1ff0:	91 05       	cpc	r25, r1
    1ff2:	91 f0       	breq	.+36     	; 0x2018 <EXT_u8IsBtnPressed+0x46>
    1ff4:	2b 81       	ldd	r18, Y+3	; 0x03
    1ff6:	3c 81       	ldd	r19, Y+4	; 0x04
    1ff8:	22 30       	cpi	r18, 0x02	; 2
    1ffa:	31 05       	cpc	r19, r1
    1ffc:	b1 f0       	breq	.+44     	; 0x202a <EXT_u8IsBtnPressed+0x58>
    1ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    2000:	9c 81       	ldd	r25, Y+4	; 0x04
    2002:	00 97       	sbiw	r24, 0x00	; 0
    2004:	d9 f4       	brne	.+54     	; 0x203c <EXT_u8IsBtnPressed+0x6a>
		case EXT0:
			return !EXT_u8BtnDebounce(EXT0);
    2006:	80 e0       	ldi	r24, 0x00	; 0
    2008:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <EXT_u8BtnDebounce>
    200c:	1a 82       	std	Y+2, r1	; 0x02
    200e:	88 23       	and	r24, r24
    2010:	b1 f4       	brne	.+44     	; 0x203e <EXT_u8IsBtnPressed+0x6c>
    2012:	91 e0       	ldi	r25, 0x01	; 1
    2014:	9a 83       	std	Y+2, r25	; 0x02
    2016:	13 c0       	rjmp	.+38     	; 0x203e <EXT_u8IsBtnPressed+0x6c>
			break;
		case EXT1:
			return !EXT_u8BtnDebounce(EXT1);
    2018:	81 e0       	ldi	r24, 0x01	; 1
    201a:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <EXT_u8BtnDebounce>
    201e:	1a 82       	std	Y+2, r1	; 0x02
    2020:	88 23       	and	r24, r24
    2022:	69 f4       	brne	.+26     	; 0x203e <EXT_u8IsBtnPressed+0x6c>
    2024:	21 e0       	ldi	r18, 0x01	; 1
    2026:	2a 83       	std	Y+2, r18	; 0x02
    2028:	0a c0       	rjmp	.+20     	; 0x203e <EXT_u8IsBtnPressed+0x6c>
			break;
		case EXT2:
			return !EXT_u8BtnDebounce(EXT2);
    202a:	82 e0       	ldi	r24, 0x02	; 2
    202c:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <EXT_u8BtnDebounce>
    2030:	1a 82       	std	Y+2, r1	; 0x02
    2032:	88 23       	and	r24, r24
    2034:	21 f4       	brne	.+8      	; 0x203e <EXT_u8IsBtnPressed+0x6c>
    2036:	31 e0       	ldi	r19, 0x01	; 1
    2038:	3a 83       	std	Y+2, r19	; 0x02
    203a:	01 c0       	rjmp	.+2      	; 0x203e <EXT_u8IsBtnPressed+0x6c>
			break;
		default:
			return 0;
    203c:	1a 82       	std	Y+2, r1	; 0x02
    203e:	8a 81       	ldd	r24, Y+2	; 0x02
			break;
	}

}
    2040:	0f 90       	pop	r0
    2042:	0f 90       	pop	r0
    2044:	0f 90       	pop	r0
    2046:	0f 90       	pop	r0
    2048:	cf 91       	pop	r28
    204a:	df 91       	pop	r29
    204c:	08 95       	ret

0000204e <EXT_voidInit>:


void EXT_voidInit(EXT_EI_NUM_TYPE copy_u8EiNum, EXT_EI_SENSE_TYPE copy_u8ControlSens){
    204e:	df 93       	push	r29
    2050:	cf 93       	push	r28
    2052:	cd b7       	in	r28, 0x3d	; 61
    2054:	de b7       	in	r29, 0x3e	; 62
    2056:	2a 97       	sbiw	r28, 0x0a	; 10
    2058:	0f b6       	in	r0, 0x3f	; 63
    205a:	f8 94       	cli
    205c:	de bf       	out	0x3e, r29	; 62
    205e:	0f be       	out	0x3f, r0	; 63
    2060:	cd bf       	out	0x3d, r28	; 61
    2062:	89 83       	std	Y+1, r24	; 0x01
    2064:	6a 83       	std	Y+2, r22	; 0x02

	switch(copy_u8EiNum){
    2066:	89 81       	ldd	r24, Y+1	; 0x01
    2068:	28 2f       	mov	r18, r24
    206a:	30 e0       	ldi	r19, 0x00	; 0
    206c:	3a 87       	std	Y+10, r19	; 0x0a
    206e:	29 87       	std	Y+9, r18	; 0x09
    2070:	89 85       	ldd	r24, Y+9	; 0x09
    2072:	9a 85       	ldd	r25, Y+10	; 0x0a
    2074:	81 30       	cpi	r24, 0x01	; 1
    2076:	91 05       	cpc	r25, r1
    2078:	09 f4       	brne	.+2      	; 0x207c <EXT_voidInit+0x2e>
    207a:	3f c0       	rjmp	.+126    	; 0x20fa <EXT_voidInit+0xac>
    207c:	29 85       	ldd	r18, Y+9	; 0x09
    207e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2080:	22 30       	cpi	r18, 0x02	; 2
    2082:	31 05       	cpc	r19, r1
    2084:	09 f4       	brne	.+2      	; 0x2088 <EXT_voidInit+0x3a>
    2086:	6d c0       	rjmp	.+218    	; 0x2162 <EXT_voidInit+0x114>
    2088:	89 85       	ldd	r24, Y+9	; 0x09
    208a:	9a 85       	ldd	r25, Y+10	; 0x0a
    208c:	00 97       	sbiw	r24, 0x00	; 0
    208e:	09 f0       	breq	.+2      	; 0x2092 <EXT_voidInit+0x44>
    2090:	8d c0       	rjmp	.+282    	; 0x21ac <EXT_voidInit+0x15e>

		case EXT0:
			switch(copy_u8ControlSens){
    2092:	8a 81       	ldd	r24, Y+2	; 0x02
    2094:	28 2f       	mov	r18, r24
    2096:	30 e0       	ldi	r19, 0x00	; 0
    2098:	38 87       	std	Y+8, r19	; 0x08
    209a:	2f 83       	std	Y+7, r18	; 0x07
    209c:	8f 81       	ldd	r24, Y+7	; 0x07
    209e:	98 85       	ldd	r25, Y+8	; 0x08
    20a0:	00 97       	sbiw	r24, 0x00	; 0
    20a2:	31 f0       	breq	.+12     	; 0x20b0 <EXT_voidInit+0x62>
    20a4:	2f 81       	ldd	r18, Y+7	; 0x07
    20a6:	38 85       	ldd	r19, Y+8	; 0x08
    20a8:	21 30       	cpi	r18, 0x01	; 1
    20aa:	31 05       	cpc	r19, r1
    20ac:	81 f0       	breq	.+32     	; 0x20ce <EXT_voidInit+0x80>
    20ae:	1d c0       	rjmp	.+58     	; 0x20ea <EXT_voidInit+0x9c>
				case FALLING_EDGE:
					CLR_BIT(MCUCR_REG,MCUCR_ISC00);
    20b0:	a5 e5       	ldi	r26, 0x55	; 85
    20b2:	b0 e0       	ldi	r27, 0x00	; 0
    20b4:	e5 e5       	ldi	r30, 0x55	; 85
    20b6:	f0 e0       	ldi	r31, 0x00	; 0
    20b8:	80 81       	ld	r24, Z
    20ba:	8e 7f       	andi	r24, 0xFE	; 254
    20bc:	8c 93       	st	X, r24
					SET_BIT(MCUCR_REG,MCUCR_ISC01);
    20be:	a5 e5       	ldi	r26, 0x55	; 85
    20c0:	b0 e0       	ldi	r27, 0x00	; 0
    20c2:	e5 e5       	ldi	r30, 0x55	; 85
    20c4:	f0 e0       	ldi	r31, 0x00	; 0
    20c6:	80 81       	ld	r24, Z
    20c8:	82 60       	ori	r24, 0x02	; 2
    20ca:	8c 93       	st	X, r24
    20cc:	0e c0       	rjmp	.+28     	; 0x20ea <EXT_voidInit+0x9c>
					break;
				case RISNIG_EDGE:
					SET_BIT(MCUCR_REG,MCUCR_ISC00);
    20ce:	a5 e5       	ldi	r26, 0x55	; 85
    20d0:	b0 e0       	ldi	r27, 0x00	; 0
    20d2:	e5 e5       	ldi	r30, 0x55	; 85
    20d4:	f0 e0       	ldi	r31, 0x00	; 0
    20d6:	80 81       	ld	r24, Z
    20d8:	81 60       	ori	r24, 0x01	; 1
    20da:	8c 93       	st	X, r24
					SET_BIT(MCUCR_REG,MCUCR_ISC01);
    20dc:	a5 e5       	ldi	r26, 0x55	; 85
    20de:	b0 e0       	ldi	r27, 0x00	; 0
    20e0:	e5 e5       	ldi	r30, 0x55	; 85
    20e2:	f0 e0       	ldi	r31, 0x00	; 0
    20e4:	80 81       	ld	r24, Z
    20e6:	82 60       	ori	r24, 0x02	; 2
    20e8:	8c 93       	st	X, r24
					break;
			}
			SET_BIT(GICR_REG,GICR_INT0);
    20ea:	ab e5       	ldi	r26, 0x5B	; 91
    20ec:	b0 e0       	ldi	r27, 0x00	; 0
    20ee:	eb e5       	ldi	r30, 0x5B	; 91
    20f0:	f0 e0       	ldi	r31, 0x00	; 0
    20f2:	80 81       	ld	r24, Z
    20f4:	80 64       	ori	r24, 0x40	; 64
    20f6:	8c 93       	st	X, r24
    20f8:	59 c0       	rjmp	.+178    	; 0x21ac <EXT_voidInit+0x15e>
			break;

		case EXT1:
			switch(copy_u8ControlSens){
    20fa:	8a 81       	ldd	r24, Y+2	; 0x02
    20fc:	28 2f       	mov	r18, r24
    20fe:	30 e0       	ldi	r19, 0x00	; 0
    2100:	3e 83       	std	Y+6, r19	; 0x06
    2102:	2d 83       	std	Y+5, r18	; 0x05
    2104:	8d 81       	ldd	r24, Y+5	; 0x05
    2106:	9e 81       	ldd	r25, Y+6	; 0x06
    2108:	00 97       	sbiw	r24, 0x00	; 0
    210a:	31 f0       	breq	.+12     	; 0x2118 <EXT_voidInit+0xca>
    210c:	2d 81       	ldd	r18, Y+5	; 0x05
    210e:	3e 81       	ldd	r19, Y+6	; 0x06
    2110:	21 30       	cpi	r18, 0x01	; 1
    2112:	31 05       	cpc	r19, r1
    2114:	81 f0       	breq	.+32     	; 0x2136 <EXT_voidInit+0xe8>
    2116:	1d c0       	rjmp	.+58     	; 0x2152 <EXT_voidInit+0x104>
				case FALLING_EDGE:
					CLR_BIT(MCUCR_REG,MCUCR_ISC10);
    2118:	a5 e5       	ldi	r26, 0x55	; 85
    211a:	b0 e0       	ldi	r27, 0x00	; 0
    211c:	e5 e5       	ldi	r30, 0x55	; 85
    211e:	f0 e0       	ldi	r31, 0x00	; 0
    2120:	80 81       	ld	r24, Z
    2122:	8b 7f       	andi	r24, 0xFB	; 251
    2124:	8c 93       	st	X, r24
					SET_BIT(MCUCR_REG,MCUCR_ISC11);
    2126:	a5 e5       	ldi	r26, 0x55	; 85
    2128:	b0 e0       	ldi	r27, 0x00	; 0
    212a:	e5 e5       	ldi	r30, 0x55	; 85
    212c:	f0 e0       	ldi	r31, 0x00	; 0
    212e:	80 81       	ld	r24, Z
    2130:	88 60       	ori	r24, 0x08	; 8
    2132:	8c 93       	st	X, r24
    2134:	0e c0       	rjmp	.+28     	; 0x2152 <EXT_voidInit+0x104>
					break;
				case RISNIG_EDGE:
					SET_BIT(MCUCR_REG,MCUCR_ISC10);
    2136:	a5 e5       	ldi	r26, 0x55	; 85
    2138:	b0 e0       	ldi	r27, 0x00	; 0
    213a:	e5 e5       	ldi	r30, 0x55	; 85
    213c:	f0 e0       	ldi	r31, 0x00	; 0
    213e:	80 81       	ld	r24, Z
    2140:	84 60       	ori	r24, 0x04	; 4
    2142:	8c 93       	st	X, r24
					SET_BIT(MCUCR_REG,MCUCR_ISC11);
    2144:	a5 e5       	ldi	r26, 0x55	; 85
    2146:	b0 e0       	ldi	r27, 0x00	; 0
    2148:	e5 e5       	ldi	r30, 0x55	; 85
    214a:	f0 e0       	ldi	r31, 0x00	; 0
    214c:	80 81       	ld	r24, Z
    214e:	88 60       	ori	r24, 0x08	; 8
    2150:	8c 93       	st	X, r24
					break;
			}
			SET_BIT(GICR_REG,GICR_INT1);
    2152:	ab e5       	ldi	r26, 0x5B	; 91
    2154:	b0 e0       	ldi	r27, 0x00	; 0
    2156:	eb e5       	ldi	r30, 0x5B	; 91
    2158:	f0 e0       	ldi	r31, 0x00	; 0
    215a:	80 81       	ld	r24, Z
    215c:	80 68       	ori	r24, 0x80	; 128
    215e:	8c 93       	st	X, r24
    2160:	25 c0       	rjmp	.+74     	; 0x21ac <EXT_voidInit+0x15e>
			break;

		case EXT2:
			switch(copy_u8ControlSens){
    2162:	8a 81       	ldd	r24, Y+2	; 0x02
    2164:	28 2f       	mov	r18, r24
    2166:	30 e0       	ldi	r19, 0x00	; 0
    2168:	3c 83       	std	Y+4, r19	; 0x04
    216a:	2b 83       	std	Y+3, r18	; 0x03
    216c:	8b 81       	ldd	r24, Y+3	; 0x03
    216e:	9c 81       	ldd	r25, Y+4	; 0x04
    2170:	00 97       	sbiw	r24, 0x00	; 0
    2172:	31 f0       	breq	.+12     	; 0x2180 <EXT_voidInit+0x132>
    2174:	2b 81       	ldd	r18, Y+3	; 0x03
    2176:	3c 81       	ldd	r19, Y+4	; 0x04
    2178:	21 30       	cpi	r18, 0x01	; 1
    217a:	31 05       	cpc	r19, r1
    217c:	49 f0       	breq	.+18     	; 0x2190 <EXT_voidInit+0x142>
    217e:	0f c0       	rjmp	.+30     	; 0x219e <EXT_voidInit+0x150>
				case FALLING_EDGE:
					CLR_BIT(MCUCSR_REG,MCUCSR_ISC2);
    2180:	a4 e5       	ldi	r26, 0x54	; 84
    2182:	b0 e0       	ldi	r27, 0x00	; 0
    2184:	e4 e5       	ldi	r30, 0x54	; 84
    2186:	f0 e0       	ldi	r31, 0x00	; 0
    2188:	80 81       	ld	r24, Z
    218a:	8f 7b       	andi	r24, 0xBF	; 191
    218c:	8c 93       	st	X, r24
    218e:	07 c0       	rjmp	.+14     	; 0x219e <EXT_voidInit+0x150>
					break;
				case RISNIG_EDGE:
					SET_BIT(MCUCSR_REG,MCUCSR_ISC2);
    2190:	a4 e5       	ldi	r26, 0x54	; 84
    2192:	b0 e0       	ldi	r27, 0x00	; 0
    2194:	e4 e5       	ldi	r30, 0x54	; 84
    2196:	f0 e0       	ldi	r31, 0x00	; 0
    2198:	80 81       	ld	r24, Z
    219a:	80 64       	ori	r24, 0x40	; 64
    219c:	8c 93       	st	X, r24
					break;
			}
			SET_BIT(GICR_REG,GICR_INT2);
    219e:	ab e5       	ldi	r26, 0x5B	; 91
    21a0:	b0 e0       	ldi	r27, 0x00	; 0
    21a2:	eb e5       	ldi	r30, 0x5B	; 91
    21a4:	f0 e0       	ldi	r31, 0x00	; 0
    21a6:	80 81       	ld	r24, Z
    21a8:	80 62       	ori	r24, 0x20	; 32
    21aa:	8c 93       	st	X, r24
			break;
	}

}
    21ac:	2a 96       	adiw	r28, 0x0a	; 10
    21ae:	0f b6       	in	r0, 0x3f	; 63
    21b0:	f8 94       	cli
    21b2:	de bf       	out	0x3e, r29	; 62
    21b4:	0f be       	out	0x3f, r0	; 63
    21b6:	cd bf       	out	0x3d, r28	; 61
    21b8:	cf 91       	pop	r28
    21ba:	df 91       	pop	r29
    21bc:	08 95       	ret

000021be <EXT_voidSetCallBack>:

void EXT_voidSetCallBack(EXT_EI_NUM_TYPE copy_u8EiNum, void(*Copy_ptf)(void)){
    21be:	df 93       	push	r29
    21c0:	cf 93       	push	r28
    21c2:	00 d0       	rcall	.+0      	; 0x21c4 <EXT_voidSetCallBack+0x6>
    21c4:	0f 92       	push	r0
    21c6:	cd b7       	in	r28, 0x3d	; 61
    21c8:	de b7       	in	r29, 0x3e	; 62
    21ca:	89 83       	std	Y+1, r24	; 0x01
    21cc:	7b 83       	std	Y+3, r23	; 0x03
    21ce:	6a 83       	std	Y+2, r22	; 0x02

	if(Copy_ptf != NULL_PTR){
    21d0:	8a 81       	ldd	r24, Y+2	; 0x02
    21d2:	9b 81       	ldd	r25, Y+3	; 0x03
    21d4:	00 97       	sbiw	r24, 0x00	; 0
    21d6:	61 f0       	breq	.+24     	; 0x21f0 <EXT_voidSetCallBack+0x32>
		EXT_CallBacks[copy_u8EiNum] = Copy_ptf;
    21d8:	89 81       	ldd	r24, Y+1	; 0x01
    21da:	88 2f       	mov	r24, r24
    21dc:	90 e0       	ldi	r25, 0x00	; 0
    21de:	88 0f       	add	r24, r24
    21e0:	99 1f       	adc	r25, r25
    21e2:	fc 01       	movw	r30, r24
    21e4:	e4 56       	subi	r30, 0x64	; 100
    21e6:	fe 4f       	sbci	r31, 0xFE	; 254
    21e8:	8a 81       	ldd	r24, Y+2	; 0x02
    21ea:	9b 81       	ldd	r25, Y+3	; 0x03
    21ec:	91 83       	std	Z+1, r25	; 0x01
    21ee:	80 83       	st	Z, r24
	}

}
    21f0:	0f 90       	pop	r0
    21f2:	0f 90       	pop	r0
    21f4:	0f 90       	pop	r0
    21f6:	cf 91       	pop	r28
    21f8:	df 91       	pop	r29
    21fa:	08 95       	ret

000021fc <__vector_1>:

/*** ISR ***/
void __vector_1() __attribute__((signal));
void __vector_1(){
    21fc:	1f 92       	push	r1
    21fe:	0f 92       	push	r0
    2200:	0f b6       	in	r0, 0x3f	; 63
    2202:	0f 92       	push	r0
    2204:	11 24       	eor	r1, r1
    2206:	2f 93       	push	r18
    2208:	3f 93       	push	r19
    220a:	4f 93       	push	r20
    220c:	5f 93       	push	r21
    220e:	6f 93       	push	r22
    2210:	7f 93       	push	r23
    2212:	8f 93       	push	r24
    2214:	9f 93       	push	r25
    2216:	af 93       	push	r26
    2218:	bf 93       	push	r27
    221a:	ef 93       	push	r30
    221c:	ff 93       	push	r31
    221e:	df 93       	push	r29
    2220:	cf 93       	push	r28
    2222:	cd b7       	in	r28, 0x3d	; 61
    2224:	de b7       	in	r29, 0x3e	; 62

	//if(EXT_u8IsBtnPressed(EXT0)){
		EXT_CallBacks[EXT0]();
    2226:	e0 91 9c 01 	lds	r30, 0x019C
    222a:	f0 91 9d 01 	lds	r31, 0x019D
    222e:	09 95       	icall
	//}
}
    2230:	cf 91       	pop	r28
    2232:	df 91       	pop	r29
    2234:	ff 91       	pop	r31
    2236:	ef 91       	pop	r30
    2238:	bf 91       	pop	r27
    223a:	af 91       	pop	r26
    223c:	9f 91       	pop	r25
    223e:	8f 91       	pop	r24
    2240:	7f 91       	pop	r23
    2242:	6f 91       	pop	r22
    2244:	5f 91       	pop	r21
    2246:	4f 91       	pop	r20
    2248:	3f 91       	pop	r19
    224a:	2f 91       	pop	r18
    224c:	0f 90       	pop	r0
    224e:	0f be       	out	0x3f, r0	; 63
    2250:	0f 90       	pop	r0
    2252:	1f 90       	pop	r1
    2254:	18 95       	reti

00002256 <__vector_2>:

void __vector_2() __attribute__((signal));
void __vector_2(){
    2256:	1f 92       	push	r1
    2258:	0f 92       	push	r0
    225a:	0f b6       	in	r0, 0x3f	; 63
    225c:	0f 92       	push	r0
    225e:	11 24       	eor	r1, r1
    2260:	2f 93       	push	r18
    2262:	3f 93       	push	r19
    2264:	4f 93       	push	r20
    2266:	5f 93       	push	r21
    2268:	6f 93       	push	r22
    226a:	7f 93       	push	r23
    226c:	8f 93       	push	r24
    226e:	9f 93       	push	r25
    2270:	af 93       	push	r26
    2272:	bf 93       	push	r27
    2274:	ef 93       	push	r30
    2276:	ff 93       	push	r31
    2278:	df 93       	push	r29
    227a:	cf 93       	push	r28
    227c:	cd b7       	in	r28, 0x3d	; 61
    227e:	de b7       	in	r29, 0x3e	; 62

	//if(EXT_u8IsBtnPressed(EXT1)){
		EXT_CallBacks[EXT1]();
    2280:	e0 91 9e 01 	lds	r30, 0x019E
    2284:	f0 91 9f 01 	lds	r31, 0x019F
    2288:	09 95       	icall
	//}
}
    228a:	cf 91       	pop	r28
    228c:	df 91       	pop	r29
    228e:	ff 91       	pop	r31
    2290:	ef 91       	pop	r30
    2292:	bf 91       	pop	r27
    2294:	af 91       	pop	r26
    2296:	9f 91       	pop	r25
    2298:	8f 91       	pop	r24
    229a:	7f 91       	pop	r23
    229c:	6f 91       	pop	r22
    229e:	5f 91       	pop	r21
    22a0:	4f 91       	pop	r20
    22a2:	3f 91       	pop	r19
    22a4:	2f 91       	pop	r18
    22a6:	0f 90       	pop	r0
    22a8:	0f be       	out	0x3f, r0	; 63
    22aa:	0f 90       	pop	r0
    22ac:	1f 90       	pop	r1
    22ae:	18 95       	reti

000022b0 <__vector_3>:


void __vector_3() __attribute__((signal));
void __vector_3(){
    22b0:	1f 92       	push	r1
    22b2:	0f 92       	push	r0
    22b4:	0f b6       	in	r0, 0x3f	; 63
    22b6:	0f 92       	push	r0
    22b8:	11 24       	eor	r1, r1
    22ba:	2f 93       	push	r18
    22bc:	3f 93       	push	r19
    22be:	4f 93       	push	r20
    22c0:	5f 93       	push	r21
    22c2:	6f 93       	push	r22
    22c4:	7f 93       	push	r23
    22c6:	8f 93       	push	r24
    22c8:	9f 93       	push	r25
    22ca:	af 93       	push	r26
    22cc:	bf 93       	push	r27
    22ce:	ef 93       	push	r30
    22d0:	ff 93       	push	r31
    22d2:	df 93       	push	r29
    22d4:	cf 93       	push	r28
    22d6:	cd b7       	in	r28, 0x3d	; 61
    22d8:	de b7       	in	r29, 0x3e	; 62

	//if(EXT_u8IsBtnPressed(EXT2)){
		EXT_CallBacks[EXT2]();
    22da:	e0 91 a0 01 	lds	r30, 0x01A0
    22de:	f0 91 a1 01 	lds	r31, 0x01A1
    22e2:	09 95       	icall
	//}
}
    22e4:	cf 91       	pop	r28
    22e6:	df 91       	pop	r29
    22e8:	ff 91       	pop	r31
    22ea:	ef 91       	pop	r30
    22ec:	bf 91       	pop	r27
    22ee:	af 91       	pop	r26
    22f0:	9f 91       	pop	r25
    22f2:	8f 91       	pop	r24
    22f4:	7f 91       	pop	r23
    22f6:	6f 91       	pop	r22
    22f8:	5f 91       	pop	r21
    22fa:	4f 91       	pop	r20
    22fc:	3f 91       	pop	r19
    22fe:	2f 91       	pop	r18
    2300:	0f 90       	pop	r0
    2302:	0f be       	out	0x3f, r0	; 63
    2304:	0f 90       	pop	r0
    2306:	1f 90       	pop	r1
    2308:	18 95       	reti

0000230a <DIO_voidSetPinDirection>:
/***DIO***/
#include "DIO_Interface.h"
#include "DIO_Private.h"


void DIO_voidSetPinDirection(DIO_PORT_TYPE Copy_u8PortID, DIO_PIN_TYPE Copy_u8PinID, DIO_PIN_DIR_TYPE Copy_u8PinDir){
    230a:	df 93       	push	r29
    230c:	cf 93       	push	r28
    230e:	cd b7       	in	r28, 0x3d	; 61
    2310:	de b7       	in	r29, 0x3e	; 62
    2312:	27 97       	sbiw	r28, 0x07	; 7
    2314:	0f b6       	in	r0, 0x3f	; 63
    2316:	f8 94       	cli
    2318:	de bf       	out	0x3e, r29	; 62
    231a:	0f be       	out	0x3f, r0	; 63
    231c:	cd bf       	out	0x3d, r28	; 61
    231e:	89 83       	std	Y+1, r24	; 0x01
    2320:	6a 83       	std	Y+2, r22	; 0x02
    2322:	4b 83       	std	Y+3, r20	; 0x03

	if(Copy_u8PinDir==PIN_INPUT){
    2324:	8b 81       	ldd	r24, Y+3	; 0x03
    2326:	88 23       	and	r24, r24
    2328:	09 f0       	breq	.+2      	; 0x232c <DIO_voidSetPinDirection+0x22>
    232a:	74 c0       	rjmp	.+232    	; 0x2414 <DIO_voidSetPinDirection+0x10a>
		switch(Copy_u8PortID){
    232c:	89 81       	ldd	r24, Y+1	; 0x01
    232e:	28 2f       	mov	r18, r24
    2330:	30 e0       	ldi	r19, 0x00	; 0
    2332:	3f 83       	std	Y+7, r19	; 0x07
    2334:	2e 83       	std	Y+6, r18	; 0x06
    2336:	8e 81       	ldd	r24, Y+6	; 0x06
    2338:	9f 81       	ldd	r25, Y+7	; 0x07
    233a:	81 30       	cpi	r24, 0x01	; 1
    233c:	91 05       	cpc	r25, r1
    233e:	59 f1       	breq	.+86     	; 0x2396 <DIO_voidSetPinDirection+0x8c>
    2340:	2e 81       	ldd	r18, Y+6	; 0x06
    2342:	3f 81       	ldd	r19, Y+7	; 0x07
    2344:	22 30       	cpi	r18, 0x02	; 2
    2346:	31 05       	cpc	r19, r1
    2348:	2c f4       	brge	.+10     	; 0x2354 <DIO_voidSetPinDirection+0x4a>
    234a:	8e 81       	ldd	r24, Y+6	; 0x06
    234c:	9f 81       	ldd	r25, Y+7	; 0x07
    234e:	00 97       	sbiw	r24, 0x00	; 0
    2350:	69 f0       	breq	.+26     	; 0x236c <DIO_voidSetPinDirection+0x62>
    2352:	d2 c0       	rjmp	.+420    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
    2354:	2e 81       	ldd	r18, Y+6	; 0x06
    2356:	3f 81       	ldd	r19, Y+7	; 0x07
    2358:	22 30       	cpi	r18, 0x02	; 2
    235a:	31 05       	cpc	r19, r1
    235c:	89 f1       	breq	.+98     	; 0x23c0 <DIO_voidSetPinDirection+0xb6>
    235e:	8e 81       	ldd	r24, Y+6	; 0x06
    2360:	9f 81       	ldd	r25, Y+7	; 0x07
    2362:	83 30       	cpi	r24, 0x03	; 3
    2364:	91 05       	cpc	r25, r1
    2366:	09 f4       	brne	.+2      	; 0x236a <DIO_voidSetPinDirection+0x60>
    2368:	40 c0       	rjmp	.+128    	; 0x23ea <DIO_voidSetPinDirection+0xe0>
    236a:	c6 c0       	rjmp	.+396    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
			case PORTA_ID: CLR_BIT(DDRA_REG,Copy_u8PinID);
    236c:	aa e3       	ldi	r26, 0x3A	; 58
    236e:	b0 e0       	ldi	r27, 0x00	; 0
    2370:	ea e3       	ldi	r30, 0x3A	; 58
    2372:	f0 e0       	ldi	r31, 0x00	; 0
    2374:	80 81       	ld	r24, Z
    2376:	48 2f       	mov	r20, r24
    2378:	8a 81       	ldd	r24, Y+2	; 0x02
    237a:	28 2f       	mov	r18, r24
    237c:	30 e0       	ldi	r19, 0x00	; 0
    237e:	81 e0       	ldi	r24, 0x01	; 1
    2380:	90 e0       	ldi	r25, 0x00	; 0
    2382:	02 2e       	mov	r0, r18
    2384:	02 c0       	rjmp	.+4      	; 0x238a <DIO_voidSetPinDirection+0x80>
    2386:	88 0f       	add	r24, r24
    2388:	99 1f       	adc	r25, r25
    238a:	0a 94       	dec	r0
    238c:	e2 f7       	brpl	.-8      	; 0x2386 <DIO_voidSetPinDirection+0x7c>
    238e:	80 95       	com	r24
    2390:	84 23       	and	r24, r20
    2392:	8c 93       	st	X, r24
    2394:	b1 c0       	rjmp	.+354    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
			break;
			case PORTB_ID: CLR_BIT(DDRB_REG,Copy_u8PinID);
    2396:	a7 e3       	ldi	r26, 0x37	; 55
    2398:	b0 e0       	ldi	r27, 0x00	; 0
    239a:	e7 e3       	ldi	r30, 0x37	; 55
    239c:	f0 e0       	ldi	r31, 0x00	; 0
    239e:	80 81       	ld	r24, Z
    23a0:	48 2f       	mov	r20, r24
    23a2:	8a 81       	ldd	r24, Y+2	; 0x02
    23a4:	28 2f       	mov	r18, r24
    23a6:	30 e0       	ldi	r19, 0x00	; 0
    23a8:	81 e0       	ldi	r24, 0x01	; 1
    23aa:	90 e0       	ldi	r25, 0x00	; 0
    23ac:	02 2e       	mov	r0, r18
    23ae:	02 c0       	rjmp	.+4      	; 0x23b4 <DIO_voidSetPinDirection+0xaa>
    23b0:	88 0f       	add	r24, r24
    23b2:	99 1f       	adc	r25, r25
    23b4:	0a 94       	dec	r0
    23b6:	e2 f7       	brpl	.-8      	; 0x23b0 <DIO_voidSetPinDirection+0xa6>
    23b8:	80 95       	com	r24
    23ba:	84 23       	and	r24, r20
    23bc:	8c 93       	st	X, r24
    23be:	9c c0       	rjmp	.+312    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
			break;
			case PORTC_ID: CLR_BIT(DDRC_REG,Copy_u8PinID);
    23c0:	a4 e3       	ldi	r26, 0x34	; 52
    23c2:	b0 e0       	ldi	r27, 0x00	; 0
    23c4:	e4 e3       	ldi	r30, 0x34	; 52
    23c6:	f0 e0       	ldi	r31, 0x00	; 0
    23c8:	80 81       	ld	r24, Z
    23ca:	48 2f       	mov	r20, r24
    23cc:	8a 81       	ldd	r24, Y+2	; 0x02
    23ce:	28 2f       	mov	r18, r24
    23d0:	30 e0       	ldi	r19, 0x00	; 0
    23d2:	81 e0       	ldi	r24, 0x01	; 1
    23d4:	90 e0       	ldi	r25, 0x00	; 0
    23d6:	02 2e       	mov	r0, r18
    23d8:	02 c0       	rjmp	.+4      	; 0x23de <DIO_voidSetPinDirection+0xd4>
    23da:	88 0f       	add	r24, r24
    23dc:	99 1f       	adc	r25, r25
    23de:	0a 94       	dec	r0
    23e0:	e2 f7       	brpl	.-8      	; 0x23da <DIO_voidSetPinDirection+0xd0>
    23e2:	80 95       	com	r24
    23e4:	84 23       	and	r24, r20
    23e6:	8c 93       	st	X, r24
    23e8:	87 c0       	rjmp	.+270    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
			break;
			case PORTD_ID: CLR_BIT(DDRD_REG,Copy_u8PinID);
    23ea:	a1 e3       	ldi	r26, 0x31	; 49
    23ec:	b0 e0       	ldi	r27, 0x00	; 0
    23ee:	e1 e3       	ldi	r30, 0x31	; 49
    23f0:	f0 e0       	ldi	r31, 0x00	; 0
    23f2:	80 81       	ld	r24, Z
    23f4:	48 2f       	mov	r20, r24
    23f6:	8a 81       	ldd	r24, Y+2	; 0x02
    23f8:	28 2f       	mov	r18, r24
    23fa:	30 e0       	ldi	r19, 0x00	; 0
    23fc:	81 e0       	ldi	r24, 0x01	; 1
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	02 2e       	mov	r0, r18
    2402:	02 c0       	rjmp	.+4      	; 0x2408 <DIO_voidSetPinDirection+0xfe>
    2404:	88 0f       	add	r24, r24
    2406:	99 1f       	adc	r25, r25
    2408:	0a 94       	dec	r0
    240a:	e2 f7       	brpl	.-8      	; 0x2404 <DIO_voidSetPinDirection+0xfa>
    240c:	80 95       	com	r24
    240e:	84 23       	and	r24, r20
    2410:	8c 93       	st	X, r24
    2412:	72 c0       	rjmp	.+228    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
			break;
		}
	}
	else if(Copy_u8PinDir==PIN_OUTPUT){
    2414:	8b 81       	ldd	r24, Y+3	; 0x03
    2416:	81 30       	cpi	r24, 0x01	; 1
    2418:	09 f0       	breq	.+2      	; 0x241c <DIO_voidSetPinDirection+0x112>
    241a:	6e c0       	rjmp	.+220    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
		switch(Copy_u8PortID){
    241c:	89 81       	ldd	r24, Y+1	; 0x01
    241e:	28 2f       	mov	r18, r24
    2420:	30 e0       	ldi	r19, 0x00	; 0
    2422:	3d 83       	std	Y+5, r19	; 0x05
    2424:	2c 83       	std	Y+4, r18	; 0x04
    2426:	8c 81       	ldd	r24, Y+4	; 0x04
    2428:	9d 81       	ldd	r25, Y+5	; 0x05
    242a:	81 30       	cpi	r24, 0x01	; 1
    242c:	91 05       	cpc	r25, r1
    242e:	49 f1       	breq	.+82     	; 0x2482 <DIO_voidSetPinDirection+0x178>
    2430:	2c 81       	ldd	r18, Y+4	; 0x04
    2432:	3d 81       	ldd	r19, Y+5	; 0x05
    2434:	22 30       	cpi	r18, 0x02	; 2
    2436:	31 05       	cpc	r19, r1
    2438:	2c f4       	brge	.+10     	; 0x2444 <DIO_voidSetPinDirection+0x13a>
    243a:	8c 81       	ldd	r24, Y+4	; 0x04
    243c:	9d 81       	ldd	r25, Y+5	; 0x05
    243e:	00 97       	sbiw	r24, 0x00	; 0
    2440:	61 f0       	breq	.+24     	; 0x245a <DIO_voidSetPinDirection+0x150>
    2442:	5a c0       	rjmp	.+180    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
    2444:	2c 81       	ldd	r18, Y+4	; 0x04
    2446:	3d 81       	ldd	r19, Y+5	; 0x05
    2448:	22 30       	cpi	r18, 0x02	; 2
    244a:	31 05       	cpc	r19, r1
    244c:	71 f1       	breq	.+92     	; 0x24aa <DIO_voidSetPinDirection+0x1a0>
    244e:	8c 81       	ldd	r24, Y+4	; 0x04
    2450:	9d 81       	ldd	r25, Y+5	; 0x05
    2452:	83 30       	cpi	r24, 0x03	; 3
    2454:	91 05       	cpc	r25, r1
    2456:	e9 f1       	breq	.+122    	; 0x24d2 <DIO_voidSetPinDirection+0x1c8>
    2458:	4f c0       	rjmp	.+158    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
			case PORTA_ID: SET_BIT(DDRA_REG,Copy_u8PinID);
    245a:	aa e3       	ldi	r26, 0x3A	; 58
    245c:	b0 e0       	ldi	r27, 0x00	; 0
    245e:	ea e3       	ldi	r30, 0x3A	; 58
    2460:	f0 e0       	ldi	r31, 0x00	; 0
    2462:	80 81       	ld	r24, Z
    2464:	48 2f       	mov	r20, r24
    2466:	8a 81       	ldd	r24, Y+2	; 0x02
    2468:	28 2f       	mov	r18, r24
    246a:	30 e0       	ldi	r19, 0x00	; 0
    246c:	81 e0       	ldi	r24, 0x01	; 1
    246e:	90 e0       	ldi	r25, 0x00	; 0
    2470:	02 2e       	mov	r0, r18
    2472:	02 c0       	rjmp	.+4      	; 0x2478 <DIO_voidSetPinDirection+0x16e>
    2474:	88 0f       	add	r24, r24
    2476:	99 1f       	adc	r25, r25
    2478:	0a 94       	dec	r0
    247a:	e2 f7       	brpl	.-8      	; 0x2474 <DIO_voidSetPinDirection+0x16a>
    247c:	84 2b       	or	r24, r20
    247e:	8c 93       	st	X, r24
    2480:	3b c0       	rjmp	.+118    	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
			break;
			case PORTB_ID: SET_BIT(DDRB_REG,Copy_u8PinID);
    2482:	a7 e3       	ldi	r26, 0x37	; 55
    2484:	b0 e0       	ldi	r27, 0x00	; 0
    2486:	e7 e3       	ldi	r30, 0x37	; 55
    2488:	f0 e0       	ldi	r31, 0x00	; 0
    248a:	80 81       	ld	r24, Z
    248c:	48 2f       	mov	r20, r24
    248e:	8a 81       	ldd	r24, Y+2	; 0x02
    2490:	28 2f       	mov	r18, r24
    2492:	30 e0       	ldi	r19, 0x00	; 0
    2494:	81 e0       	ldi	r24, 0x01	; 1
    2496:	90 e0       	ldi	r25, 0x00	; 0
    2498:	02 2e       	mov	r0, r18
    249a:	02 c0       	rjmp	.+4      	; 0x24a0 <DIO_voidSetPinDirection+0x196>
    249c:	88 0f       	add	r24, r24
    249e:	99 1f       	adc	r25, r25
    24a0:	0a 94       	dec	r0
    24a2:	e2 f7       	brpl	.-8      	; 0x249c <DIO_voidSetPinDirection+0x192>
    24a4:	84 2b       	or	r24, r20
    24a6:	8c 93       	st	X, r24
    24a8:	27 c0       	rjmp	.+78     	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
			break;
			case PORTC_ID: SET_BIT(DDRC_REG,Copy_u8PinID);
    24aa:	a4 e3       	ldi	r26, 0x34	; 52
    24ac:	b0 e0       	ldi	r27, 0x00	; 0
    24ae:	e4 e3       	ldi	r30, 0x34	; 52
    24b0:	f0 e0       	ldi	r31, 0x00	; 0
    24b2:	80 81       	ld	r24, Z
    24b4:	48 2f       	mov	r20, r24
    24b6:	8a 81       	ldd	r24, Y+2	; 0x02
    24b8:	28 2f       	mov	r18, r24
    24ba:	30 e0       	ldi	r19, 0x00	; 0
    24bc:	81 e0       	ldi	r24, 0x01	; 1
    24be:	90 e0       	ldi	r25, 0x00	; 0
    24c0:	02 2e       	mov	r0, r18
    24c2:	02 c0       	rjmp	.+4      	; 0x24c8 <DIO_voidSetPinDirection+0x1be>
    24c4:	88 0f       	add	r24, r24
    24c6:	99 1f       	adc	r25, r25
    24c8:	0a 94       	dec	r0
    24ca:	e2 f7       	brpl	.-8      	; 0x24c4 <DIO_voidSetPinDirection+0x1ba>
    24cc:	84 2b       	or	r24, r20
    24ce:	8c 93       	st	X, r24
    24d0:	13 c0       	rjmp	.+38     	; 0x24f8 <DIO_voidSetPinDirection+0x1ee>
			break;
			case PORTD_ID: SET_BIT(DDRD_REG,Copy_u8PinID);
    24d2:	a1 e3       	ldi	r26, 0x31	; 49
    24d4:	b0 e0       	ldi	r27, 0x00	; 0
    24d6:	e1 e3       	ldi	r30, 0x31	; 49
    24d8:	f0 e0       	ldi	r31, 0x00	; 0
    24da:	80 81       	ld	r24, Z
    24dc:	48 2f       	mov	r20, r24
    24de:	8a 81       	ldd	r24, Y+2	; 0x02
    24e0:	28 2f       	mov	r18, r24
    24e2:	30 e0       	ldi	r19, 0x00	; 0
    24e4:	81 e0       	ldi	r24, 0x01	; 1
    24e6:	90 e0       	ldi	r25, 0x00	; 0
    24e8:	02 2e       	mov	r0, r18
    24ea:	02 c0       	rjmp	.+4      	; 0x24f0 <DIO_voidSetPinDirection+0x1e6>
    24ec:	88 0f       	add	r24, r24
    24ee:	99 1f       	adc	r25, r25
    24f0:	0a 94       	dec	r0
    24f2:	e2 f7       	brpl	.-8      	; 0x24ec <DIO_voidSetPinDirection+0x1e2>
    24f4:	84 2b       	or	r24, r20
    24f6:	8c 93       	st	X, r24
			break;
		}
	}

}
    24f8:	27 96       	adiw	r28, 0x07	; 7
    24fa:	0f b6       	in	r0, 0x3f	; 63
    24fc:	f8 94       	cli
    24fe:	de bf       	out	0x3e, r29	; 62
    2500:	0f be       	out	0x3f, r0	; 63
    2502:	cd bf       	out	0x3d, r28	; 61
    2504:	cf 91       	pop	r28
    2506:	df 91       	pop	r29
    2508:	08 95       	ret

0000250a <DIO_voidSetPinValue>:

void DIO_voidSetPinValue(DIO_PORT_TYPE Copy_u8PortID, DIO_PIN_TYPE Copy_u8PinID, DIO_PIN_VAL_TYPE Copy_u8PinVal){
    250a:	df 93       	push	r29
    250c:	cf 93       	push	r28
    250e:	cd b7       	in	r28, 0x3d	; 61
    2510:	de b7       	in	r29, 0x3e	; 62
    2512:	27 97       	sbiw	r28, 0x07	; 7
    2514:	0f b6       	in	r0, 0x3f	; 63
    2516:	f8 94       	cli
    2518:	de bf       	out	0x3e, r29	; 62
    251a:	0f be       	out	0x3f, r0	; 63
    251c:	cd bf       	out	0x3d, r28	; 61
    251e:	89 83       	std	Y+1, r24	; 0x01
    2520:	6a 83       	std	Y+2, r22	; 0x02
    2522:	4b 83       	std	Y+3, r20	; 0x03

	if(Copy_u8PinVal==PIN_LOW){
    2524:	8b 81       	ldd	r24, Y+3	; 0x03
    2526:	88 23       	and	r24, r24
    2528:	09 f0       	breq	.+2      	; 0x252c <DIO_voidSetPinValue+0x22>
    252a:	74 c0       	rjmp	.+232    	; 0x2614 <DIO_voidSetPinValue+0x10a>
		switch(Copy_u8PortID){
    252c:	89 81       	ldd	r24, Y+1	; 0x01
    252e:	28 2f       	mov	r18, r24
    2530:	30 e0       	ldi	r19, 0x00	; 0
    2532:	3f 83       	std	Y+7, r19	; 0x07
    2534:	2e 83       	std	Y+6, r18	; 0x06
    2536:	8e 81       	ldd	r24, Y+6	; 0x06
    2538:	9f 81       	ldd	r25, Y+7	; 0x07
    253a:	81 30       	cpi	r24, 0x01	; 1
    253c:	91 05       	cpc	r25, r1
    253e:	59 f1       	breq	.+86     	; 0x2596 <DIO_voidSetPinValue+0x8c>
    2540:	2e 81       	ldd	r18, Y+6	; 0x06
    2542:	3f 81       	ldd	r19, Y+7	; 0x07
    2544:	22 30       	cpi	r18, 0x02	; 2
    2546:	31 05       	cpc	r19, r1
    2548:	2c f4       	brge	.+10     	; 0x2554 <DIO_voidSetPinValue+0x4a>
    254a:	8e 81       	ldd	r24, Y+6	; 0x06
    254c:	9f 81       	ldd	r25, Y+7	; 0x07
    254e:	00 97       	sbiw	r24, 0x00	; 0
    2550:	69 f0       	breq	.+26     	; 0x256c <DIO_voidSetPinValue+0x62>
    2552:	d2 c0       	rjmp	.+420    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
    2554:	2e 81       	ldd	r18, Y+6	; 0x06
    2556:	3f 81       	ldd	r19, Y+7	; 0x07
    2558:	22 30       	cpi	r18, 0x02	; 2
    255a:	31 05       	cpc	r19, r1
    255c:	89 f1       	breq	.+98     	; 0x25c0 <DIO_voidSetPinValue+0xb6>
    255e:	8e 81       	ldd	r24, Y+6	; 0x06
    2560:	9f 81       	ldd	r25, Y+7	; 0x07
    2562:	83 30       	cpi	r24, 0x03	; 3
    2564:	91 05       	cpc	r25, r1
    2566:	09 f4       	brne	.+2      	; 0x256a <DIO_voidSetPinValue+0x60>
    2568:	40 c0       	rjmp	.+128    	; 0x25ea <DIO_voidSetPinValue+0xe0>
    256a:	c6 c0       	rjmp	.+396    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
			case PORTA_ID: CLR_BIT(PORTA_REG,Copy_u8PinID);
    256c:	ab e3       	ldi	r26, 0x3B	; 59
    256e:	b0 e0       	ldi	r27, 0x00	; 0
    2570:	eb e3       	ldi	r30, 0x3B	; 59
    2572:	f0 e0       	ldi	r31, 0x00	; 0
    2574:	80 81       	ld	r24, Z
    2576:	48 2f       	mov	r20, r24
    2578:	8a 81       	ldd	r24, Y+2	; 0x02
    257a:	28 2f       	mov	r18, r24
    257c:	30 e0       	ldi	r19, 0x00	; 0
    257e:	81 e0       	ldi	r24, 0x01	; 1
    2580:	90 e0       	ldi	r25, 0x00	; 0
    2582:	02 2e       	mov	r0, r18
    2584:	02 c0       	rjmp	.+4      	; 0x258a <DIO_voidSetPinValue+0x80>
    2586:	88 0f       	add	r24, r24
    2588:	99 1f       	adc	r25, r25
    258a:	0a 94       	dec	r0
    258c:	e2 f7       	brpl	.-8      	; 0x2586 <DIO_voidSetPinValue+0x7c>
    258e:	80 95       	com	r24
    2590:	84 23       	and	r24, r20
    2592:	8c 93       	st	X, r24
    2594:	b1 c0       	rjmp	.+354    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
			break;
			case PORTB_ID: CLR_BIT(PORTB_REG,Copy_u8PinID);
    2596:	a8 e3       	ldi	r26, 0x38	; 56
    2598:	b0 e0       	ldi	r27, 0x00	; 0
    259a:	e8 e3       	ldi	r30, 0x38	; 56
    259c:	f0 e0       	ldi	r31, 0x00	; 0
    259e:	80 81       	ld	r24, Z
    25a0:	48 2f       	mov	r20, r24
    25a2:	8a 81       	ldd	r24, Y+2	; 0x02
    25a4:	28 2f       	mov	r18, r24
    25a6:	30 e0       	ldi	r19, 0x00	; 0
    25a8:	81 e0       	ldi	r24, 0x01	; 1
    25aa:	90 e0       	ldi	r25, 0x00	; 0
    25ac:	02 2e       	mov	r0, r18
    25ae:	02 c0       	rjmp	.+4      	; 0x25b4 <DIO_voidSetPinValue+0xaa>
    25b0:	88 0f       	add	r24, r24
    25b2:	99 1f       	adc	r25, r25
    25b4:	0a 94       	dec	r0
    25b6:	e2 f7       	brpl	.-8      	; 0x25b0 <DIO_voidSetPinValue+0xa6>
    25b8:	80 95       	com	r24
    25ba:	84 23       	and	r24, r20
    25bc:	8c 93       	st	X, r24
    25be:	9c c0       	rjmp	.+312    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
			break;
			case PORTC_ID: CLR_BIT(PORTC_REG,Copy_u8PinID);
    25c0:	a5 e3       	ldi	r26, 0x35	; 53
    25c2:	b0 e0       	ldi	r27, 0x00	; 0
    25c4:	e5 e3       	ldi	r30, 0x35	; 53
    25c6:	f0 e0       	ldi	r31, 0x00	; 0
    25c8:	80 81       	ld	r24, Z
    25ca:	48 2f       	mov	r20, r24
    25cc:	8a 81       	ldd	r24, Y+2	; 0x02
    25ce:	28 2f       	mov	r18, r24
    25d0:	30 e0       	ldi	r19, 0x00	; 0
    25d2:	81 e0       	ldi	r24, 0x01	; 1
    25d4:	90 e0       	ldi	r25, 0x00	; 0
    25d6:	02 2e       	mov	r0, r18
    25d8:	02 c0       	rjmp	.+4      	; 0x25de <DIO_voidSetPinValue+0xd4>
    25da:	88 0f       	add	r24, r24
    25dc:	99 1f       	adc	r25, r25
    25de:	0a 94       	dec	r0
    25e0:	e2 f7       	brpl	.-8      	; 0x25da <DIO_voidSetPinValue+0xd0>
    25e2:	80 95       	com	r24
    25e4:	84 23       	and	r24, r20
    25e6:	8c 93       	st	X, r24
    25e8:	87 c0       	rjmp	.+270    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
			break;
			case PORTD_ID: CLR_BIT(PORTD_REG,Copy_u8PinID);
    25ea:	a2 e3       	ldi	r26, 0x32	; 50
    25ec:	b0 e0       	ldi	r27, 0x00	; 0
    25ee:	e2 e3       	ldi	r30, 0x32	; 50
    25f0:	f0 e0       	ldi	r31, 0x00	; 0
    25f2:	80 81       	ld	r24, Z
    25f4:	48 2f       	mov	r20, r24
    25f6:	8a 81       	ldd	r24, Y+2	; 0x02
    25f8:	28 2f       	mov	r18, r24
    25fa:	30 e0       	ldi	r19, 0x00	; 0
    25fc:	81 e0       	ldi	r24, 0x01	; 1
    25fe:	90 e0       	ldi	r25, 0x00	; 0
    2600:	02 2e       	mov	r0, r18
    2602:	02 c0       	rjmp	.+4      	; 0x2608 <DIO_voidSetPinValue+0xfe>
    2604:	88 0f       	add	r24, r24
    2606:	99 1f       	adc	r25, r25
    2608:	0a 94       	dec	r0
    260a:	e2 f7       	brpl	.-8      	; 0x2604 <DIO_voidSetPinValue+0xfa>
    260c:	80 95       	com	r24
    260e:	84 23       	and	r24, r20
    2610:	8c 93       	st	X, r24
    2612:	72 c0       	rjmp	.+228    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
			break;
		}
	}
	else if(Copy_u8PinVal==PIN_HIGH){
    2614:	8b 81       	ldd	r24, Y+3	; 0x03
    2616:	81 30       	cpi	r24, 0x01	; 1
    2618:	09 f0       	breq	.+2      	; 0x261c <DIO_voidSetPinValue+0x112>
    261a:	6e c0       	rjmp	.+220    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
		switch(Copy_u8PortID){
    261c:	89 81       	ldd	r24, Y+1	; 0x01
    261e:	28 2f       	mov	r18, r24
    2620:	30 e0       	ldi	r19, 0x00	; 0
    2622:	3d 83       	std	Y+5, r19	; 0x05
    2624:	2c 83       	std	Y+4, r18	; 0x04
    2626:	8c 81       	ldd	r24, Y+4	; 0x04
    2628:	9d 81       	ldd	r25, Y+5	; 0x05
    262a:	81 30       	cpi	r24, 0x01	; 1
    262c:	91 05       	cpc	r25, r1
    262e:	49 f1       	breq	.+82     	; 0x2682 <DIO_voidSetPinValue+0x178>
    2630:	2c 81       	ldd	r18, Y+4	; 0x04
    2632:	3d 81       	ldd	r19, Y+5	; 0x05
    2634:	22 30       	cpi	r18, 0x02	; 2
    2636:	31 05       	cpc	r19, r1
    2638:	2c f4       	brge	.+10     	; 0x2644 <DIO_voidSetPinValue+0x13a>
    263a:	8c 81       	ldd	r24, Y+4	; 0x04
    263c:	9d 81       	ldd	r25, Y+5	; 0x05
    263e:	00 97       	sbiw	r24, 0x00	; 0
    2640:	61 f0       	breq	.+24     	; 0x265a <DIO_voidSetPinValue+0x150>
    2642:	5a c0       	rjmp	.+180    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
    2644:	2c 81       	ldd	r18, Y+4	; 0x04
    2646:	3d 81       	ldd	r19, Y+5	; 0x05
    2648:	22 30       	cpi	r18, 0x02	; 2
    264a:	31 05       	cpc	r19, r1
    264c:	71 f1       	breq	.+92     	; 0x26aa <DIO_voidSetPinValue+0x1a0>
    264e:	8c 81       	ldd	r24, Y+4	; 0x04
    2650:	9d 81       	ldd	r25, Y+5	; 0x05
    2652:	83 30       	cpi	r24, 0x03	; 3
    2654:	91 05       	cpc	r25, r1
    2656:	e9 f1       	breq	.+122    	; 0x26d2 <DIO_voidSetPinValue+0x1c8>
    2658:	4f c0       	rjmp	.+158    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
			case PORTA_ID: SET_BIT(PORTA_REG,Copy_u8PinID);
    265a:	ab e3       	ldi	r26, 0x3B	; 59
    265c:	b0 e0       	ldi	r27, 0x00	; 0
    265e:	eb e3       	ldi	r30, 0x3B	; 59
    2660:	f0 e0       	ldi	r31, 0x00	; 0
    2662:	80 81       	ld	r24, Z
    2664:	48 2f       	mov	r20, r24
    2666:	8a 81       	ldd	r24, Y+2	; 0x02
    2668:	28 2f       	mov	r18, r24
    266a:	30 e0       	ldi	r19, 0x00	; 0
    266c:	81 e0       	ldi	r24, 0x01	; 1
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	02 2e       	mov	r0, r18
    2672:	02 c0       	rjmp	.+4      	; 0x2678 <DIO_voidSetPinValue+0x16e>
    2674:	88 0f       	add	r24, r24
    2676:	99 1f       	adc	r25, r25
    2678:	0a 94       	dec	r0
    267a:	e2 f7       	brpl	.-8      	; 0x2674 <DIO_voidSetPinValue+0x16a>
    267c:	84 2b       	or	r24, r20
    267e:	8c 93       	st	X, r24
    2680:	3b c0       	rjmp	.+118    	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
			break;
			case PORTB_ID: SET_BIT(PORTB_REG,Copy_u8PinID);
    2682:	a8 e3       	ldi	r26, 0x38	; 56
    2684:	b0 e0       	ldi	r27, 0x00	; 0
    2686:	e8 e3       	ldi	r30, 0x38	; 56
    2688:	f0 e0       	ldi	r31, 0x00	; 0
    268a:	80 81       	ld	r24, Z
    268c:	48 2f       	mov	r20, r24
    268e:	8a 81       	ldd	r24, Y+2	; 0x02
    2690:	28 2f       	mov	r18, r24
    2692:	30 e0       	ldi	r19, 0x00	; 0
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	02 2e       	mov	r0, r18
    269a:	02 c0       	rjmp	.+4      	; 0x26a0 <DIO_voidSetPinValue+0x196>
    269c:	88 0f       	add	r24, r24
    269e:	99 1f       	adc	r25, r25
    26a0:	0a 94       	dec	r0
    26a2:	e2 f7       	brpl	.-8      	; 0x269c <DIO_voidSetPinValue+0x192>
    26a4:	84 2b       	or	r24, r20
    26a6:	8c 93       	st	X, r24
    26a8:	27 c0       	rjmp	.+78     	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
			break;
			case PORTC_ID: SET_BIT(PORTC_REG,Copy_u8PinID);
    26aa:	a5 e3       	ldi	r26, 0x35	; 53
    26ac:	b0 e0       	ldi	r27, 0x00	; 0
    26ae:	e5 e3       	ldi	r30, 0x35	; 53
    26b0:	f0 e0       	ldi	r31, 0x00	; 0
    26b2:	80 81       	ld	r24, Z
    26b4:	48 2f       	mov	r20, r24
    26b6:	8a 81       	ldd	r24, Y+2	; 0x02
    26b8:	28 2f       	mov	r18, r24
    26ba:	30 e0       	ldi	r19, 0x00	; 0
    26bc:	81 e0       	ldi	r24, 0x01	; 1
    26be:	90 e0       	ldi	r25, 0x00	; 0
    26c0:	02 2e       	mov	r0, r18
    26c2:	02 c0       	rjmp	.+4      	; 0x26c8 <DIO_voidSetPinValue+0x1be>
    26c4:	88 0f       	add	r24, r24
    26c6:	99 1f       	adc	r25, r25
    26c8:	0a 94       	dec	r0
    26ca:	e2 f7       	brpl	.-8      	; 0x26c4 <DIO_voidSetPinValue+0x1ba>
    26cc:	84 2b       	or	r24, r20
    26ce:	8c 93       	st	X, r24
    26d0:	13 c0       	rjmp	.+38     	; 0x26f8 <DIO_voidSetPinValue+0x1ee>
			break;
			case PORTD_ID: SET_BIT(PORTD_REG,Copy_u8PinID);
    26d2:	a2 e3       	ldi	r26, 0x32	; 50
    26d4:	b0 e0       	ldi	r27, 0x00	; 0
    26d6:	e2 e3       	ldi	r30, 0x32	; 50
    26d8:	f0 e0       	ldi	r31, 0x00	; 0
    26da:	80 81       	ld	r24, Z
    26dc:	48 2f       	mov	r20, r24
    26de:	8a 81       	ldd	r24, Y+2	; 0x02
    26e0:	28 2f       	mov	r18, r24
    26e2:	30 e0       	ldi	r19, 0x00	; 0
    26e4:	81 e0       	ldi	r24, 0x01	; 1
    26e6:	90 e0       	ldi	r25, 0x00	; 0
    26e8:	02 2e       	mov	r0, r18
    26ea:	02 c0       	rjmp	.+4      	; 0x26f0 <DIO_voidSetPinValue+0x1e6>
    26ec:	88 0f       	add	r24, r24
    26ee:	99 1f       	adc	r25, r25
    26f0:	0a 94       	dec	r0
    26f2:	e2 f7       	brpl	.-8      	; 0x26ec <DIO_voidSetPinValue+0x1e2>
    26f4:	84 2b       	or	r24, r20
    26f6:	8c 93       	st	X, r24
			break;
		}
	}
}
    26f8:	27 96       	adiw	r28, 0x07	; 7
    26fa:	0f b6       	in	r0, 0x3f	; 63
    26fc:	f8 94       	cli
    26fe:	de bf       	out	0x3e, r29	; 62
    2700:	0f be       	out	0x3f, r0	; 63
    2702:	cd bf       	out	0x3d, r28	; 61
    2704:	cf 91       	pop	r28
    2706:	df 91       	pop	r29
    2708:	08 95       	ret

0000270a <DIO_voidSetPortDirection>:

void DIO_voidSetPortDirection(DIO_PORT_TYPE Copy_u8PortID, DIO_PORT_DIR_TYPE Copy_u8PortDir){
    270a:	df 93       	push	r29
    270c:	cf 93       	push	r28
    270e:	00 d0       	rcall	.+0      	; 0x2710 <DIO_voidSetPortDirection+0x6>
    2710:	00 d0       	rcall	.+0      	; 0x2712 <DIO_voidSetPortDirection+0x8>
    2712:	cd b7       	in	r28, 0x3d	; 61
    2714:	de b7       	in	r29, 0x3e	; 62
    2716:	89 83       	std	Y+1, r24	; 0x01
    2718:	6a 83       	std	Y+2, r22	; 0x02

	switch(Copy_u8PortID){
    271a:	89 81       	ldd	r24, Y+1	; 0x01
    271c:	28 2f       	mov	r18, r24
    271e:	30 e0       	ldi	r19, 0x00	; 0
    2720:	3c 83       	std	Y+4, r19	; 0x04
    2722:	2b 83       	std	Y+3, r18	; 0x03
    2724:	8b 81       	ldd	r24, Y+3	; 0x03
    2726:	9c 81       	ldd	r25, Y+4	; 0x04
    2728:	81 30       	cpi	r24, 0x01	; 1
    272a:	91 05       	cpc	r25, r1
    272c:	d1 f0       	breq	.+52     	; 0x2762 <DIO_voidSetPortDirection+0x58>
    272e:	2b 81       	ldd	r18, Y+3	; 0x03
    2730:	3c 81       	ldd	r19, Y+4	; 0x04
    2732:	22 30       	cpi	r18, 0x02	; 2
    2734:	31 05       	cpc	r19, r1
    2736:	2c f4       	brge	.+10     	; 0x2742 <DIO_voidSetPortDirection+0x38>
    2738:	8b 81       	ldd	r24, Y+3	; 0x03
    273a:	9c 81       	ldd	r25, Y+4	; 0x04
    273c:	00 97       	sbiw	r24, 0x00	; 0
    273e:	61 f0       	breq	.+24     	; 0x2758 <DIO_voidSetPortDirection+0x4e>
    2740:	1e c0       	rjmp	.+60     	; 0x277e <DIO_voidSetPortDirection+0x74>
    2742:	2b 81       	ldd	r18, Y+3	; 0x03
    2744:	3c 81       	ldd	r19, Y+4	; 0x04
    2746:	22 30       	cpi	r18, 0x02	; 2
    2748:	31 05       	cpc	r19, r1
    274a:	81 f0       	breq	.+32     	; 0x276c <DIO_voidSetPortDirection+0x62>
    274c:	8b 81       	ldd	r24, Y+3	; 0x03
    274e:	9c 81       	ldd	r25, Y+4	; 0x04
    2750:	83 30       	cpi	r24, 0x03	; 3
    2752:	91 05       	cpc	r25, r1
    2754:	81 f0       	breq	.+32     	; 0x2776 <DIO_voidSetPortDirection+0x6c>
    2756:	13 c0       	rjmp	.+38     	; 0x277e <DIO_voidSetPortDirection+0x74>
		case PORTA_ID: DDRA_REG = Copy_u8PortDir;
    2758:	ea e3       	ldi	r30, 0x3A	; 58
    275a:	f0 e0       	ldi	r31, 0x00	; 0
    275c:	8a 81       	ldd	r24, Y+2	; 0x02
    275e:	80 83       	st	Z, r24
    2760:	0e c0       	rjmp	.+28     	; 0x277e <DIO_voidSetPortDirection+0x74>
		break;
		case PORTB_ID: DDRB_REG = Copy_u8PortDir;
    2762:	e7 e3       	ldi	r30, 0x37	; 55
    2764:	f0 e0       	ldi	r31, 0x00	; 0
    2766:	8a 81       	ldd	r24, Y+2	; 0x02
    2768:	80 83       	st	Z, r24
    276a:	09 c0       	rjmp	.+18     	; 0x277e <DIO_voidSetPortDirection+0x74>
		break;
		case PORTC_ID: DDRC_REG = Copy_u8PortDir;
    276c:	e4 e3       	ldi	r30, 0x34	; 52
    276e:	f0 e0       	ldi	r31, 0x00	; 0
    2770:	8a 81       	ldd	r24, Y+2	; 0x02
    2772:	80 83       	st	Z, r24
    2774:	04 c0       	rjmp	.+8      	; 0x277e <DIO_voidSetPortDirection+0x74>
		break;
		case PORTD_ID: DDRD_REG = Copy_u8PortDir;
    2776:	e1 e3       	ldi	r30, 0x31	; 49
    2778:	f0 e0       	ldi	r31, 0x00	; 0
    277a:	8a 81       	ldd	r24, Y+2	; 0x02
    277c:	80 83       	st	Z, r24
		break;
	}
}
    277e:	0f 90       	pop	r0
    2780:	0f 90       	pop	r0
    2782:	0f 90       	pop	r0
    2784:	0f 90       	pop	r0
    2786:	cf 91       	pop	r28
    2788:	df 91       	pop	r29
    278a:	08 95       	ret

0000278c <DIO_voidSetPortValue>:

void DIO_voidSetPortValue(DIO_PORT_TYPE Copy_u8PortID, DIO_PIN_VAL_TYPE Copy_u8PortVal){
    278c:	df 93       	push	r29
    278e:	cf 93       	push	r28
    2790:	00 d0       	rcall	.+0      	; 0x2792 <DIO_voidSetPortValue+0x6>
    2792:	00 d0       	rcall	.+0      	; 0x2794 <DIO_voidSetPortValue+0x8>
    2794:	cd b7       	in	r28, 0x3d	; 61
    2796:	de b7       	in	r29, 0x3e	; 62
    2798:	89 83       	std	Y+1, r24	; 0x01
    279a:	6a 83       	std	Y+2, r22	; 0x02

	switch(Copy_u8PortID){
    279c:	89 81       	ldd	r24, Y+1	; 0x01
    279e:	28 2f       	mov	r18, r24
    27a0:	30 e0       	ldi	r19, 0x00	; 0
    27a2:	3c 83       	std	Y+4, r19	; 0x04
    27a4:	2b 83       	std	Y+3, r18	; 0x03
    27a6:	8b 81       	ldd	r24, Y+3	; 0x03
    27a8:	9c 81       	ldd	r25, Y+4	; 0x04
    27aa:	81 30       	cpi	r24, 0x01	; 1
    27ac:	91 05       	cpc	r25, r1
    27ae:	d1 f0       	breq	.+52     	; 0x27e4 <DIO_voidSetPortValue+0x58>
    27b0:	2b 81       	ldd	r18, Y+3	; 0x03
    27b2:	3c 81       	ldd	r19, Y+4	; 0x04
    27b4:	22 30       	cpi	r18, 0x02	; 2
    27b6:	31 05       	cpc	r19, r1
    27b8:	2c f4       	brge	.+10     	; 0x27c4 <DIO_voidSetPortValue+0x38>
    27ba:	8b 81       	ldd	r24, Y+3	; 0x03
    27bc:	9c 81       	ldd	r25, Y+4	; 0x04
    27be:	00 97       	sbiw	r24, 0x00	; 0
    27c0:	61 f0       	breq	.+24     	; 0x27da <DIO_voidSetPortValue+0x4e>
    27c2:	1e c0       	rjmp	.+60     	; 0x2800 <DIO_voidSetPortValue+0x74>
    27c4:	2b 81       	ldd	r18, Y+3	; 0x03
    27c6:	3c 81       	ldd	r19, Y+4	; 0x04
    27c8:	22 30       	cpi	r18, 0x02	; 2
    27ca:	31 05       	cpc	r19, r1
    27cc:	81 f0       	breq	.+32     	; 0x27ee <DIO_voidSetPortValue+0x62>
    27ce:	8b 81       	ldd	r24, Y+3	; 0x03
    27d0:	9c 81       	ldd	r25, Y+4	; 0x04
    27d2:	83 30       	cpi	r24, 0x03	; 3
    27d4:	91 05       	cpc	r25, r1
    27d6:	81 f0       	breq	.+32     	; 0x27f8 <DIO_voidSetPortValue+0x6c>
    27d8:	13 c0       	rjmp	.+38     	; 0x2800 <DIO_voidSetPortValue+0x74>
		case PORTA_ID: PORTA_REG = Copy_u8PortVal;
    27da:	eb e3       	ldi	r30, 0x3B	; 59
    27dc:	f0 e0       	ldi	r31, 0x00	; 0
    27de:	8a 81       	ldd	r24, Y+2	; 0x02
    27e0:	80 83       	st	Z, r24
    27e2:	0e c0       	rjmp	.+28     	; 0x2800 <DIO_voidSetPortValue+0x74>
		break;
		case PORTB_ID: PORTB_REG = Copy_u8PortVal;
    27e4:	e8 e3       	ldi	r30, 0x38	; 56
    27e6:	f0 e0       	ldi	r31, 0x00	; 0
    27e8:	8a 81       	ldd	r24, Y+2	; 0x02
    27ea:	80 83       	st	Z, r24
    27ec:	09 c0       	rjmp	.+18     	; 0x2800 <DIO_voidSetPortValue+0x74>
		break;
		case PORTC_ID: PORTC_REG = Copy_u8PortVal;
    27ee:	e5 e3       	ldi	r30, 0x35	; 53
    27f0:	f0 e0       	ldi	r31, 0x00	; 0
    27f2:	8a 81       	ldd	r24, Y+2	; 0x02
    27f4:	80 83       	st	Z, r24
    27f6:	04 c0       	rjmp	.+8      	; 0x2800 <DIO_voidSetPortValue+0x74>
		break;
		case PORTD_ID: PORTD_REG = Copy_u8PortVal;
    27f8:	e2 e3       	ldi	r30, 0x32	; 50
    27fa:	f0 e0       	ldi	r31, 0x00	; 0
    27fc:	8a 81       	ldd	r24, Y+2	; 0x02
    27fe:	80 83       	st	Z, r24
		break;
	}

}
    2800:	0f 90       	pop	r0
    2802:	0f 90       	pop	r0
    2804:	0f 90       	pop	r0
    2806:	0f 90       	pop	r0
    2808:	cf 91       	pop	r28
    280a:	df 91       	pop	r29
    280c:	08 95       	ret

0000280e <DIO_voidGetPinValue>:

DIO_PIN_VAL_TYPE DIO_voidGetPinValue(DIO_PORT_TYPE Copy_u8PortID , DIO_PIN_TYPE Copy_u8PinID){
    280e:	df 93       	push	r29
    2810:	cf 93       	push	r28
    2812:	00 d0       	rcall	.+0      	; 0x2814 <DIO_voidGetPinValue+0x6>
    2814:	00 d0       	rcall	.+0      	; 0x2816 <DIO_voidGetPinValue+0x8>
    2816:	0f 92       	push	r0
    2818:	cd b7       	in	r28, 0x3d	; 61
    281a:	de b7       	in	r29, 0x3e	; 62
    281c:	89 83       	std	Y+1, r24	; 0x01
    281e:	6a 83       	std	Y+2, r22	; 0x02

	switch(Copy_u8PortID){
    2820:	89 81       	ldd	r24, Y+1	; 0x01
    2822:	28 2f       	mov	r18, r24
    2824:	30 e0       	ldi	r19, 0x00	; 0
    2826:	3d 83       	std	Y+5, r19	; 0x05
    2828:	2c 83       	std	Y+4, r18	; 0x04
    282a:	4c 81       	ldd	r20, Y+4	; 0x04
    282c:	5d 81       	ldd	r21, Y+5	; 0x05
    282e:	41 30       	cpi	r20, 0x01	; 1
    2830:	51 05       	cpc	r21, r1
    2832:	49 f1       	breq	.+82     	; 0x2886 <DIO_voidGetPinValue+0x78>
    2834:	8c 81       	ldd	r24, Y+4	; 0x04
    2836:	9d 81       	ldd	r25, Y+5	; 0x05
    2838:	82 30       	cpi	r24, 0x02	; 2
    283a:	91 05       	cpc	r25, r1
    283c:	34 f4       	brge	.+12     	; 0x284a <DIO_voidGetPinValue+0x3c>
    283e:	2c 81       	ldd	r18, Y+4	; 0x04
    2840:	3d 81       	ldd	r19, Y+5	; 0x05
    2842:	21 15       	cp	r18, r1
    2844:	31 05       	cpc	r19, r1
    2846:	61 f0       	breq	.+24     	; 0x2860 <DIO_voidGetPinValue+0x52>
    2848:	57 c0       	rjmp	.+174    	; 0x28f8 <DIO_voidGetPinValue+0xea>
    284a:	4c 81       	ldd	r20, Y+4	; 0x04
    284c:	5d 81       	ldd	r21, Y+5	; 0x05
    284e:	42 30       	cpi	r20, 0x02	; 2
    2850:	51 05       	cpc	r21, r1
    2852:	61 f1       	breq	.+88     	; 0x28ac <DIO_voidGetPinValue+0x9e>
    2854:	8c 81       	ldd	r24, Y+4	; 0x04
    2856:	9d 81       	ldd	r25, Y+5	; 0x05
    2858:	83 30       	cpi	r24, 0x03	; 3
    285a:	91 05       	cpc	r25, r1
    285c:	d1 f1       	breq	.+116    	; 0x28d2 <DIO_voidGetPinValue+0xc4>
    285e:	4c c0       	rjmp	.+152    	; 0x28f8 <DIO_voidGetPinValue+0xea>
		case PORTA_ID: return GET_BIT(PINA_REG, Copy_u8PinID);
    2860:	e9 e3       	ldi	r30, 0x39	; 57
    2862:	f0 e0       	ldi	r31, 0x00	; 0
    2864:	80 81       	ld	r24, Z
    2866:	28 2f       	mov	r18, r24
    2868:	30 e0       	ldi	r19, 0x00	; 0
    286a:	8a 81       	ldd	r24, Y+2	; 0x02
    286c:	88 2f       	mov	r24, r24
    286e:	90 e0       	ldi	r25, 0x00	; 0
    2870:	a9 01       	movw	r20, r18
    2872:	02 c0       	rjmp	.+4      	; 0x2878 <DIO_voidGetPinValue+0x6a>
    2874:	55 95       	asr	r21
    2876:	47 95       	ror	r20
    2878:	8a 95       	dec	r24
    287a:	e2 f7       	brpl	.-8      	; 0x2874 <DIO_voidGetPinValue+0x66>
    287c:	ca 01       	movw	r24, r20
    287e:	58 2f       	mov	r21, r24
    2880:	51 70       	andi	r21, 0x01	; 1
    2882:	5b 83       	std	Y+3, r21	; 0x03
    2884:	3a c0       	rjmp	.+116    	; 0x28fa <DIO_voidGetPinValue+0xec>
		break;
		case PORTB_ID: return GET_BIT(PINB_REG, Copy_u8PinID);
    2886:	e6 e3       	ldi	r30, 0x36	; 54
    2888:	f0 e0       	ldi	r31, 0x00	; 0
    288a:	80 81       	ld	r24, Z
    288c:	28 2f       	mov	r18, r24
    288e:	30 e0       	ldi	r19, 0x00	; 0
    2890:	8a 81       	ldd	r24, Y+2	; 0x02
    2892:	88 2f       	mov	r24, r24
    2894:	90 e0       	ldi	r25, 0x00	; 0
    2896:	a9 01       	movw	r20, r18
    2898:	02 c0       	rjmp	.+4      	; 0x289e <DIO_voidGetPinValue+0x90>
    289a:	55 95       	asr	r21
    289c:	47 95       	ror	r20
    289e:	8a 95       	dec	r24
    28a0:	e2 f7       	brpl	.-8      	; 0x289a <DIO_voidGetPinValue+0x8c>
    28a2:	ca 01       	movw	r24, r20
    28a4:	58 2f       	mov	r21, r24
    28a6:	51 70       	andi	r21, 0x01	; 1
    28a8:	5b 83       	std	Y+3, r21	; 0x03
    28aa:	27 c0       	rjmp	.+78     	; 0x28fa <DIO_voidGetPinValue+0xec>
		break;
		case PORTC_ID: return GET_BIT(PINC_REG, Copy_u8PinID);
    28ac:	e3 e3       	ldi	r30, 0x33	; 51
    28ae:	f0 e0       	ldi	r31, 0x00	; 0
    28b0:	80 81       	ld	r24, Z
    28b2:	28 2f       	mov	r18, r24
    28b4:	30 e0       	ldi	r19, 0x00	; 0
    28b6:	8a 81       	ldd	r24, Y+2	; 0x02
    28b8:	88 2f       	mov	r24, r24
    28ba:	90 e0       	ldi	r25, 0x00	; 0
    28bc:	a9 01       	movw	r20, r18
    28be:	02 c0       	rjmp	.+4      	; 0x28c4 <DIO_voidGetPinValue+0xb6>
    28c0:	55 95       	asr	r21
    28c2:	47 95       	ror	r20
    28c4:	8a 95       	dec	r24
    28c6:	e2 f7       	brpl	.-8      	; 0x28c0 <DIO_voidGetPinValue+0xb2>
    28c8:	ca 01       	movw	r24, r20
    28ca:	58 2f       	mov	r21, r24
    28cc:	51 70       	andi	r21, 0x01	; 1
    28ce:	5b 83       	std	Y+3, r21	; 0x03
    28d0:	14 c0       	rjmp	.+40     	; 0x28fa <DIO_voidGetPinValue+0xec>
		break;
		case PORTD_ID: return GET_BIT(PIND_REG, Copy_u8PinID);
    28d2:	e0 e3       	ldi	r30, 0x30	; 48
    28d4:	f0 e0       	ldi	r31, 0x00	; 0
    28d6:	80 81       	ld	r24, Z
    28d8:	28 2f       	mov	r18, r24
    28da:	30 e0       	ldi	r19, 0x00	; 0
    28dc:	8a 81       	ldd	r24, Y+2	; 0x02
    28de:	88 2f       	mov	r24, r24
    28e0:	90 e0       	ldi	r25, 0x00	; 0
    28e2:	a9 01       	movw	r20, r18
    28e4:	02 c0       	rjmp	.+4      	; 0x28ea <DIO_voidGetPinValue+0xdc>
    28e6:	55 95       	asr	r21
    28e8:	47 95       	ror	r20
    28ea:	8a 95       	dec	r24
    28ec:	e2 f7       	brpl	.-8      	; 0x28e6 <DIO_voidGetPinValue+0xd8>
    28ee:	ca 01       	movw	r24, r20
    28f0:	58 2f       	mov	r21, r24
    28f2:	51 70       	andi	r21, 0x01	; 1
    28f4:	5b 83       	std	Y+3, r21	; 0x03
    28f6:	01 c0       	rjmp	.+2      	; 0x28fa <DIO_voidGetPinValue+0xec>
		break;
		default: return 0;
    28f8:	1b 82       	std	Y+3, r1	; 0x03
    28fa:	8b 81       	ldd	r24, Y+3	; 0x03
		break;
		}
}
    28fc:	0f 90       	pop	r0
    28fe:	0f 90       	pop	r0
    2900:	0f 90       	pop	r0
    2902:	0f 90       	pop	r0
    2904:	0f 90       	pop	r0
    2906:	cf 91       	pop	r28
    2908:	df 91       	pop	r29
    290a:	08 95       	ret

0000290c <DIO_voidToggelPin>:
//		case PORTD_ID: *Copy_u8PinVal = GET_BIT(PIND_REG, Copy_u8PinID);
//		break;
//		}
//}

void DIO_voidToggelPin(DIO_PORT_TYPE Copy_u8PortID, DIO_PIN_TYPE Copy_u8PinID){
    290c:	df 93       	push	r29
    290e:	cf 93       	push	r28
    2910:	00 d0       	rcall	.+0      	; 0x2912 <DIO_voidToggelPin+0x6>
    2912:	00 d0       	rcall	.+0      	; 0x2914 <DIO_voidToggelPin+0x8>
    2914:	cd b7       	in	r28, 0x3d	; 61
    2916:	de b7       	in	r29, 0x3e	; 62
    2918:	89 83       	std	Y+1, r24	; 0x01
    291a:	6a 83       	std	Y+2, r22	; 0x02

	switch(Copy_u8PortID){
    291c:	89 81       	ldd	r24, Y+1	; 0x01
    291e:	28 2f       	mov	r18, r24
    2920:	30 e0       	ldi	r19, 0x00	; 0
    2922:	3c 83       	std	Y+4, r19	; 0x04
    2924:	2b 83       	std	Y+3, r18	; 0x03
    2926:	8b 81       	ldd	r24, Y+3	; 0x03
    2928:	9c 81       	ldd	r25, Y+4	; 0x04
    292a:	81 30       	cpi	r24, 0x01	; 1
    292c:	91 05       	cpc	r25, r1
    292e:	49 f1       	breq	.+82     	; 0x2982 <DIO_voidToggelPin+0x76>
    2930:	2b 81       	ldd	r18, Y+3	; 0x03
    2932:	3c 81       	ldd	r19, Y+4	; 0x04
    2934:	22 30       	cpi	r18, 0x02	; 2
    2936:	31 05       	cpc	r19, r1
    2938:	2c f4       	brge	.+10     	; 0x2944 <DIO_voidToggelPin+0x38>
    293a:	8b 81       	ldd	r24, Y+3	; 0x03
    293c:	9c 81       	ldd	r25, Y+4	; 0x04
    293e:	00 97       	sbiw	r24, 0x00	; 0
    2940:	61 f0       	breq	.+24     	; 0x295a <DIO_voidToggelPin+0x4e>
    2942:	5a c0       	rjmp	.+180    	; 0x29f8 <DIO_voidToggelPin+0xec>
    2944:	2b 81       	ldd	r18, Y+3	; 0x03
    2946:	3c 81       	ldd	r19, Y+4	; 0x04
    2948:	22 30       	cpi	r18, 0x02	; 2
    294a:	31 05       	cpc	r19, r1
    294c:	71 f1       	breq	.+92     	; 0x29aa <DIO_voidToggelPin+0x9e>
    294e:	8b 81       	ldd	r24, Y+3	; 0x03
    2950:	9c 81       	ldd	r25, Y+4	; 0x04
    2952:	83 30       	cpi	r24, 0x03	; 3
    2954:	91 05       	cpc	r25, r1
    2956:	e9 f1       	breq	.+122    	; 0x29d2 <DIO_voidToggelPin+0xc6>
    2958:	4f c0       	rjmp	.+158    	; 0x29f8 <DIO_voidToggelPin+0xec>
		case PORTA_ID: TOG_BIT(PORTA_REG, Copy_u8PinID);
    295a:	ab e3       	ldi	r26, 0x3B	; 59
    295c:	b0 e0       	ldi	r27, 0x00	; 0
    295e:	eb e3       	ldi	r30, 0x3B	; 59
    2960:	f0 e0       	ldi	r31, 0x00	; 0
    2962:	80 81       	ld	r24, Z
    2964:	48 2f       	mov	r20, r24
    2966:	8a 81       	ldd	r24, Y+2	; 0x02
    2968:	28 2f       	mov	r18, r24
    296a:	30 e0       	ldi	r19, 0x00	; 0
    296c:	81 e0       	ldi	r24, 0x01	; 1
    296e:	90 e0       	ldi	r25, 0x00	; 0
    2970:	02 2e       	mov	r0, r18
    2972:	02 c0       	rjmp	.+4      	; 0x2978 <DIO_voidToggelPin+0x6c>
    2974:	88 0f       	add	r24, r24
    2976:	99 1f       	adc	r25, r25
    2978:	0a 94       	dec	r0
    297a:	e2 f7       	brpl	.-8      	; 0x2974 <DIO_voidToggelPin+0x68>
    297c:	84 27       	eor	r24, r20
    297e:	8c 93       	st	X, r24
    2980:	3b c0       	rjmp	.+118    	; 0x29f8 <DIO_voidToggelPin+0xec>
		break;
		case PORTB_ID: TOG_BIT(PORTB_REG, Copy_u8PinID);
    2982:	a8 e3       	ldi	r26, 0x38	; 56
    2984:	b0 e0       	ldi	r27, 0x00	; 0
    2986:	e8 e3       	ldi	r30, 0x38	; 56
    2988:	f0 e0       	ldi	r31, 0x00	; 0
    298a:	80 81       	ld	r24, Z
    298c:	48 2f       	mov	r20, r24
    298e:	8a 81       	ldd	r24, Y+2	; 0x02
    2990:	28 2f       	mov	r18, r24
    2992:	30 e0       	ldi	r19, 0x00	; 0
    2994:	81 e0       	ldi	r24, 0x01	; 1
    2996:	90 e0       	ldi	r25, 0x00	; 0
    2998:	02 2e       	mov	r0, r18
    299a:	02 c0       	rjmp	.+4      	; 0x29a0 <DIO_voidToggelPin+0x94>
    299c:	88 0f       	add	r24, r24
    299e:	99 1f       	adc	r25, r25
    29a0:	0a 94       	dec	r0
    29a2:	e2 f7       	brpl	.-8      	; 0x299c <DIO_voidToggelPin+0x90>
    29a4:	84 27       	eor	r24, r20
    29a6:	8c 93       	st	X, r24
    29a8:	27 c0       	rjmp	.+78     	; 0x29f8 <DIO_voidToggelPin+0xec>
		break;
		case PORTC_ID: TOG_BIT(PORTC_REG, Copy_u8PinID);
    29aa:	a5 e3       	ldi	r26, 0x35	; 53
    29ac:	b0 e0       	ldi	r27, 0x00	; 0
    29ae:	e5 e3       	ldi	r30, 0x35	; 53
    29b0:	f0 e0       	ldi	r31, 0x00	; 0
    29b2:	80 81       	ld	r24, Z
    29b4:	48 2f       	mov	r20, r24
    29b6:	8a 81       	ldd	r24, Y+2	; 0x02
    29b8:	28 2f       	mov	r18, r24
    29ba:	30 e0       	ldi	r19, 0x00	; 0
    29bc:	81 e0       	ldi	r24, 0x01	; 1
    29be:	90 e0       	ldi	r25, 0x00	; 0
    29c0:	02 2e       	mov	r0, r18
    29c2:	02 c0       	rjmp	.+4      	; 0x29c8 <DIO_voidToggelPin+0xbc>
    29c4:	88 0f       	add	r24, r24
    29c6:	99 1f       	adc	r25, r25
    29c8:	0a 94       	dec	r0
    29ca:	e2 f7       	brpl	.-8      	; 0x29c4 <DIO_voidToggelPin+0xb8>
    29cc:	84 27       	eor	r24, r20
    29ce:	8c 93       	st	X, r24
    29d0:	13 c0       	rjmp	.+38     	; 0x29f8 <DIO_voidToggelPin+0xec>
		break;
		case PORTD_ID: TOG_BIT(PORTD_REG, Copy_u8PinID);
    29d2:	a2 e3       	ldi	r26, 0x32	; 50
    29d4:	b0 e0       	ldi	r27, 0x00	; 0
    29d6:	e2 e3       	ldi	r30, 0x32	; 50
    29d8:	f0 e0       	ldi	r31, 0x00	; 0
    29da:	80 81       	ld	r24, Z
    29dc:	48 2f       	mov	r20, r24
    29de:	8a 81       	ldd	r24, Y+2	; 0x02
    29e0:	28 2f       	mov	r18, r24
    29e2:	30 e0       	ldi	r19, 0x00	; 0
    29e4:	81 e0       	ldi	r24, 0x01	; 1
    29e6:	90 e0       	ldi	r25, 0x00	; 0
    29e8:	02 2e       	mov	r0, r18
    29ea:	02 c0       	rjmp	.+4      	; 0x29f0 <DIO_voidToggelPin+0xe4>
    29ec:	88 0f       	add	r24, r24
    29ee:	99 1f       	adc	r25, r25
    29f0:	0a 94       	dec	r0
    29f2:	e2 f7       	brpl	.-8      	; 0x29ec <DIO_voidToggelPin+0xe0>
    29f4:	84 27       	eor	r24, r20
    29f6:	8c 93       	st	X, r24
		break;
		}

}
    29f8:	0f 90       	pop	r0
    29fa:	0f 90       	pop	r0
    29fc:	0f 90       	pop	r0
    29fe:	0f 90       	pop	r0
    2a00:	cf 91       	pop	r28
    2a02:	df 91       	pop	r29
    2a04:	08 95       	ret

00002a06 <ADC_voidInit>:
#include "ADC_Private.h"
#include "ADC_Config.h"

void(*ADC_CallBack)(void) = NULL_PTR;

void ADC_voidInit(){
    2a06:	df 93       	push	r29
    2a08:	cf 93       	push	r28
    2a0a:	cd b7       	in	r28, 0x3d	; 61
    2a0c:	de b7       	in	r29, 0x3e	; 62
	ADCSRA_REG->Bits.ADEN = STD_HIGH;
    2a0e:	e6 e2       	ldi	r30, 0x26	; 38
    2a10:	f0 e0       	ldi	r31, 0x00	; 0
    2a12:	80 81       	ld	r24, Z
    2a14:	80 68       	ori	r24, 0x80	; 128
    2a16:	80 83       	st	Z, r24
	ADMUX_REG->Bits.REFS  = REF_VOLT;
    2a18:	e7 e2       	ldi	r30, 0x27	; 39
    2a1a:	f0 e0       	ldi	r31, 0x00	; 0
    2a1c:	80 81       	ld	r24, Z
    2a1e:	8f 73       	andi	r24, 0x3F	; 63
    2a20:	80 64       	ori	r24, 0x40	; 64
    2a22:	80 83       	st	Z, r24
	ADMUX_REG->Bits.ADLAR = TYPE_DATA;
    2a24:	e7 e2       	ldi	r30, 0x27	; 39
    2a26:	f0 e0       	ldi	r31, 0x00	; 0
    2a28:	80 81       	ld	r24, Z
    2a2a:	8f 7d       	andi	r24, 0xDF	; 223
    2a2c:	80 83       	st	Z, r24
	ADCSRA_REG->Bits.ADPS = PRESCALER;
    2a2e:	e6 e2       	ldi	r30, 0x26	; 38
    2a30:	f0 e0       	ldi	r31, 0x00	; 0
    2a32:	80 81       	ld	r24, Z
    2a34:	88 7f       	andi	r24, 0xF8	; 248
    2a36:	82 60       	ori	r24, 0x02	; 2
    2a38:	80 83       	st	Z, r24
#if ADC_ENABLE_INTERRUPT == 1
	ADCSRA_REG->Bits.ADIE = STD_HIGH;
#else
	ADCSRA_REG->Bits.ADIE = STD_LOW;
    2a3a:	e6 e2       	ldi	r30, 0x26	; 38
    2a3c:	f0 e0       	ldi	r31, 0x00	; 0
    2a3e:	80 81       	ld	r24, Z
    2a40:	87 7f       	andi	r24, 0xF7	; 247
    2a42:	80 83       	st	Z, r24
#endif
}
    2a44:	cf 91       	pop	r28
    2a46:	df 91       	pop	r29
    2a48:	08 95       	ret

00002a4a <ADC_voidChannelSelect>:

void ADC_voidChannelSelect(ADC_CHANNEL_TYPE copy_u8ChannelSelect){
    2a4a:	df 93       	push	r29
    2a4c:	cf 93       	push	r28
    2a4e:	0f 92       	push	r0
    2a50:	cd b7       	in	r28, 0x3d	; 61
    2a52:	de b7       	in	r29, 0x3e	; 62
    2a54:	89 83       	std	Y+1, r24	; 0x01
	ADMUX_REG->Bits.MUX=copy_u8ChannelSelect;
    2a56:	e7 e2       	ldi	r30, 0x27	; 39
    2a58:	f0 e0       	ldi	r31, 0x00	; 0
    2a5a:	89 81       	ldd	r24, Y+1	; 0x01
    2a5c:	8f 71       	andi	r24, 0x1F	; 31
    2a5e:	98 2f       	mov	r25, r24
    2a60:	9f 71       	andi	r25, 0x1F	; 31
    2a62:	80 81       	ld	r24, Z
    2a64:	80 7e       	andi	r24, 0xE0	; 224
    2a66:	89 2b       	or	r24, r25
    2a68:	80 83       	st	Z, r24
}
    2a6a:	0f 90       	pop	r0
    2a6c:	cf 91       	pop	r28
    2a6e:	df 91       	pop	r29
    2a70:	08 95       	ret

00002a72 <ADC_voidStartConversion_Polling>:

void ADC_voidStartConversion_Polling(u16 *copy_u16Data){
    2a72:	df 93       	push	r29
    2a74:	cf 93       	push	r28
    2a76:	00 d0       	rcall	.+0      	; 0x2a78 <ADC_voidStartConversion_Polling+0x6>
    2a78:	cd b7       	in	r28, 0x3d	; 61
    2a7a:	de b7       	in	r29, 0x3e	; 62
    2a7c:	9a 83       	std	Y+2, r25	; 0x02
    2a7e:	89 83       	std	Y+1, r24	; 0x01
	/***Clear Flag***/
	ADCSRA_REG->Bits.ADIF = STD_LOW;
    2a80:	e6 e2       	ldi	r30, 0x26	; 38
    2a82:	f0 e0       	ldi	r31, 0x00	; 0
    2a84:	80 81       	ld	r24, Z
    2a86:	8f 7e       	andi	r24, 0xEF	; 239
    2a88:	80 83       	st	Z, r24
	/***Start Conversion***/
	ADCSRA_REG->Bits.ADSC = STD_HIGH;
    2a8a:	e6 e2       	ldi	r30, 0x26	; 38
    2a8c:	f0 e0       	ldi	r31, 0x00	; 0
    2a8e:	80 81       	ld	r24, Z
    2a90:	80 64       	ori	r24, 0x40	; 64
    2a92:	80 83       	st	Z, r24
	/***Wait For Flag***/
	while(ADCSRA_REG->Bits.ADIF == STD_LOW);
    2a94:	e6 e2       	ldi	r30, 0x26	; 38
    2a96:	f0 e0       	ldi	r31, 0x00	; 0
    2a98:	80 81       	ld	r24, Z
    2a9a:	80 71       	andi	r24, 0x10	; 16
    2a9c:	88 23       	and	r24, r24
    2a9e:	d1 f3       	breq	.-12     	; 0x2a94 <ADC_voidStartConversion_Polling+0x22>
	/***Reset Flag***/
	ADCSRA_REG->Bits.ADIF = STD_HIGH;
    2aa0:	e6 e2       	ldi	r30, 0x26	; 38
    2aa2:	f0 e0       	ldi	r31, 0x00	; 0
    2aa4:	80 81       	ld	r24, Z
    2aa6:	80 61       	ori	r24, 0x10	; 16
    2aa8:	80 83       	st	Z, r24
	/***Read Data***/
	*copy_u16Data = *((u16*)(ADCDATA_REG));
    2aaa:	e4 e2       	ldi	r30, 0x24	; 36
    2aac:	f0 e0       	ldi	r31, 0x00	; 0
    2aae:	80 81       	ld	r24, Z
    2ab0:	91 81       	ldd	r25, Z+1	; 0x01
    2ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ab6:	91 83       	std	Z+1, r25	; 0x01
    2ab8:	80 83       	st	Z, r24
}
    2aba:	0f 90       	pop	r0
    2abc:	0f 90       	pop	r0
    2abe:	cf 91       	pop	r28
    2ac0:	df 91       	pop	r29
    2ac2:	08 95       	ret

00002ac4 <ADC_voidStartConversion_Interrupt>:

void ADC_voidStartConversion_Interrupt(){
    2ac4:	df 93       	push	r29
    2ac6:	cf 93       	push	r28
    2ac8:	cd b7       	in	r28, 0x3d	; 61
    2aca:	de b7       	in	r29, 0x3e	; 62
	/***Clear Flag***/
	ADCSRA_REG->Bits.ADIF = STD_LOW;
    2acc:	e6 e2       	ldi	r30, 0x26	; 38
    2ace:	f0 e0       	ldi	r31, 0x00	; 0
    2ad0:	80 81       	ld	r24, Z
    2ad2:	8f 7e       	andi	r24, 0xEF	; 239
    2ad4:	80 83       	st	Z, r24
	/***Start Conversion***/
	ADCSRA_REG->Bits.ADSC = STD_HIGH;
    2ad6:	e6 e2       	ldi	r30, 0x26	; 38
    2ad8:	f0 e0       	ldi	r31, 0x00	; 0
    2ada:	80 81       	ld	r24, Z
    2adc:	80 64       	ori	r24, 0x40	; 64
    2ade:	80 83       	st	Z, r24
}
    2ae0:	cf 91       	pop	r28
    2ae2:	df 91       	pop	r29
    2ae4:	08 95       	ret

00002ae6 <ADC_voidReadData>:

void ADC_voidReadData(u16 *copy_u16Data){
    2ae6:	df 93       	push	r29
    2ae8:	cf 93       	push	r28
    2aea:	00 d0       	rcall	.+0      	; 0x2aec <ADC_voidReadData+0x6>
    2aec:	cd b7       	in	r28, 0x3d	; 61
    2aee:	de b7       	in	r29, 0x3e	; 62
    2af0:	9a 83       	std	Y+2, r25	; 0x02
    2af2:	89 83       	std	Y+1, r24	; 0x01
	/***Read Data***/
	*copy_u16Data = *((u16*)(ADCDATA_REG));
    2af4:	e4 e2       	ldi	r30, 0x24	; 36
    2af6:	f0 e0       	ldi	r31, 0x00	; 0
    2af8:	80 81       	ld	r24, Z
    2afa:	91 81       	ldd	r25, Z+1	; 0x01
    2afc:	e9 81       	ldd	r30, Y+1	; 0x01
    2afe:	fa 81       	ldd	r31, Y+2	; 0x02
    2b00:	91 83       	std	Z+1, r25	; 0x01
    2b02:	80 83       	st	Z, r24
}
    2b04:	0f 90       	pop	r0
    2b06:	0f 90       	pop	r0
    2b08:	cf 91       	pop	r28
    2b0a:	df 91       	pop	r29
    2b0c:	08 95       	ret

00002b0e <ADC_voidSetCallBack>:

void ADC_voidSetCallBack(void(*copy_ptf)(void)){
    2b0e:	df 93       	push	r29
    2b10:	cf 93       	push	r28
    2b12:	00 d0       	rcall	.+0      	; 0x2b14 <ADC_voidSetCallBack+0x6>
    2b14:	cd b7       	in	r28, 0x3d	; 61
    2b16:	de b7       	in	r29, 0x3e	; 62
    2b18:	9a 83       	std	Y+2, r25	; 0x02
    2b1a:	89 83       	std	Y+1, r24	; 0x01

	if(copy_ptf != NULL_PTR){
    2b1c:	89 81       	ldd	r24, Y+1	; 0x01
    2b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b20:	00 97       	sbiw	r24, 0x00	; 0
    2b22:	31 f0       	breq	.+12     	; 0x2b30 <ADC_voidSetCallBack+0x22>
		ADC_CallBack = copy_ptf;
    2b24:	89 81       	ldd	r24, Y+1	; 0x01
    2b26:	9a 81       	ldd	r25, Y+2	; 0x02
    2b28:	90 93 a3 01 	sts	0x01A3, r25
    2b2c:	80 93 a2 01 	sts	0x01A2, r24
	}
}
    2b30:	0f 90       	pop	r0
    2b32:	0f 90       	pop	r0
    2b34:	cf 91       	pop	r28
    2b36:	df 91       	pop	r29
    2b38:	08 95       	ret

00002b3a <__vector_16>:


void __vector_16() __attribute__((signal));
void __vector_16(){
    2b3a:	1f 92       	push	r1
    2b3c:	0f 92       	push	r0
    2b3e:	0f b6       	in	r0, 0x3f	; 63
    2b40:	0f 92       	push	r0
    2b42:	11 24       	eor	r1, r1
    2b44:	2f 93       	push	r18
    2b46:	3f 93       	push	r19
    2b48:	4f 93       	push	r20
    2b4a:	5f 93       	push	r21
    2b4c:	6f 93       	push	r22
    2b4e:	7f 93       	push	r23
    2b50:	8f 93       	push	r24
    2b52:	9f 93       	push	r25
    2b54:	af 93       	push	r26
    2b56:	bf 93       	push	r27
    2b58:	ef 93       	push	r30
    2b5a:	ff 93       	push	r31
    2b5c:	df 93       	push	r29
    2b5e:	cf 93       	push	r28
    2b60:	cd b7       	in	r28, 0x3d	; 61
    2b62:	de b7       	in	r29, 0x3e	; 62

	ADC_CallBack();
    2b64:	e0 91 a2 01 	lds	r30, 0x01A2
    2b68:	f0 91 a3 01 	lds	r31, 0x01A3
    2b6c:	09 95       	icall

}
    2b6e:	cf 91       	pop	r28
    2b70:	df 91       	pop	r29
    2b72:	ff 91       	pop	r31
    2b74:	ef 91       	pop	r30
    2b76:	bf 91       	pop	r27
    2b78:	af 91       	pop	r26
    2b7a:	9f 91       	pop	r25
    2b7c:	8f 91       	pop	r24
    2b7e:	7f 91       	pop	r23
    2b80:	6f 91       	pop	r22
    2b82:	5f 91       	pop	r21
    2b84:	4f 91       	pop	r20
    2b86:	3f 91       	pop	r19
    2b88:	2f 91       	pop	r18
    2b8a:	0f 90       	pop	r0
    2b8c:	0f be       	out	0x3f, r0	; 63
    2b8e:	0f 90       	pop	r0
    2b90:	1f 90       	pop	r1
    2b92:	18 95       	reti

00002b94 <STRNG_voidReverseString>:
#include "../BIT_MATH.h"

/***STRNG***/
#include "STRNG.h"

void STRNG_voidReverseString(u8* copy_Au8Str, u32 copy_u32StrLen){
    2b94:	df 93       	push	r29
    2b96:	cf 93       	push	r28
    2b98:	cd b7       	in	r28, 0x3d	; 61
    2b9a:	de b7       	in	r29, 0x3e	; 62
    2b9c:	2f 97       	sbiw	r28, 0x0f	; 15
    2b9e:	0f b6       	in	r0, 0x3f	; 63
    2ba0:	f8 94       	cli
    2ba2:	de bf       	out	0x3e, r29	; 62
    2ba4:	0f be       	out	0x3f, r0	; 63
    2ba6:	cd bf       	out	0x3d, r28	; 61
    2ba8:	9b 87       	std	Y+11, r25	; 0x0b
    2baa:	8a 87       	std	Y+10, r24	; 0x0a
    2bac:	4c 87       	std	Y+12, r20	; 0x0c
    2bae:	5d 87       	std	Y+13, r21	; 0x0d
    2bb0:	6e 87       	std	Y+14, r22	; 0x0e
    2bb2:	7f 87       	std	Y+15, r23	; 0x0f
	u32 i = 0;
    2bb4:	1e 82       	std	Y+6, r1	; 0x06
    2bb6:	1f 82       	std	Y+7, r1	; 0x07
    2bb8:	18 86       	std	Y+8, r1	; 0x08
    2bba:	19 86       	std	Y+9, r1	; 0x09
	u32 j = copy_u32StrLen - 1;
    2bbc:	8c 85       	ldd	r24, Y+12	; 0x0c
    2bbe:	9d 85       	ldd	r25, Y+13	; 0x0d
    2bc0:	ae 85       	ldd	r26, Y+14	; 0x0e
    2bc2:	bf 85       	ldd	r27, Y+15	; 0x0f
    2bc4:	01 97       	sbiw	r24, 0x01	; 1
    2bc6:	a1 09       	sbc	r26, r1
    2bc8:	b1 09       	sbc	r27, r1
    2bca:	8a 83       	std	Y+2, r24	; 0x02
    2bcc:	9b 83       	std	Y+3, r25	; 0x03
    2bce:	ac 83       	std	Y+4, r26	; 0x04
    2bd0:	bd 83       	std	Y+5, r27	; 0x05
    2bd2:	38 c0       	rjmp	.+112    	; 0x2c44 <STRNG_voidReverseString+0xb0>
	u8 temp;

	 while (i < j){
	        temp = copy_Au8Str[i];
    2bd4:	2e 81       	ldd	r18, Y+6	; 0x06
    2bd6:	3f 81       	ldd	r19, Y+7	; 0x07
    2bd8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bda:	9b 85       	ldd	r25, Y+11	; 0x0b
    2bdc:	fc 01       	movw	r30, r24
    2bde:	e2 0f       	add	r30, r18
    2be0:	f3 1f       	adc	r31, r19
    2be2:	80 81       	ld	r24, Z
    2be4:	89 83       	std	Y+1, r24	; 0x01
	        copy_Au8Str[i] = copy_Au8Str[j];
    2be6:	2e 81       	ldd	r18, Y+6	; 0x06
    2be8:	3f 81       	ldd	r19, Y+7	; 0x07
    2bea:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bec:	9b 85       	ldd	r25, Y+11	; 0x0b
    2bee:	dc 01       	movw	r26, r24
    2bf0:	a2 0f       	add	r26, r18
    2bf2:	b3 1f       	adc	r27, r19
    2bf4:	2a 81       	ldd	r18, Y+2	; 0x02
    2bf6:	3b 81       	ldd	r19, Y+3	; 0x03
    2bf8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bfa:	9b 85       	ldd	r25, Y+11	; 0x0b
    2bfc:	fc 01       	movw	r30, r24
    2bfe:	e2 0f       	add	r30, r18
    2c00:	f3 1f       	adc	r31, r19
    2c02:	80 81       	ld	r24, Z
    2c04:	8c 93       	st	X, r24
	        copy_Au8Str[j] = temp;
    2c06:	2a 81       	ldd	r18, Y+2	; 0x02
    2c08:	3b 81       	ldd	r19, Y+3	; 0x03
    2c0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c0e:	fc 01       	movw	r30, r24
    2c10:	e2 0f       	add	r30, r18
    2c12:	f3 1f       	adc	r31, r19
    2c14:	89 81       	ldd	r24, Y+1	; 0x01
    2c16:	80 83       	st	Z, r24
	        i++;
    2c18:	8e 81       	ldd	r24, Y+6	; 0x06
    2c1a:	9f 81       	ldd	r25, Y+7	; 0x07
    2c1c:	a8 85       	ldd	r26, Y+8	; 0x08
    2c1e:	b9 85       	ldd	r27, Y+9	; 0x09
    2c20:	01 96       	adiw	r24, 0x01	; 1
    2c22:	a1 1d       	adc	r26, r1
    2c24:	b1 1d       	adc	r27, r1
    2c26:	8e 83       	std	Y+6, r24	; 0x06
    2c28:	9f 83       	std	Y+7, r25	; 0x07
    2c2a:	a8 87       	std	Y+8, r26	; 0x08
    2c2c:	b9 87       	std	Y+9, r27	; 0x09
	        j--;
    2c2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c30:	9b 81       	ldd	r25, Y+3	; 0x03
    2c32:	ac 81       	ldd	r26, Y+4	; 0x04
    2c34:	bd 81       	ldd	r27, Y+5	; 0x05
    2c36:	01 97       	sbiw	r24, 0x01	; 1
    2c38:	a1 09       	sbc	r26, r1
    2c3a:	b1 09       	sbc	r27, r1
    2c3c:	8a 83       	std	Y+2, r24	; 0x02
    2c3e:	9b 83       	std	Y+3, r25	; 0x03
    2c40:	ac 83       	std	Y+4, r26	; 0x04
    2c42:	bd 83       	std	Y+5, r27	; 0x05
void STRNG_voidReverseString(u8* copy_Au8Str, u32 copy_u32StrLen){
	u32 i = 0;
	u32 j = copy_u32StrLen - 1;
	u8 temp;

	 while (i < j){
    2c44:	2e 81       	ldd	r18, Y+6	; 0x06
    2c46:	3f 81       	ldd	r19, Y+7	; 0x07
    2c48:	48 85       	ldd	r20, Y+8	; 0x08
    2c4a:	59 85       	ldd	r21, Y+9	; 0x09
    2c4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c4e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c50:	ac 81       	ldd	r26, Y+4	; 0x04
    2c52:	bd 81       	ldd	r27, Y+5	; 0x05
    2c54:	28 17       	cp	r18, r24
    2c56:	39 07       	cpc	r19, r25
    2c58:	4a 07       	cpc	r20, r26
    2c5a:	5b 07       	cpc	r21, r27
    2c5c:	08 f4       	brcc	.+2      	; 0x2c60 <STRNG_voidReverseString+0xcc>
    2c5e:	ba cf       	rjmp	.-140    	; 0x2bd4 <STRNG_voidReverseString+0x40>
	        copy_Au8Str[i] = copy_Au8Str[j];
	        copy_Au8Str[j] = temp;
	        i++;
	        j--;
	    }
}
    2c60:	2f 96       	adiw	r28, 0x0f	; 15
    2c62:	0f b6       	in	r0, 0x3f	; 63
    2c64:	f8 94       	cli
    2c66:	de bf       	out	0x3e, r29	; 62
    2c68:	0f be       	out	0x3f, r0	; 63
    2c6a:	cd bf       	out	0x3d, r28	; 61
    2c6c:	cf 91       	pop	r28
    2c6e:	df 91       	pop	r29
    2c70:	08 95       	ret

00002c72 <STRNG_IntToString>:

u32 STRNG_IntToString(u32 copy_u8IntNumber, u8* copy_Au8Str){
    2c72:	0f 93       	push	r16
    2c74:	1f 93       	push	r17
    2c76:	df 93       	push	r29
    2c78:	cf 93       	push	r28
    2c7a:	cd b7       	in	r28, 0x3d	; 61
    2c7c:	de b7       	in	r29, 0x3e	; 62
    2c7e:	2a 97       	sbiw	r28, 0x0a	; 10
    2c80:	0f b6       	in	r0, 0x3f	; 63
    2c82:	f8 94       	cli
    2c84:	de bf       	out	0x3e, r29	; 62
    2c86:	0f be       	out	0x3f, r0	; 63
    2c88:	cd bf       	out	0x3d, r28	; 61
    2c8a:	6d 83       	std	Y+5, r22	; 0x05
    2c8c:	7e 83       	std	Y+6, r23	; 0x06
    2c8e:	8f 83       	std	Y+7, r24	; 0x07
    2c90:	98 87       	std	Y+8, r25	; 0x08
    2c92:	5a 87       	std	Y+10, r21	; 0x0a
    2c94:	49 87       	std	Y+9, r20	; 0x09
	u32 i = 0;
    2c96:	19 82       	std	Y+1, r1	; 0x01
    2c98:	1a 82       	std	Y+2, r1	; 0x02
    2c9a:	1b 82       	std	Y+3, r1	; 0x03
    2c9c:	1c 82       	std	Y+4, r1	; 0x04
    2c9e:	35 c0       	rjmp	.+106    	; 0x2d0a <STRNG_IntToString+0x98>
	while(copy_u8IntNumber){
		copy_Au8Str[i++] = copy_u8IntNumber%10 + '0';
    2ca0:	29 81       	ldd	r18, Y+1	; 0x01
    2ca2:	3a 81       	ldd	r19, Y+2	; 0x02
    2ca4:	89 85       	ldd	r24, Y+9	; 0x09
    2ca6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ca8:	8c 01       	movw	r16, r24
    2caa:	02 0f       	add	r16, r18
    2cac:	13 1f       	adc	r17, r19
    2cae:	8d 81       	ldd	r24, Y+5	; 0x05
    2cb0:	9e 81       	ldd	r25, Y+6	; 0x06
    2cb2:	af 81       	ldd	r26, Y+7	; 0x07
    2cb4:	b8 85       	ldd	r27, Y+8	; 0x08
    2cb6:	2a e0       	ldi	r18, 0x0A	; 10
    2cb8:	30 e0       	ldi	r19, 0x00	; 0
    2cba:	40 e0       	ldi	r20, 0x00	; 0
    2cbc:	50 e0       	ldi	r21, 0x00	; 0
    2cbe:	bc 01       	movw	r22, r24
    2cc0:	cd 01       	movw	r24, r26
    2cc2:	0e 94 bf 3a 	call	0x757e	; 0x757e <__udivmodsi4>
    2cc6:	dc 01       	movw	r26, r24
    2cc8:	cb 01       	movw	r24, r22
    2cca:	80 5d       	subi	r24, 0xD0	; 208
    2ccc:	f8 01       	movw	r30, r16
    2cce:	80 83       	st	Z, r24
    2cd0:	89 81       	ldd	r24, Y+1	; 0x01
    2cd2:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd4:	ab 81       	ldd	r26, Y+3	; 0x03
    2cd6:	bc 81       	ldd	r27, Y+4	; 0x04
    2cd8:	01 96       	adiw	r24, 0x01	; 1
    2cda:	a1 1d       	adc	r26, r1
    2cdc:	b1 1d       	adc	r27, r1
    2cde:	89 83       	std	Y+1, r24	; 0x01
    2ce0:	9a 83       	std	Y+2, r25	; 0x02
    2ce2:	ab 83       	std	Y+3, r26	; 0x03
    2ce4:	bc 83       	std	Y+4, r27	; 0x04
		copy_u8IntNumber/=10;
    2ce6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ce8:	9e 81       	ldd	r25, Y+6	; 0x06
    2cea:	af 81       	ldd	r26, Y+7	; 0x07
    2cec:	b8 85       	ldd	r27, Y+8	; 0x08
    2cee:	2a e0       	ldi	r18, 0x0A	; 10
    2cf0:	30 e0       	ldi	r19, 0x00	; 0
    2cf2:	40 e0       	ldi	r20, 0x00	; 0
    2cf4:	50 e0       	ldi	r21, 0x00	; 0
    2cf6:	bc 01       	movw	r22, r24
    2cf8:	cd 01       	movw	r24, r26
    2cfa:	0e 94 bf 3a 	call	0x757e	; 0x757e <__udivmodsi4>
    2cfe:	da 01       	movw	r26, r20
    2d00:	c9 01       	movw	r24, r18
    2d02:	8d 83       	std	Y+5, r24	; 0x05
    2d04:	9e 83       	std	Y+6, r25	; 0x06
    2d06:	af 83       	std	Y+7, r26	; 0x07
    2d08:	b8 87       	std	Y+8, r27	; 0x08
	    }
}

u32 STRNG_IntToString(u32 copy_u8IntNumber, u8* copy_Au8Str){
	u32 i = 0;
	while(copy_u8IntNumber){
    2d0a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d0c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d0e:	af 81       	ldd	r26, Y+7	; 0x07
    2d10:	b8 85       	ldd	r27, Y+8	; 0x08
    2d12:	00 97       	sbiw	r24, 0x00	; 0
    2d14:	a1 05       	cpc	r26, r1
    2d16:	b1 05       	cpc	r27, r1
    2d18:	19 f6       	brne	.-122    	; 0x2ca0 <STRNG_IntToString+0x2e>
		copy_Au8Str[i++] = copy_u8IntNumber%10 + '0';
		copy_u8IntNumber/=10;
	}

	STRNG_voidReverseString(copy_Au8Str, i);
    2d1a:	89 85       	ldd	r24, Y+9	; 0x09
    2d1c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d1e:	29 81       	ldd	r18, Y+1	; 0x01
    2d20:	3a 81       	ldd	r19, Y+2	; 0x02
    2d22:	4b 81       	ldd	r20, Y+3	; 0x03
    2d24:	5c 81       	ldd	r21, Y+4	; 0x04
    2d26:	ba 01       	movw	r22, r20
    2d28:	a9 01       	movw	r20, r18
    2d2a:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <STRNG_voidReverseString>
	copy_Au8Str[i] = '\0';
    2d2e:	29 81       	ldd	r18, Y+1	; 0x01
    2d30:	3a 81       	ldd	r19, Y+2	; 0x02
    2d32:	89 85       	ldd	r24, Y+9	; 0x09
    2d34:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d36:	fc 01       	movw	r30, r24
    2d38:	e2 0f       	add	r30, r18
    2d3a:	f3 1f       	adc	r31, r19
    2d3c:	10 82       	st	Z, r1
	return i;
    2d3e:	89 81       	ldd	r24, Y+1	; 0x01
    2d40:	9a 81       	ldd	r25, Y+2	; 0x02
    2d42:	ab 81       	ldd	r26, Y+3	; 0x03
    2d44:	bc 81       	ldd	r27, Y+4	; 0x04
}
    2d46:	bc 01       	movw	r22, r24
    2d48:	cd 01       	movw	r24, r26
    2d4a:	2a 96       	adiw	r28, 0x0a	; 10
    2d4c:	0f b6       	in	r0, 0x3f	; 63
    2d4e:	f8 94       	cli
    2d50:	de bf       	out	0x3e, r29	; 62
    2d52:	0f be       	out	0x3f, r0	; 63
    2d54:	cd bf       	out	0x3d, r28	; 61
    2d56:	cf 91       	pop	r28
    2d58:	df 91       	pop	r29
    2d5a:	1f 91       	pop	r17
    2d5c:	0f 91       	pop	r16
    2d5e:	08 95       	ret

00002d60 <STRNG_FloatToString>:

void STRNG_FloatToString(f64 copy_f64floatNumber, u8* copy_Au8Str){
    2d60:	af 92       	push	r10
    2d62:	bf 92       	push	r11
    2d64:	cf 92       	push	r12
    2d66:	df 92       	push	r13
    2d68:	ef 92       	push	r14
    2d6a:	ff 92       	push	r15
    2d6c:	0f 93       	push	r16
    2d6e:	1f 93       	push	r17
    2d70:	df 93       	push	r29
    2d72:	cf 93       	push	r28
    2d74:	cd b7       	in	r28, 0x3d	; 61
    2d76:	de b7       	in	r29, 0x3e	; 62
    2d78:	66 97       	sbiw	r28, 0x16	; 22
    2d7a:	0f b6       	in	r0, 0x3f	; 63
    2d7c:	f8 94       	cli
    2d7e:	de bf       	out	0x3e, r29	; 62
    2d80:	0f be       	out	0x3f, r0	; 63
    2d82:	cd bf       	out	0x3d, r28	; 61
    2d84:	69 8b       	std	Y+17, r22	; 0x11
    2d86:	7a 8b       	std	Y+18, r23	; 0x12
    2d88:	8b 8b       	std	Y+19, r24	; 0x13
    2d8a:	9c 8b       	std	Y+20, r25	; 0x14
    2d8c:	5e 8b       	std	Y+22, r21	; 0x16
    2d8e:	4d 8b       	std	Y+21, r20	; 0x15
	/*Extract Integer Part*/
	u32 local_u32IntPart = (u32)copy_f64floatNumber;
    2d90:	69 89       	ldd	r22, Y+17	; 0x11
    2d92:	7a 89       	ldd	r23, Y+18	; 0x12
    2d94:	8b 89       	ldd	r24, Y+19	; 0x13
    2d96:	9c 89       	ldd	r25, Y+20	; 0x14
    2d98:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2d9c:	dc 01       	movw	r26, r24
    2d9e:	cb 01       	movw	r24, r22
    2da0:	8d 87       	std	Y+13, r24	; 0x0d
    2da2:	9e 87       	std	Y+14, r25	; 0x0e
    2da4:	af 87       	std	Y+15, r26	; 0x0f
    2da6:	b8 8b       	std	Y+16, r27	; 0x10
	/*Extract float Part*/
	u64 local_u64FloatPart = 100*(copy_f64floatNumber - (u64)local_u32IntPart);
    2da8:	6d 85       	ldd	r22, Y+13	; 0x0d
    2daa:	7e 85       	ldd	r23, Y+14	; 0x0e
    2dac:	8f 85       	ldd	r24, Y+15	; 0x0f
    2dae:	98 89       	ldd	r25, Y+16	; 0x10
    2db0:	0e 94 51 05 	call	0xaa2	; 0xaa2 <__floatunsisf>
    2db4:	9b 01       	movw	r18, r22
    2db6:	ac 01       	movw	r20, r24
    2db8:	69 89       	ldd	r22, Y+17	; 0x11
    2dba:	7a 89       	ldd	r23, Y+18	; 0x12
    2dbc:	8b 89       	ldd	r24, Y+19	; 0x13
    2dbe:	9c 89       	ldd	r25, Y+20	; 0x14
    2dc0:	0e 94 69 02 	call	0x4d2	; 0x4d2 <__subsf3>
    2dc4:	dc 01       	movw	r26, r24
    2dc6:	cb 01       	movw	r24, r22
    2dc8:	bc 01       	movw	r22, r24
    2dca:	cd 01       	movw	r24, r26
    2dcc:	20 e0       	ldi	r18, 0x00	; 0
    2dce:	30 e0       	ldi	r19, 0x00	; 0
    2dd0:	48 ec       	ldi	r20, 0xC8	; 200
    2dd2:	52 e4       	ldi	r21, 0x42	; 66
    2dd4:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    2dd8:	dc 01       	movw	r26, r24
    2dda:	cb 01       	movw	r24, r22
    2ddc:	bc 01       	movw	r22, r24
    2dde:	cd 01       	movw	r24, r26
    2de0:	0e 94 75 00 	call	0xea	; 0xea <__fixunssfdi>
    2de4:	a2 2e       	mov	r10, r18
    2de6:	b3 2e       	mov	r11, r19
    2de8:	c4 2e       	mov	r12, r20
    2dea:	d5 2e       	mov	r13, r21
    2dec:	e6 2e       	mov	r14, r22
    2dee:	f7 2e       	mov	r15, r23
    2df0:	08 2f       	mov	r16, r24
    2df2:	19 2f       	mov	r17, r25
    2df4:	ad 82       	std	Y+5, r10	; 0x05
    2df6:	be 82       	std	Y+6, r11	; 0x06
    2df8:	cf 82       	std	Y+7, r12	; 0x07
    2dfa:	d8 86       	std	Y+8, r13	; 0x08
    2dfc:	e9 86       	std	Y+9, r14	; 0x09
    2dfe:	fa 86       	std	Y+10, r15	; 0x0a
    2e00:	0b 87       	std	Y+11, r16	; 0x0b
    2e02:	1c 87       	std	Y+12, r17	; 0x0c
	/*Convert integer part to string*/
	u32 i = STRNG_IntToString(local_u32IntPart, copy_Au8Str);
    2e04:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e06:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e08:	af 85       	ldd	r26, Y+15	; 0x0f
    2e0a:	b8 89       	ldd	r27, Y+16	; 0x10
    2e0c:	2d 89       	ldd	r18, Y+21	; 0x15
    2e0e:	3e 89       	ldd	r19, Y+22	; 0x16
    2e10:	bc 01       	movw	r22, r24
    2e12:	cd 01       	movw	r24, r26
    2e14:	a9 01       	movw	r20, r18
    2e16:	0e 94 39 16 	call	0x2c72	; 0x2c72 <STRNG_IntToString>
    2e1a:	dc 01       	movw	r26, r24
    2e1c:	cb 01       	movw	r24, r22
    2e1e:	89 83       	std	Y+1, r24	; 0x01
    2e20:	9a 83       	std	Y+2, r25	; 0x02
    2e22:	ab 83       	std	Y+3, r26	; 0x03
    2e24:	bc 83       	std	Y+4, r27	; 0x04
	/* Add a Dot */
	copy_Au8Str[i]='.';
    2e26:	29 81       	ldd	r18, Y+1	; 0x01
    2e28:	3a 81       	ldd	r19, Y+2	; 0x02
    2e2a:	8d 89       	ldd	r24, Y+21	; 0x15
    2e2c:	9e 89       	ldd	r25, Y+22	; 0x16
    2e2e:	fc 01       	movw	r30, r24
    2e30:	e2 0f       	add	r30, r18
    2e32:	f3 1f       	adc	r31, r19
    2e34:	8e e2       	ldi	r24, 0x2E	; 46
    2e36:	80 83       	st	Z, r24
	/*Convert float Part*/
	STRNG_IntToString((u32)local_u64FloatPart, copy_Au8Str+i+1);
    2e38:	4d 81       	ldd	r20, Y+5	; 0x05
    2e3a:	5e 81       	ldd	r21, Y+6	; 0x06
    2e3c:	6f 81       	ldd	r22, Y+7	; 0x07
    2e3e:	78 85       	ldd	r23, Y+8	; 0x08
    2e40:	89 81       	ldd	r24, Y+1	; 0x01
    2e42:	9a 81       	ldd	r25, Y+2	; 0x02
    2e44:	9c 01       	movw	r18, r24
    2e46:	2f 5f       	subi	r18, 0xFF	; 255
    2e48:	3f 4f       	sbci	r19, 0xFF	; 255
    2e4a:	8d 89       	ldd	r24, Y+21	; 0x15
    2e4c:	9e 89       	ldd	r25, Y+22	; 0x16
    2e4e:	28 0f       	add	r18, r24
    2e50:	39 1f       	adc	r19, r25
    2e52:	cb 01       	movw	r24, r22
    2e54:	ba 01       	movw	r22, r20
    2e56:	a9 01       	movw	r20, r18
    2e58:	0e 94 39 16 	call	0x2c72	; 0x2c72 <STRNG_IntToString>
}
    2e5c:	66 96       	adiw	r28, 0x16	; 22
    2e5e:	0f b6       	in	r0, 0x3f	; 63
    2e60:	f8 94       	cli
    2e62:	de bf       	out	0x3e, r29	; 62
    2e64:	0f be       	out	0x3f, r0	; 63
    2e66:	cd bf       	out	0x3d, r28	; 61
    2e68:	cf 91       	pop	r28
    2e6a:	df 91       	pop	r29
    2e6c:	1f 91       	pop	r17
    2e6e:	0f 91       	pop	r16
    2e70:	ff 90       	pop	r15
    2e72:	ef 90       	pop	r14
    2e74:	df 90       	pop	r13
    2e76:	cf 90       	pop	r12
    2e78:	bf 90       	pop	r11
    2e7a:	af 90       	pop	r10
    2e7c:	08 95       	ret

00002e7e <voidPrintNumOnSSD>:
#include "SSD_Interface.h"
#include "SSD_Private.h"
#include "SSD_Config.h"


static void voidPrintNumOnSSD(u8 copy_u8Num){
    2e7e:	df 93       	push	r29
    2e80:	cf 93       	push	r28
    2e82:	00 d0       	rcall	.+0      	; 0x2e84 <voidPrintNumOnSSD+0x6>
    2e84:	0f 92       	push	r0
    2e86:	cd b7       	in	r28, 0x3d	; 61
    2e88:	de b7       	in	r29, 0x3e	; 62
    2e8a:	89 83       	std	Y+1, r24	; 0x01
	switch(copy_u8Num){
    2e8c:	89 81       	ldd	r24, Y+1	; 0x01
    2e8e:	28 2f       	mov	r18, r24
    2e90:	30 e0       	ldi	r19, 0x00	; 0
    2e92:	3b 83       	std	Y+3, r19	; 0x03
    2e94:	2a 83       	std	Y+2, r18	; 0x02
    2e96:	8a 81       	ldd	r24, Y+2	; 0x02
    2e98:	9b 81       	ldd	r25, Y+3	; 0x03
    2e9a:	84 30       	cpi	r24, 0x04	; 4
    2e9c:	91 05       	cpc	r25, r1
    2e9e:	09 f4       	brne	.+2      	; 0x2ea2 <voidPrintNumOnSSD+0x24>
    2ea0:	9b c0       	rjmp	.+310    	; 0x2fd8 <voidPrintNumOnSSD+0x15a>
    2ea2:	2a 81       	ldd	r18, Y+2	; 0x02
    2ea4:	3b 81       	ldd	r19, Y+3	; 0x03
    2ea6:	25 30       	cpi	r18, 0x05	; 5
    2ea8:	31 05       	cpc	r19, r1
    2eaa:	ec f4       	brge	.+58     	; 0x2ee6 <voidPrintNumOnSSD+0x68>
    2eac:	8a 81       	ldd	r24, Y+2	; 0x02
    2eae:	9b 81       	ldd	r25, Y+3	; 0x03
    2eb0:	81 30       	cpi	r24, 0x01	; 1
    2eb2:	91 05       	cpc	r25, r1
    2eb4:	09 f4       	brne	.+2      	; 0x2eb8 <voidPrintNumOnSSD+0x3a>
    2eb6:	51 c0       	rjmp	.+162    	; 0x2f5a <voidPrintNumOnSSD+0xdc>
    2eb8:	2a 81       	ldd	r18, Y+2	; 0x02
    2eba:	3b 81       	ldd	r19, Y+3	; 0x03
    2ebc:	22 30       	cpi	r18, 0x02	; 2
    2ebe:	31 05       	cpc	r19, r1
    2ec0:	2c f4       	brge	.+10     	; 0x2ecc <voidPrintNumOnSSD+0x4e>
    2ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ec6:	00 97       	sbiw	r24, 0x00	; 0
    2ec8:	99 f1       	breq	.+102    	; 0x2f30 <voidPrintNumOnSSD+0xb2>
    2eca:	03 c1       	rjmp	.+518    	; 0x30d2 <voidPrintNumOnSSD+0x254>
    2ecc:	2a 81       	ldd	r18, Y+2	; 0x02
    2ece:	3b 81       	ldd	r19, Y+3	; 0x03
    2ed0:	22 30       	cpi	r18, 0x02	; 2
    2ed2:	31 05       	cpc	r19, r1
    2ed4:	09 f4       	brne	.+2      	; 0x2ed8 <voidPrintNumOnSSD+0x5a>
    2ed6:	56 c0       	rjmp	.+172    	; 0x2f84 <voidPrintNumOnSSD+0x106>
    2ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eda:	9b 81       	ldd	r25, Y+3	; 0x03
    2edc:	83 30       	cpi	r24, 0x03	; 3
    2ede:	91 05       	cpc	r25, r1
    2ee0:	09 f4       	brne	.+2      	; 0x2ee4 <voidPrintNumOnSSD+0x66>
    2ee2:	65 c0       	rjmp	.+202    	; 0x2fae <voidPrintNumOnSSD+0x130>
    2ee4:	f6 c0       	rjmp	.+492    	; 0x30d2 <voidPrintNumOnSSD+0x254>
    2ee6:	2a 81       	ldd	r18, Y+2	; 0x02
    2ee8:	3b 81       	ldd	r19, Y+3	; 0x03
    2eea:	27 30       	cpi	r18, 0x07	; 7
    2eec:	31 05       	cpc	r19, r1
    2eee:	09 f4       	brne	.+2      	; 0x2ef2 <voidPrintNumOnSSD+0x74>
    2ef0:	b2 c0       	rjmp	.+356    	; 0x3056 <voidPrintNumOnSSD+0x1d8>
    2ef2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ef4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ef6:	88 30       	cpi	r24, 0x08	; 8
    2ef8:	91 05       	cpc	r25, r1
    2efa:	6c f4       	brge	.+26     	; 0x2f16 <voidPrintNumOnSSD+0x98>
    2efc:	2a 81       	ldd	r18, Y+2	; 0x02
    2efe:	3b 81       	ldd	r19, Y+3	; 0x03
    2f00:	25 30       	cpi	r18, 0x05	; 5
    2f02:	31 05       	cpc	r19, r1
    2f04:	09 f4       	brne	.+2      	; 0x2f08 <voidPrintNumOnSSD+0x8a>
    2f06:	7d c0       	rjmp	.+250    	; 0x3002 <voidPrintNumOnSSD+0x184>
    2f08:	8a 81       	ldd	r24, Y+2	; 0x02
    2f0a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f0c:	86 30       	cpi	r24, 0x06	; 6
    2f0e:	91 05       	cpc	r25, r1
    2f10:	09 f4       	brne	.+2      	; 0x2f14 <voidPrintNumOnSSD+0x96>
    2f12:	8c c0       	rjmp	.+280    	; 0x302c <voidPrintNumOnSSD+0x1ae>
    2f14:	de c0       	rjmp	.+444    	; 0x30d2 <voidPrintNumOnSSD+0x254>
    2f16:	2a 81       	ldd	r18, Y+2	; 0x02
    2f18:	3b 81       	ldd	r19, Y+3	; 0x03
    2f1a:	28 30       	cpi	r18, 0x08	; 8
    2f1c:	31 05       	cpc	r19, r1
    2f1e:	09 f4       	brne	.+2      	; 0x2f22 <voidPrintNumOnSSD+0xa4>
    2f20:	af c0       	rjmp	.+350    	; 0x3080 <voidPrintNumOnSSD+0x202>
    2f22:	8a 81       	ldd	r24, Y+2	; 0x02
    2f24:	9b 81       	ldd	r25, Y+3	; 0x03
    2f26:	89 30       	cpi	r24, 0x09	; 9
    2f28:	91 05       	cpc	r25, r1
    2f2a:	09 f4       	brne	.+2      	; 0x2f2e <voidPrintNumOnSSD+0xb0>
    2f2c:	be c0       	rjmp	.+380    	; 0x30aa <voidPrintNumOnSSD+0x22c>
    2f2e:	d1 c0       	rjmp	.+418    	; 0x30d2 <voidPrintNumOnSSD+0x254>
	case 0:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_LOW);
    2f30:	81 e0       	ldi	r24, 0x01	; 1
    2f32:	64 e0       	ldi	r22, 0x04	; 4
    2f34:	40 e0       	ldi	r20, 0x00	; 0
    2f36:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_LOW);
    2f3a:	81 e0       	ldi	r24, 0x01	; 1
    2f3c:	62 e0       	ldi	r22, 0x02	; 2
    2f3e:	40 e0       	ldi	r20, 0x00	; 0
    2f40:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_LOW);
    2f44:	81 e0       	ldi	r24, 0x01	; 1
    2f46:	61 e0       	ldi	r22, 0x01	; 1
    2f48:	40 e0       	ldi	r20, 0x00	; 0
    2f4a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_LOW);
    2f4e:	81 e0       	ldi	r24, 0x01	; 1
    2f50:	60 e0       	ldi	r22, 0x00	; 0
    2f52:	40 e0       	ldi	r20, 0x00	; 0
    2f54:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    2f58:	bc c0       	rjmp	.+376    	; 0x30d2 <voidPrintNumOnSSD+0x254>
		break;
	case 1:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_LOW);
    2f5a:	81 e0       	ldi	r24, 0x01	; 1
    2f5c:	64 e0       	ldi	r22, 0x04	; 4
    2f5e:	40 e0       	ldi	r20, 0x00	; 0
    2f60:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_LOW);
    2f64:	81 e0       	ldi	r24, 0x01	; 1
    2f66:	62 e0       	ldi	r22, 0x02	; 2
    2f68:	40 e0       	ldi	r20, 0x00	; 0
    2f6a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_LOW);
    2f6e:	81 e0       	ldi	r24, 0x01	; 1
    2f70:	61 e0       	ldi	r22, 0x01	; 1
    2f72:	40 e0       	ldi	r20, 0x00	; 0
    2f74:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_HIGH);
    2f78:	81 e0       	ldi	r24, 0x01	; 1
    2f7a:	60 e0       	ldi	r22, 0x00	; 0
    2f7c:	41 e0       	ldi	r20, 0x01	; 1
    2f7e:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    2f82:	a7 c0       	rjmp	.+334    	; 0x30d2 <voidPrintNumOnSSD+0x254>
		break;
	case 2:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_LOW);
    2f84:	81 e0       	ldi	r24, 0x01	; 1
    2f86:	64 e0       	ldi	r22, 0x04	; 4
    2f88:	40 e0       	ldi	r20, 0x00	; 0
    2f8a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_LOW);
    2f8e:	81 e0       	ldi	r24, 0x01	; 1
    2f90:	62 e0       	ldi	r22, 0x02	; 2
    2f92:	40 e0       	ldi	r20, 0x00	; 0
    2f94:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_HIGH);
    2f98:	81 e0       	ldi	r24, 0x01	; 1
    2f9a:	61 e0       	ldi	r22, 0x01	; 1
    2f9c:	41 e0       	ldi	r20, 0x01	; 1
    2f9e:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_LOW);
    2fa2:	81 e0       	ldi	r24, 0x01	; 1
    2fa4:	60 e0       	ldi	r22, 0x00	; 0
    2fa6:	40 e0       	ldi	r20, 0x00	; 0
    2fa8:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    2fac:	92 c0       	rjmp	.+292    	; 0x30d2 <voidPrintNumOnSSD+0x254>
		break;
	case 3:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_LOW);
    2fae:	81 e0       	ldi	r24, 0x01	; 1
    2fb0:	64 e0       	ldi	r22, 0x04	; 4
    2fb2:	40 e0       	ldi	r20, 0x00	; 0
    2fb4:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_LOW);
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	62 e0       	ldi	r22, 0x02	; 2
    2fbc:	40 e0       	ldi	r20, 0x00	; 0
    2fbe:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_HIGH);
    2fc2:	81 e0       	ldi	r24, 0x01	; 1
    2fc4:	61 e0       	ldi	r22, 0x01	; 1
    2fc6:	41 e0       	ldi	r20, 0x01	; 1
    2fc8:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_HIGH);
    2fcc:	81 e0       	ldi	r24, 0x01	; 1
    2fce:	60 e0       	ldi	r22, 0x00	; 0
    2fd0:	41 e0       	ldi	r20, 0x01	; 1
    2fd2:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    2fd6:	7d c0       	rjmp	.+250    	; 0x30d2 <voidPrintNumOnSSD+0x254>
		break;
	case 4:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_LOW);
    2fd8:	81 e0       	ldi	r24, 0x01	; 1
    2fda:	64 e0       	ldi	r22, 0x04	; 4
    2fdc:	40 e0       	ldi	r20, 0x00	; 0
    2fde:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_HIGH);
    2fe2:	81 e0       	ldi	r24, 0x01	; 1
    2fe4:	62 e0       	ldi	r22, 0x02	; 2
    2fe6:	41 e0       	ldi	r20, 0x01	; 1
    2fe8:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_LOW);
    2fec:	81 e0       	ldi	r24, 0x01	; 1
    2fee:	61 e0       	ldi	r22, 0x01	; 1
    2ff0:	40 e0       	ldi	r20, 0x00	; 0
    2ff2:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_LOW);
    2ff6:	81 e0       	ldi	r24, 0x01	; 1
    2ff8:	60 e0       	ldi	r22, 0x00	; 0
    2ffa:	40 e0       	ldi	r20, 0x00	; 0
    2ffc:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    3000:	68 c0       	rjmp	.+208    	; 0x30d2 <voidPrintNumOnSSD+0x254>
		break;
	case 5:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_LOW);
    3002:	81 e0       	ldi	r24, 0x01	; 1
    3004:	64 e0       	ldi	r22, 0x04	; 4
    3006:	40 e0       	ldi	r20, 0x00	; 0
    3008:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_HIGH);
    300c:	81 e0       	ldi	r24, 0x01	; 1
    300e:	62 e0       	ldi	r22, 0x02	; 2
    3010:	41 e0       	ldi	r20, 0x01	; 1
    3012:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_LOW);
    3016:	81 e0       	ldi	r24, 0x01	; 1
    3018:	61 e0       	ldi	r22, 0x01	; 1
    301a:	40 e0       	ldi	r20, 0x00	; 0
    301c:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_HIGH);
    3020:	81 e0       	ldi	r24, 0x01	; 1
    3022:	60 e0       	ldi	r22, 0x00	; 0
    3024:	41 e0       	ldi	r20, 0x01	; 1
    3026:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    302a:	53 c0       	rjmp	.+166    	; 0x30d2 <voidPrintNumOnSSD+0x254>
		break;
	case 6:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_LOW);
    302c:	81 e0       	ldi	r24, 0x01	; 1
    302e:	64 e0       	ldi	r22, 0x04	; 4
    3030:	40 e0       	ldi	r20, 0x00	; 0
    3032:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_HIGH);
    3036:	81 e0       	ldi	r24, 0x01	; 1
    3038:	62 e0       	ldi	r22, 0x02	; 2
    303a:	41 e0       	ldi	r20, 0x01	; 1
    303c:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_HIGH);
    3040:	81 e0       	ldi	r24, 0x01	; 1
    3042:	61 e0       	ldi	r22, 0x01	; 1
    3044:	41 e0       	ldi	r20, 0x01	; 1
    3046:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_LOW);
    304a:	81 e0       	ldi	r24, 0x01	; 1
    304c:	60 e0       	ldi	r22, 0x00	; 0
    304e:	40 e0       	ldi	r20, 0x00	; 0
    3050:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    3054:	3e c0       	rjmp	.+124    	; 0x30d2 <voidPrintNumOnSSD+0x254>
		break;
	case 7:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_LOW);
    3056:	81 e0       	ldi	r24, 0x01	; 1
    3058:	64 e0       	ldi	r22, 0x04	; 4
    305a:	40 e0       	ldi	r20, 0x00	; 0
    305c:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_HIGH);
    3060:	81 e0       	ldi	r24, 0x01	; 1
    3062:	62 e0       	ldi	r22, 0x02	; 2
    3064:	41 e0       	ldi	r20, 0x01	; 1
    3066:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_HIGH);
    306a:	81 e0       	ldi	r24, 0x01	; 1
    306c:	61 e0       	ldi	r22, 0x01	; 1
    306e:	41 e0       	ldi	r20, 0x01	; 1
    3070:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_HIGH);
    3074:	81 e0       	ldi	r24, 0x01	; 1
    3076:	60 e0       	ldi	r22, 0x00	; 0
    3078:	41 e0       	ldi	r20, 0x01	; 1
    307a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    307e:	29 c0       	rjmp	.+82     	; 0x30d2 <voidPrintNumOnSSD+0x254>
		break;
	case 8:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_HIGH);
    3080:	81 e0       	ldi	r24, 0x01	; 1
    3082:	64 e0       	ldi	r22, 0x04	; 4
    3084:	41 e0       	ldi	r20, 0x01	; 1
    3086:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_LOW);
    308a:	81 e0       	ldi	r24, 0x01	; 1
    308c:	62 e0       	ldi	r22, 0x02	; 2
    308e:	40 e0       	ldi	r20, 0x00	; 0
    3090:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_LOW);
    3094:	81 e0       	ldi	r24, 0x01	; 1
    3096:	61 e0       	ldi	r22, 0x01	; 1
    3098:	40 e0       	ldi	r20, 0x00	; 0
    309a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_LOW);
    309e:	81 e0       	ldi	r24, 0x01	; 1
    30a0:	60 e0       	ldi	r22, 0x00	; 0
    30a2:	40 e0       	ldi	r20, 0x00	; 0
    30a4:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    30a8:	14 c0       	rjmp	.+40     	; 0x30d2 <voidPrintNumOnSSD+0x254>
		break;
	case 9:
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT3, PIN_HIGH);
    30aa:	81 e0       	ldi	r24, 0x01	; 1
    30ac:	64 e0       	ldi	r22, 0x04	; 4
    30ae:	41 e0       	ldi	r20, 0x01	; 1
    30b0:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT2, PIN_LOW);
    30b4:	81 e0       	ldi	r24, 0x01	; 1
    30b6:	62 e0       	ldi	r22, 0x02	; 2
    30b8:	40 e0       	ldi	r20, 0x00	; 0
    30ba:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT1, PIN_LOW);
    30be:	81 e0       	ldi	r24, 0x01	; 1
    30c0:	61 e0       	ldi	r22, 0x01	; 1
    30c2:	40 e0       	ldi	r20, 0x00	; 0
    30c4:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		DIO_voidSetPinValue(SSD_NUM_PORT, SSD_BIT0, PIN_HIGH);
    30c8:	81 e0       	ldi	r24, 0x01	; 1
    30ca:	60 e0       	ldi	r22, 0x00	; 0
    30cc:	41 e0       	ldi	r20, 0x01	; 1
    30ce:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
		break;
	default:
		break;
	}

}
    30d2:	0f 90       	pop	r0
    30d4:	0f 90       	pop	r0
    30d6:	0f 90       	pop	r0
    30d8:	cf 91       	pop	r28
    30da:	df 91       	pop	r29
    30dc:	08 95       	ret

000030de <SSD_voidInit>:

void SSD_voidInit(){
    30de:	df 93       	push	r29
    30e0:	cf 93       	push	r28
    30e2:	cd b7       	in	r28, 0x3d	; 61
    30e4:	de b7       	in	r29, 0x3e	; 62

	/* Output Number Ports  */
	DIO_voidSetPortDirection(SSD_NUM_PORT, PORT_OUTPUT);
    30e6:	81 e0       	ldi	r24, 0x01	; 1
    30e8:	6f ef       	ldi	r22, 0xFF	; 255
    30ea:	0e 94 85 13 	call	0x270a	; 0x270a <DIO_voidSetPortDirection>

	/* Output COM  */
	DIO_voidSetPinDirection(SSD_COM1_PORT, SSD_COM1_PIN, PIN_OUTPUT);
    30ee:	80 e0       	ldi	r24, 0x00	; 0
    30f0:	63 e0       	ldi	r22, 0x03	; 3
    30f2:	41 e0       	ldi	r20, 0x01	; 1
    30f4:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(SSD_COM2_PORT, SSD_COM2_PIN, PIN_OUTPUT);
    30f8:	80 e0       	ldi	r24, 0x00	; 0
    30fa:	62 e0       	ldi	r22, 0x02	; 2
    30fc:	41 e0       	ldi	r20, 0x01	; 1
    30fe:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(SSD_COM3_PORT, SSD_COM3_PIN, PIN_OUTPUT);
    3102:	81 e0       	ldi	r24, 0x01	; 1
    3104:	65 e0       	ldi	r22, 0x05	; 5
    3106:	41 e0       	ldi	r20, 0x01	; 1
    3108:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(SSD_COM4_PORT, SSD_COM4_PIN, PIN_OUTPUT);
    310c:	81 e0       	ldi	r24, 0x01	; 1
    310e:	66 e0       	ldi	r22, 0x06	; 6
    3110:	41 e0       	ldi	r20, 0x01	; 1
    3112:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>

	/* Disable All SSDs */
	DIO_voidSetPinValue(SSD_COM1_PORT,  SSD_COM1_PIN, PIN_HIGH);
    3116:	80 e0       	ldi	r24, 0x00	; 0
    3118:	63 e0       	ldi	r22, 0x03	; 3
    311a:	41 e0       	ldi	r20, 0x01	; 1
    311c:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM2_PORT,  SSD_COM2_PIN, PIN_HIGH);
    3120:	80 e0       	ldi	r24, 0x00	; 0
    3122:	62 e0       	ldi	r22, 0x02	; 2
    3124:	41 e0       	ldi	r20, 0x01	; 1
    3126:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM3_PORT,  SSD_COM3_PIN, PIN_HIGH);
    312a:	81 e0       	ldi	r24, 0x01	; 1
    312c:	65 e0       	ldi	r22, 0x05	; 5
    312e:	41 e0       	ldi	r20, 0x01	; 1
    3130:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM4_PORT,  SSD_COM4_PIN, PIN_HIGH);
    3134:	81 e0       	ldi	r24, 0x01	; 1
    3136:	66 e0       	ldi	r22, 0x06	; 6
    3138:	41 e0       	ldi	r20, 0x01	; 1
    313a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
}
    313e:	cf 91       	pop	r28
    3140:	df 91       	pop	r29
    3142:	08 95       	ret

00003144 <SSD_voidPrintNumOnSSD_1>:


void SSD_voidPrintNumOnSSD_1(u8 copy_u8Num){
    3144:	df 93       	push	r29
    3146:	cf 93       	push	r28
    3148:	0f 92       	push	r0
    314a:	cd b7       	in	r28, 0x3d	; 61
    314c:	de b7       	in	r29, 0x3e	; 62
    314e:	89 83       	std	Y+1, r24	; 0x01
	/* Enable SSD1 only */
	DIO_voidSetPinValue(SSD_COM1_PORT,  SSD_COM1_PIN, PIN_LOW);
    3150:	80 e0       	ldi	r24, 0x00	; 0
    3152:	63 e0       	ldi	r22, 0x03	; 3
    3154:	40 e0       	ldi	r20, 0x00	; 0
    3156:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM2_PORT,  SSD_COM2_PIN, PIN_HIGH);
    315a:	80 e0       	ldi	r24, 0x00	; 0
    315c:	62 e0       	ldi	r22, 0x02	; 2
    315e:	41 e0       	ldi	r20, 0x01	; 1
    3160:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM3_PORT,  SSD_COM3_PIN, PIN_HIGH);
    3164:	81 e0       	ldi	r24, 0x01	; 1
    3166:	65 e0       	ldi	r22, 0x05	; 5
    3168:	41 e0       	ldi	r20, 0x01	; 1
    316a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM4_PORT,  SSD_COM4_PIN, PIN_HIGH);
    316e:	81 e0       	ldi	r24, 0x01	; 1
    3170:	66 e0       	ldi	r22, 0x06	; 6
    3172:	41 e0       	ldi	r20, 0x01	; 1
    3174:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	/* Print Number on SSD1 */
	voidPrintNumOnSSD(copy_u8Num);
    3178:	89 81       	ldd	r24, Y+1	; 0x01
    317a:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <voidPrintNumOnSSD>

}
    317e:	0f 90       	pop	r0
    3180:	cf 91       	pop	r28
    3182:	df 91       	pop	r29
    3184:	08 95       	ret

00003186 <SSD_voidPrintNumOnSSD_2>:

void SSD_voidPrintNumOnSSD_2(u8 copy_u8Num){
    3186:	df 93       	push	r29
    3188:	cf 93       	push	r28
    318a:	0f 92       	push	r0
    318c:	cd b7       	in	r28, 0x3d	; 61
    318e:	de b7       	in	r29, 0x3e	; 62
    3190:	89 83       	std	Y+1, r24	; 0x01
	/* Enable SSD2 only */
	DIO_voidSetPinValue(SSD_COM1_PORT,  SSD_COM1_PIN, PIN_HIGH);
    3192:	80 e0       	ldi	r24, 0x00	; 0
    3194:	63 e0       	ldi	r22, 0x03	; 3
    3196:	41 e0       	ldi	r20, 0x01	; 1
    3198:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM2_PORT,  SSD_COM2_PIN, PIN_LOW);
    319c:	80 e0       	ldi	r24, 0x00	; 0
    319e:	62 e0       	ldi	r22, 0x02	; 2
    31a0:	40 e0       	ldi	r20, 0x00	; 0
    31a2:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM3_PORT,  SSD_COM3_PIN, PIN_HIGH);
    31a6:	81 e0       	ldi	r24, 0x01	; 1
    31a8:	65 e0       	ldi	r22, 0x05	; 5
    31aa:	41 e0       	ldi	r20, 0x01	; 1
    31ac:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM4_PORT,  SSD_COM4_PIN, PIN_HIGH);
    31b0:	81 e0       	ldi	r24, 0x01	; 1
    31b2:	66 e0       	ldi	r22, 0x06	; 6
    31b4:	41 e0       	ldi	r20, 0x01	; 1
    31b6:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	/* Print Number on SSD2 */
	voidPrintNumOnSSD(copy_u8Num);
    31ba:	89 81       	ldd	r24, Y+1	; 0x01
    31bc:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <voidPrintNumOnSSD>
}
    31c0:	0f 90       	pop	r0
    31c2:	cf 91       	pop	r28
    31c4:	df 91       	pop	r29
    31c6:	08 95       	ret

000031c8 <SSD_voidPrintNumOnSSD_3>:

void SSD_voidPrintNumOnSSD_3(u8 copy_u8Num){
    31c8:	df 93       	push	r29
    31ca:	cf 93       	push	r28
    31cc:	0f 92       	push	r0
    31ce:	cd b7       	in	r28, 0x3d	; 61
    31d0:	de b7       	in	r29, 0x3e	; 62
    31d2:	89 83       	std	Y+1, r24	; 0x01
	/* Enable SSD3 only */
	DIO_voidSetPinValue(SSD_COM1_PORT,  SSD_COM1_PIN, PIN_HIGH);
    31d4:	80 e0       	ldi	r24, 0x00	; 0
    31d6:	63 e0       	ldi	r22, 0x03	; 3
    31d8:	41 e0       	ldi	r20, 0x01	; 1
    31da:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM2_PORT,  SSD_COM2_PIN, PIN_HIGH);
    31de:	80 e0       	ldi	r24, 0x00	; 0
    31e0:	62 e0       	ldi	r22, 0x02	; 2
    31e2:	41 e0       	ldi	r20, 0x01	; 1
    31e4:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM3_PORT,  SSD_COM3_PIN, PIN_LOW);
    31e8:	81 e0       	ldi	r24, 0x01	; 1
    31ea:	65 e0       	ldi	r22, 0x05	; 5
    31ec:	40 e0       	ldi	r20, 0x00	; 0
    31ee:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM4_PORT,  SSD_COM4_PIN, PIN_HIGH);
    31f2:	81 e0       	ldi	r24, 0x01	; 1
    31f4:	66 e0       	ldi	r22, 0x06	; 6
    31f6:	41 e0       	ldi	r20, 0x01	; 1
    31f8:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	/* Print Number on SSD3 */
	voidPrintNumOnSSD(copy_u8Num);
    31fc:	89 81       	ldd	r24, Y+1	; 0x01
    31fe:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <voidPrintNumOnSSD>
}
    3202:	0f 90       	pop	r0
    3204:	cf 91       	pop	r28
    3206:	df 91       	pop	r29
    3208:	08 95       	ret

0000320a <SSD_voidPrintNumOnSSD_4>:

void SSD_voidPrintNumOnSSD_4(u8 copy_u8Num){
    320a:	df 93       	push	r29
    320c:	cf 93       	push	r28
    320e:	0f 92       	push	r0
    3210:	cd b7       	in	r28, 0x3d	; 61
    3212:	de b7       	in	r29, 0x3e	; 62
    3214:	89 83       	std	Y+1, r24	; 0x01
	/* Enable SSD4 only */
	DIO_voidSetPinValue(SSD_COM1_PORT,  SSD_COM1_PIN, PIN_HIGH);
    3216:	80 e0       	ldi	r24, 0x00	; 0
    3218:	63 e0       	ldi	r22, 0x03	; 3
    321a:	41 e0       	ldi	r20, 0x01	; 1
    321c:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM2_PORT,  SSD_COM2_PIN, PIN_HIGH);
    3220:	80 e0       	ldi	r24, 0x00	; 0
    3222:	62 e0       	ldi	r22, 0x02	; 2
    3224:	41 e0       	ldi	r20, 0x01	; 1
    3226:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM3_PORT,  SSD_COM3_PIN, PIN_HIGH);
    322a:	81 e0       	ldi	r24, 0x01	; 1
    322c:	65 e0       	ldi	r22, 0x05	; 5
    322e:	41 e0       	ldi	r20, 0x01	; 1
    3230:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SSD_COM4_PORT,  SSD_COM4_PIN, PIN_LOW);
    3234:	81 e0       	ldi	r24, 0x01	; 1
    3236:	66 e0       	ldi	r22, 0x06	; 6
    3238:	40 e0       	ldi	r20, 0x00	; 0
    323a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	/* Print Number on SSD4 */
	voidPrintNumOnSSD(copy_u8Num);
    323e:	89 81       	ldd	r24, Y+1	; 0x01
    3240:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <voidPrintNumOnSSD>
}
    3244:	0f 90       	pop	r0
    3246:	cf 91       	pop	r28
    3248:	df 91       	pop	r29
    324a:	08 95       	ret

0000324c <SEVSEG_u8FromU8toSevSeg>:
#include "SEVSEG_Interface.h"
#include "SEVSEG_Private.h"
#include "SEVSEG_Config.h"


static u8 SEVSEG_u8FromU8toSevSeg(u8 copy_u8Num){
    324c:	df 93       	push	r29
    324e:	cf 93       	push	r28
    3250:	00 d0       	rcall	.+0      	; 0x3252 <SEVSEG_u8FromU8toSevSeg+0x6>
    3252:	00 d0       	rcall	.+0      	; 0x3254 <SEVSEG_u8FromU8toSevSeg+0x8>
    3254:	cd b7       	in	r28, 0x3d	; 61
    3256:	de b7       	in	r29, 0x3e	; 62
    3258:	89 83       	std	Y+1, r24	; 0x01
	switch(copy_u8Num){
    325a:	89 81       	ldd	r24, Y+1	; 0x01
    325c:	28 2f       	mov	r18, r24
    325e:	30 e0       	ldi	r19, 0x00	; 0
    3260:	3c 83       	std	Y+4, r19	; 0x04
    3262:	2b 83       	std	Y+3, r18	; 0x03
    3264:	8b 81       	ldd	r24, Y+3	; 0x03
    3266:	9c 81       	ldd	r25, Y+4	; 0x04
    3268:	84 30       	cpi	r24, 0x04	; 4
    326a:	91 05       	cpc	r25, r1
    326c:	09 f4       	brne	.+2      	; 0x3270 <SEVSEG_u8FromU8toSevSeg+0x24>
    326e:	4b c0       	rjmp	.+150    	; 0x3306 <SEVSEG_u8FromU8toSevSeg+0xba>
    3270:	2b 81       	ldd	r18, Y+3	; 0x03
    3272:	3c 81       	ldd	r19, Y+4	; 0x04
    3274:	25 30       	cpi	r18, 0x05	; 5
    3276:	31 05       	cpc	r19, r1
    3278:	d4 f4       	brge	.+52     	; 0x32ae <SEVSEG_u8FromU8toSevSeg+0x62>
    327a:	8b 81       	ldd	r24, Y+3	; 0x03
    327c:	9c 81       	ldd	r25, Y+4	; 0x04
    327e:	81 30       	cpi	r24, 0x01	; 1
    3280:	91 05       	cpc	r25, r1
    3282:	c1 f1       	breq	.+112    	; 0x32f4 <SEVSEG_u8FromU8toSevSeg+0xa8>
    3284:	2b 81       	ldd	r18, Y+3	; 0x03
    3286:	3c 81       	ldd	r19, Y+4	; 0x04
    3288:	22 30       	cpi	r18, 0x02	; 2
    328a:	31 05       	cpc	r19, r1
    328c:	2c f4       	brge	.+10     	; 0x3298 <SEVSEG_u8FromU8toSevSeg+0x4c>
    328e:	8b 81       	ldd	r24, Y+3	; 0x03
    3290:	9c 81       	ldd	r25, Y+4	; 0x04
    3292:	00 97       	sbiw	r24, 0x00	; 0
    3294:	61 f1       	breq	.+88     	; 0x32ee <SEVSEG_u8FromU8toSevSeg+0xa2>
    3296:	49 c0       	rjmp	.+146    	; 0x332a <SEVSEG_u8FromU8toSevSeg+0xde>
    3298:	2b 81       	ldd	r18, Y+3	; 0x03
    329a:	3c 81       	ldd	r19, Y+4	; 0x04
    329c:	22 30       	cpi	r18, 0x02	; 2
    329e:	31 05       	cpc	r19, r1
    32a0:	61 f1       	breq	.+88     	; 0x32fa <SEVSEG_u8FromU8toSevSeg+0xae>
    32a2:	8b 81       	ldd	r24, Y+3	; 0x03
    32a4:	9c 81       	ldd	r25, Y+4	; 0x04
    32a6:	83 30       	cpi	r24, 0x03	; 3
    32a8:	91 05       	cpc	r25, r1
    32aa:	51 f1       	breq	.+84     	; 0x3300 <SEVSEG_u8FromU8toSevSeg+0xb4>
    32ac:	3e c0       	rjmp	.+124    	; 0x332a <SEVSEG_u8FromU8toSevSeg+0xde>
    32ae:	2b 81       	ldd	r18, Y+3	; 0x03
    32b0:	3c 81       	ldd	r19, Y+4	; 0x04
    32b2:	27 30       	cpi	r18, 0x07	; 7
    32b4:	31 05       	cpc	r19, r1
    32b6:	81 f1       	breq	.+96     	; 0x3318 <SEVSEG_u8FromU8toSevSeg+0xcc>
    32b8:	8b 81       	ldd	r24, Y+3	; 0x03
    32ba:	9c 81       	ldd	r25, Y+4	; 0x04
    32bc:	88 30       	cpi	r24, 0x08	; 8
    32be:	91 05       	cpc	r25, r1
    32c0:	5c f4       	brge	.+22     	; 0x32d8 <SEVSEG_u8FromU8toSevSeg+0x8c>
    32c2:	2b 81       	ldd	r18, Y+3	; 0x03
    32c4:	3c 81       	ldd	r19, Y+4	; 0x04
    32c6:	25 30       	cpi	r18, 0x05	; 5
    32c8:	31 05       	cpc	r19, r1
    32ca:	01 f1       	breq	.+64     	; 0x330c <SEVSEG_u8FromU8toSevSeg+0xc0>
    32cc:	8b 81       	ldd	r24, Y+3	; 0x03
    32ce:	9c 81       	ldd	r25, Y+4	; 0x04
    32d0:	86 30       	cpi	r24, 0x06	; 6
    32d2:	91 05       	cpc	r25, r1
    32d4:	f1 f0       	breq	.+60     	; 0x3312 <SEVSEG_u8FromU8toSevSeg+0xc6>
    32d6:	29 c0       	rjmp	.+82     	; 0x332a <SEVSEG_u8FromU8toSevSeg+0xde>
    32d8:	2b 81       	ldd	r18, Y+3	; 0x03
    32da:	3c 81       	ldd	r19, Y+4	; 0x04
    32dc:	28 30       	cpi	r18, 0x08	; 8
    32de:	31 05       	cpc	r19, r1
    32e0:	f1 f0       	breq	.+60     	; 0x331e <SEVSEG_u8FromU8toSevSeg+0xd2>
    32e2:	8b 81       	ldd	r24, Y+3	; 0x03
    32e4:	9c 81       	ldd	r25, Y+4	; 0x04
    32e6:	89 30       	cpi	r24, 0x09	; 9
    32e8:	91 05       	cpc	r25, r1
    32ea:	e1 f0       	breq	.+56     	; 0x3324 <SEVSEG_u8FromU8toSevSeg+0xd8>
    32ec:	1e c0       	rjmp	.+60     	; 0x332a <SEVSEG_u8FromU8toSevSeg+0xde>
	case 0:return SEVSEG_NUM_0; break;
    32ee:	9e e7       	ldi	r25, 0x7E	; 126
    32f0:	9a 83       	std	Y+2, r25	; 0x02
    32f2:	1d c0       	rjmp	.+58     	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	case 1:return SEVSEG_NUM_1; break;
    32f4:	2c e0       	ldi	r18, 0x0C	; 12
    32f6:	2a 83       	std	Y+2, r18	; 0x02
    32f8:	1a c0       	rjmp	.+52     	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	case 2:return SEVSEG_NUM_2; break;
    32fa:	36 eb       	ldi	r19, 0xB6	; 182
    32fc:	3a 83       	std	Y+2, r19	; 0x02
    32fe:	17 c0       	rjmp	.+46     	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	case 3:return SEVSEG_NUM_3; break;
    3300:	8e e9       	ldi	r24, 0x9E	; 158
    3302:	8a 83       	std	Y+2, r24	; 0x02
    3304:	14 c0       	rjmp	.+40     	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	case 4:return SEVSEG_NUM_4; break;
    3306:	9c ec       	ldi	r25, 0xCC	; 204
    3308:	9a 83       	std	Y+2, r25	; 0x02
    330a:	11 c0       	rjmp	.+34     	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	case 5:return SEVSEG_NUM_5; break;
    330c:	2a ed       	ldi	r18, 0xDA	; 218
    330e:	2a 83       	std	Y+2, r18	; 0x02
    3310:	0e c0       	rjmp	.+28     	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	case 6:return SEVSEG_NUM_6; break;
    3312:	3a ef       	ldi	r19, 0xFA	; 250
    3314:	3a 83       	std	Y+2, r19	; 0x02
    3316:	0b c0       	rjmp	.+22     	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	case 7:return SEVSEG_NUM_7; break;
    3318:	8e e0       	ldi	r24, 0x0E	; 14
    331a:	8a 83       	std	Y+2, r24	; 0x02
    331c:	08 c0       	rjmp	.+16     	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	case 8:return SEVSEG_NUM_8; break;
    331e:	9f ef       	ldi	r25, 0xFF	; 255
    3320:	9a 83       	std	Y+2, r25	; 0x02
    3322:	05 c0       	rjmp	.+10     	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	case 9:return SEVSEG_NUM_9; break;
    3324:	2e ed       	ldi	r18, 0xDE	; 222
    3326:	2a 83       	std	Y+2, r18	; 0x02
    3328:	02 c0       	rjmp	.+4      	; 0x332e <SEVSEG_u8FromU8toSevSeg+0xe2>
	default:return SEVSEG_NUM_0; break;
    332a:	3e e7       	ldi	r19, 0x7E	; 126
    332c:	3a 83       	std	Y+2, r19	; 0x02
    332e:	8a 81       	ldd	r24, Y+2	; 0x02
	}

}
    3330:	0f 90       	pop	r0
    3332:	0f 90       	pop	r0
    3334:	0f 90       	pop	r0
    3336:	0f 90       	pop	r0
    3338:	cf 91       	pop	r28
    333a:	df 91       	pop	r29
    333c:	08 95       	ret

0000333e <SEVSEG_voidInit>:
void SEVSEG_voidInit(){
    333e:	df 93       	push	r29
    3340:	cf 93       	push	r28
    3342:	cd b7       	in	r28, 0x3d	; 61
    3344:	de b7       	in	r29, 0x3e	; 62
	DIO_voidSetPortDirection(SEVSEG_NUM_PORT, PORT_OUTPUT);
    3346:	80 e0       	ldi	r24, 0x00	; 0
    3348:	6f ef       	ldi	r22, 0xFF	; 255
    334a:	0e 94 85 13 	call	0x270a	; 0x270a <DIO_voidSetPortDirection>
	DIO_voidSetPinDirection(SEVSEG_COM_PORT, SEVSEG_COM1_PIN,PIN_OUTPUT);
    334e:	82 e0       	ldi	r24, 0x02	; 2
    3350:	66 e0       	ldi	r22, 0x06	; 6
    3352:	41 e0       	ldi	r20, 0x01	; 1
    3354:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(SEVSEG_COM_PORT, SEVSEG_COM2_PIN,PIN_OUTPUT);
    3358:	82 e0       	ldi	r24, 0x02	; 2
    335a:	67 e0       	ldi	r22, 0x07	; 7
    335c:	41 e0       	ldi	r20, 0x01	; 1
    335e:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
}
    3362:	cf 91       	pop	r28
    3364:	df 91       	pop	r29
    3366:	08 95       	ret

00003368 <SEVSEG_voidPrintNum>:

void SEVSEG_voidPrintNum(u8 copy_u8Num){
    3368:	df 93       	push	r29
    336a:	cf 93       	push	r28
    336c:	cd b7       	in	r28, 0x3d	; 61
    336e:	de b7       	in	r29, 0x3e	; 62
    3370:	6f 97       	sbiw	r28, 0x1f	; 31
    3372:	0f b6       	in	r0, 0x3f	; 63
    3374:	f8 94       	cli
    3376:	de bf       	out	0x3e, r29	; 62
    3378:	0f be       	out	0x3f, r0	; 63
    337a:	cd bf       	out	0x3d, r28	; 61
    337c:	8f 8f       	std	Y+31, r24	; 0x1f

	u8 num1 = copy_u8Num%10;
    337e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3380:	9a e0       	ldi	r25, 0x0A	; 10
    3382:	69 2f       	mov	r22, r25
    3384:	0e 94 b3 3a 	call	0x7566	; 0x7566 <__udivmodqi4>
    3388:	89 2f       	mov	r24, r25
    338a:	8e 8f       	std	Y+30, r24	; 0x1e
	u8 num2 = copy_u8Num/10;
    338c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    338e:	9a e0       	ldi	r25, 0x0A	; 10
    3390:	69 2f       	mov	r22, r25
    3392:	0e 94 b3 3a 	call	0x7566	; 0x7566 <__udivmodqi4>
    3396:	8d 8f       	std	Y+29, r24	; 0x1d


	DIO_voidSetPortValue(SEVSEG_NUM_PORT, SEVSEG_u8FromU8toSevSeg(num1));
    3398:	8e 8d       	ldd	r24, Y+30	; 0x1e
    339a:	0e 94 26 19 	call	0x324c	; 0x324c <SEVSEG_u8FromU8toSevSeg>
    339e:	98 2f       	mov	r25, r24
    33a0:	80 e0       	ldi	r24, 0x00	; 0
    33a2:	69 2f       	mov	r22, r25
    33a4:	0e 94 c6 13 	call	0x278c	; 0x278c <DIO_voidSetPortValue>
	DIO_voidSetPinValue(SEVSEG_COM_PORT,  SEVSEG_COM1_PIN,PIN_HIGH);
    33a8:	82 e0       	ldi	r24, 0x02	; 2
    33aa:	66 e0       	ldi	r22, 0x06	; 6
    33ac:	41 e0       	ldi	r20, 0x01	; 1
    33ae:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SEVSEG_COM_PORT,  SEVSEG_COM2_PIN,PIN_LOW);
    33b2:	82 e0       	ldi	r24, 0x02	; 2
    33b4:	67 e0       	ldi	r22, 0x07	; 7
    33b6:	40 e0       	ldi	r20, 0x00	; 0
    33b8:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    33bc:	80 e0       	ldi	r24, 0x00	; 0
    33be:	90 e0       	ldi	r25, 0x00	; 0
    33c0:	a0 e8       	ldi	r26, 0x80	; 128
    33c2:	bf e3       	ldi	r27, 0x3F	; 63
    33c4:	89 8f       	std	Y+25, r24	; 0x19
    33c6:	9a 8f       	std	Y+26, r25	; 0x1a
    33c8:	ab 8f       	std	Y+27, r26	; 0x1b
    33ca:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    33cc:	69 8d       	ldd	r22, Y+25	; 0x19
    33ce:	7a 8d       	ldd	r23, Y+26	; 0x1a
    33d0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    33d2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    33d4:	20 e0       	ldi	r18, 0x00	; 0
    33d6:	30 e0       	ldi	r19, 0x00	; 0
    33d8:	4a e7       	ldi	r20, 0x7A	; 122
    33da:	55 e4       	ldi	r21, 0x45	; 69
    33dc:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    33e0:	dc 01       	movw	r26, r24
    33e2:	cb 01       	movw	r24, r22
    33e4:	8d 8b       	std	Y+21, r24	; 0x15
    33e6:	9e 8b       	std	Y+22, r25	; 0x16
    33e8:	af 8b       	std	Y+23, r26	; 0x17
    33ea:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    33ec:	6d 89       	ldd	r22, Y+21	; 0x15
    33ee:	7e 89       	ldd	r23, Y+22	; 0x16
    33f0:	8f 89       	ldd	r24, Y+23	; 0x17
    33f2:	98 8d       	ldd	r25, Y+24	; 0x18
    33f4:	20 e0       	ldi	r18, 0x00	; 0
    33f6:	30 e0       	ldi	r19, 0x00	; 0
    33f8:	40 e8       	ldi	r20, 0x80	; 128
    33fa:	5f e3       	ldi	r21, 0x3F	; 63
    33fc:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    3400:	88 23       	and	r24, r24
    3402:	2c f4       	brge	.+10     	; 0x340e <SEVSEG_voidPrintNum+0xa6>
		__ticks = 1;
    3404:	81 e0       	ldi	r24, 0x01	; 1
    3406:	90 e0       	ldi	r25, 0x00	; 0
    3408:	9c 8b       	std	Y+20, r25	; 0x14
    340a:	8b 8b       	std	Y+19, r24	; 0x13
    340c:	3f c0       	rjmp	.+126    	; 0x348c <SEVSEG_voidPrintNum+0x124>
	else if (__tmp > 65535)
    340e:	6d 89       	ldd	r22, Y+21	; 0x15
    3410:	7e 89       	ldd	r23, Y+22	; 0x16
    3412:	8f 89       	ldd	r24, Y+23	; 0x17
    3414:	98 8d       	ldd	r25, Y+24	; 0x18
    3416:	20 e0       	ldi	r18, 0x00	; 0
    3418:	3f ef       	ldi	r19, 0xFF	; 255
    341a:	4f e7       	ldi	r20, 0x7F	; 127
    341c:	57 e4       	ldi	r21, 0x47	; 71
    341e:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    3422:	18 16       	cp	r1, r24
    3424:	4c f5       	brge	.+82     	; 0x3478 <SEVSEG_voidPrintNum+0x110>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3426:	69 8d       	ldd	r22, Y+25	; 0x19
    3428:	7a 8d       	ldd	r23, Y+26	; 0x1a
    342a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    342c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    342e:	20 e0       	ldi	r18, 0x00	; 0
    3430:	30 e0       	ldi	r19, 0x00	; 0
    3432:	40 e2       	ldi	r20, 0x20	; 32
    3434:	51 e4       	ldi	r21, 0x41	; 65
    3436:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    343a:	dc 01       	movw	r26, r24
    343c:	cb 01       	movw	r24, r22
    343e:	bc 01       	movw	r22, r24
    3440:	cd 01       	movw	r24, r26
    3442:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3446:	dc 01       	movw	r26, r24
    3448:	cb 01       	movw	r24, r22
    344a:	9c 8b       	std	Y+20, r25	; 0x14
    344c:	8b 8b       	std	Y+19, r24	; 0x13
    344e:	0f c0       	rjmp	.+30     	; 0x346e <SEVSEG_voidPrintNum+0x106>
    3450:	80 e9       	ldi	r24, 0x90	; 144
    3452:	91 e0       	ldi	r25, 0x01	; 1
    3454:	9a 8b       	std	Y+18, r25	; 0x12
    3456:	89 8b       	std	Y+17, r24	; 0x11
    3458:	89 89       	ldd	r24, Y+17	; 0x11
    345a:	9a 89       	ldd	r25, Y+18	; 0x12
    345c:	01 97       	sbiw	r24, 0x01	; 1
    345e:	f1 f7       	brne	.-4      	; 0x345c <SEVSEG_voidPrintNum+0xf4>
    3460:	9a 8b       	std	Y+18, r25	; 0x12
    3462:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3464:	8b 89       	ldd	r24, Y+19	; 0x13
    3466:	9c 89       	ldd	r25, Y+20	; 0x14
    3468:	01 97       	sbiw	r24, 0x01	; 1
    346a:	9c 8b       	std	Y+20, r25	; 0x14
    346c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    346e:	8b 89       	ldd	r24, Y+19	; 0x13
    3470:	9c 89       	ldd	r25, Y+20	; 0x14
    3472:	00 97       	sbiw	r24, 0x00	; 0
    3474:	69 f7       	brne	.-38     	; 0x3450 <SEVSEG_voidPrintNum+0xe8>
    3476:	14 c0       	rjmp	.+40     	; 0x34a0 <SEVSEG_voidPrintNum+0x138>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3478:	6d 89       	ldd	r22, Y+21	; 0x15
    347a:	7e 89       	ldd	r23, Y+22	; 0x16
    347c:	8f 89       	ldd	r24, Y+23	; 0x17
    347e:	98 8d       	ldd	r25, Y+24	; 0x18
    3480:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3484:	dc 01       	movw	r26, r24
    3486:	cb 01       	movw	r24, r22
    3488:	9c 8b       	std	Y+20, r25	; 0x14
    348a:	8b 8b       	std	Y+19, r24	; 0x13
    348c:	8b 89       	ldd	r24, Y+19	; 0x13
    348e:	9c 89       	ldd	r25, Y+20	; 0x14
    3490:	98 8b       	std	Y+16, r25	; 0x10
    3492:	8f 87       	std	Y+15, r24	; 0x0f
    3494:	8f 85       	ldd	r24, Y+15	; 0x0f
    3496:	98 89       	ldd	r25, Y+16	; 0x10
    3498:	01 97       	sbiw	r24, 0x01	; 1
    349a:	f1 f7       	brne	.-4      	; 0x3498 <SEVSEG_voidPrintNum+0x130>
    349c:	98 8b       	std	Y+16, r25	; 0x10
    349e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);

	DIO_voidSetPortValue(SEVSEG_NUM_PORT, SEVSEG_u8FromU8toSevSeg(num2));
    34a0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    34a2:	0e 94 26 19 	call	0x324c	; 0x324c <SEVSEG_u8FromU8toSevSeg>
    34a6:	98 2f       	mov	r25, r24
    34a8:	80 e0       	ldi	r24, 0x00	; 0
    34aa:	69 2f       	mov	r22, r25
    34ac:	0e 94 c6 13 	call	0x278c	; 0x278c <DIO_voidSetPortValue>
	DIO_voidSetPinValue(SEVSEG_COM_PORT, SEVSEG_COM1_PIN,PIN_LOW);
    34b0:	82 e0       	ldi	r24, 0x02	; 2
    34b2:	66 e0       	ldi	r22, 0x06	; 6
    34b4:	40 e0       	ldi	r20, 0x00	; 0
    34b6:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SEVSEG_COM_PORT, SEVSEG_COM2_PIN,PIN_HIGH);
    34ba:	82 e0       	ldi	r24, 0x02	; 2
    34bc:	67 e0       	ldi	r22, 0x07	; 7
    34be:	41 e0       	ldi	r20, 0x01	; 1
    34c0:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    34c4:	80 e0       	ldi	r24, 0x00	; 0
    34c6:	90 e0       	ldi	r25, 0x00	; 0
    34c8:	a0 e8       	ldi	r26, 0x80	; 128
    34ca:	bf e3       	ldi	r27, 0x3F	; 63
    34cc:	8b 87       	std	Y+11, r24	; 0x0b
    34ce:	9c 87       	std	Y+12, r25	; 0x0c
    34d0:	ad 87       	std	Y+13, r26	; 0x0d
    34d2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    34d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    34d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    34d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    34da:	9e 85       	ldd	r25, Y+14	; 0x0e
    34dc:	20 e0       	ldi	r18, 0x00	; 0
    34de:	30 e0       	ldi	r19, 0x00	; 0
    34e0:	4a e7       	ldi	r20, 0x7A	; 122
    34e2:	55 e4       	ldi	r21, 0x45	; 69
    34e4:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    34e8:	dc 01       	movw	r26, r24
    34ea:	cb 01       	movw	r24, r22
    34ec:	8f 83       	std	Y+7, r24	; 0x07
    34ee:	98 87       	std	Y+8, r25	; 0x08
    34f0:	a9 87       	std	Y+9, r26	; 0x09
    34f2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    34f4:	6f 81       	ldd	r22, Y+7	; 0x07
    34f6:	78 85       	ldd	r23, Y+8	; 0x08
    34f8:	89 85       	ldd	r24, Y+9	; 0x09
    34fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    34fc:	20 e0       	ldi	r18, 0x00	; 0
    34fe:	30 e0       	ldi	r19, 0x00	; 0
    3500:	40 e8       	ldi	r20, 0x80	; 128
    3502:	5f e3       	ldi	r21, 0x3F	; 63
    3504:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    3508:	88 23       	and	r24, r24
    350a:	2c f4       	brge	.+10     	; 0x3516 <SEVSEG_voidPrintNum+0x1ae>
		__ticks = 1;
    350c:	81 e0       	ldi	r24, 0x01	; 1
    350e:	90 e0       	ldi	r25, 0x00	; 0
    3510:	9e 83       	std	Y+6, r25	; 0x06
    3512:	8d 83       	std	Y+5, r24	; 0x05
    3514:	3f c0       	rjmp	.+126    	; 0x3594 <SEVSEG_voidPrintNum+0x22c>
	else if (__tmp > 65535)
    3516:	6f 81       	ldd	r22, Y+7	; 0x07
    3518:	78 85       	ldd	r23, Y+8	; 0x08
    351a:	89 85       	ldd	r24, Y+9	; 0x09
    351c:	9a 85       	ldd	r25, Y+10	; 0x0a
    351e:	20 e0       	ldi	r18, 0x00	; 0
    3520:	3f ef       	ldi	r19, 0xFF	; 255
    3522:	4f e7       	ldi	r20, 0x7F	; 127
    3524:	57 e4       	ldi	r21, 0x47	; 71
    3526:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    352a:	18 16       	cp	r1, r24
    352c:	4c f5       	brge	.+82     	; 0x3580 <SEVSEG_voidPrintNum+0x218>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    352e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3530:	7c 85       	ldd	r23, Y+12	; 0x0c
    3532:	8d 85       	ldd	r24, Y+13	; 0x0d
    3534:	9e 85       	ldd	r25, Y+14	; 0x0e
    3536:	20 e0       	ldi	r18, 0x00	; 0
    3538:	30 e0       	ldi	r19, 0x00	; 0
    353a:	40 e2       	ldi	r20, 0x20	; 32
    353c:	51 e4       	ldi	r21, 0x41	; 65
    353e:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3542:	dc 01       	movw	r26, r24
    3544:	cb 01       	movw	r24, r22
    3546:	bc 01       	movw	r22, r24
    3548:	cd 01       	movw	r24, r26
    354a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    354e:	dc 01       	movw	r26, r24
    3550:	cb 01       	movw	r24, r22
    3552:	9e 83       	std	Y+6, r25	; 0x06
    3554:	8d 83       	std	Y+5, r24	; 0x05
    3556:	0f c0       	rjmp	.+30     	; 0x3576 <SEVSEG_voidPrintNum+0x20e>
    3558:	80 e9       	ldi	r24, 0x90	; 144
    355a:	91 e0       	ldi	r25, 0x01	; 1
    355c:	9c 83       	std	Y+4, r25	; 0x04
    355e:	8b 83       	std	Y+3, r24	; 0x03
    3560:	8b 81       	ldd	r24, Y+3	; 0x03
    3562:	9c 81       	ldd	r25, Y+4	; 0x04
    3564:	01 97       	sbiw	r24, 0x01	; 1
    3566:	f1 f7       	brne	.-4      	; 0x3564 <SEVSEG_voidPrintNum+0x1fc>
    3568:	9c 83       	std	Y+4, r25	; 0x04
    356a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    356c:	8d 81       	ldd	r24, Y+5	; 0x05
    356e:	9e 81       	ldd	r25, Y+6	; 0x06
    3570:	01 97       	sbiw	r24, 0x01	; 1
    3572:	9e 83       	std	Y+6, r25	; 0x06
    3574:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3576:	8d 81       	ldd	r24, Y+5	; 0x05
    3578:	9e 81       	ldd	r25, Y+6	; 0x06
    357a:	00 97       	sbiw	r24, 0x00	; 0
    357c:	69 f7       	brne	.-38     	; 0x3558 <SEVSEG_voidPrintNum+0x1f0>
    357e:	14 c0       	rjmp	.+40     	; 0x35a8 <SEVSEG_voidPrintNum+0x240>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3580:	6f 81       	ldd	r22, Y+7	; 0x07
    3582:	78 85       	ldd	r23, Y+8	; 0x08
    3584:	89 85       	ldd	r24, Y+9	; 0x09
    3586:	9a 85       	ldd	r25, Y+10	; 0x0a
    3588:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    358c:	dc 01       	movw	r26, r24
    358e:	cb 01       	movw	r24, r22
    3590:	9e 83       	std	Y+6, r25	; 0x06
    3592:	8d 83       	std	Y+5, r24	; 0x05
    3594:	8d 81       	ldd	r24, Y+5	; 0x05
    3596:	9e 81       	ldd	r25, Y+6	; 0x06
    3598:	9a 83       	std	Y+2, r25	; 0x02
    359a:	89 83       	std	Y+1, r24	; 0x01
    359c:	89 81       	ldd	r24, Y+1	; 0x01
    359e:	9a 81       	ldd	r25, Y+2	; 0x02
    35a0:	01 97       	sbiw	r24, 0x01	; 1
    35a2:	f1 f7       	brne	.-4      	; 0x35a0 <SEVSEG_voidPrintNum+0x238>
    35a4:	9a 83       	std	Y+2, r25	; 0x02
    35a6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);

	DIO_voidSetPinValue(SEVSEG_COM_PORT, SEVSEG_COM1_PIN,PIN_LOW);
    35a8:	82 e0       	ldi	r24, 0x02	; 2
    35aa:	66 e0       	ldi	r22, 0x06	; 6
    35ac:	40 e0       	ldi	r20, 0x00	; 0
    35ae:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(SEVSEG_COM_PORT, SEVSEG_COM2_PIN,PIN_LOW);
    35b2:	82 e0       	ldi	r24, 0x02	; 2
    35b4:	67 e0       	ldi	r22, 0x07	; 7
    35b6:	40 e0       	ldi	r20, 0x00	; 0
    35b8:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>

}
    35bc:	6f 96       	adiw	r28, 0x1f	; 31
    35be:	0f b6       	in	r0, 0x3f	; 63
    35c0:	f8 94       	cli
    35c2:	de bf       	out	0x3e, r29	; 62
    35c4:	0f be       	out	0x3f, r0	; 63
    35c6:	cd bf       	out	0x3d, r28	; 61
    35c8:	cf 91       	pop	r28
    35ca:	df 91       	pop	r29
    35cc:	08 95       	ret

000035ce <LED_voidInit>:
#include "../../MCAL/EXT/EXT_Interface.h"
/***LED***/
#include "LED_Interface.h"
#include "LED_Config.h"

void LED_voidInit(){
    35ce:	df 93       	push	r29
    35d0:	cf 93       	push	r28
    35d2:	cd b7       	in	r28, 0x3d	; 61
    35d4:	de b7       	in	r29, 0x3e	; 62
	DIO_voidSetPinDirection(LED_BLU_PORT, LED_BLU_PIN, PIN_OUTPUT);
    35d6:	80 e0       	ldi	r24, 0x00	; 0
    35d8:	65 e0       	ldi	r22, 0x05	; 5
    35da:	41 e0       	ldi	r20, 0x01	; 1
    35dc:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LED_GRN_PORT, LED_GRN_PIN, PIN_OUTPUT);
    35e0:	80 e0       	ldi	r24, 0x00	; 0
    35e2:	64 e0       	ldi	r22, 0x04	; 4
    35e4:	41 e0       	ldi	r20, 0x01	; 1
    35e6:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LED_RED_PORT, LED_RED_PIN, PIN_OUTPUT);
    35ea:	81 e0       	ldi	r24, 0x01	; 1
    35ec:	67 e0       	ldi	r22, 0x07	; 7
    35ee:	41 e0       	ldi	r20, 0x01	; 1
    35f0:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(LED_YEL_PORT, LED_YEL_PIN, PIN_OUTPUT);
    35f4:	80 e0       	ldi	r24, 0x00	; 0
    35f6:	66 e0       	ldi	r22, 0x06	; 6
    35f8:	41 e0       	ldi	r20, 0x01	; 1
    35fa:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	LED_voidTurnOffLed(LED_BLU_ID);
    35fe:	80 e0       	ldi	r24, 0x00	; 0
    3600:	0e 94 51 1b 	call	0x36a2	; 0x36a2 <LED_voidTurnOffLed>
	LED_voidTurnOffLed(LED_GRN_ID);
    3604:	81 e0       	ldi	r24, 0x01	; 1
    3606:	0e 94 51 1b 	call	0x36a2	; 0x36a2 <LED_voidTurnOffLed>
	LED_voidTurnOffLed(LED_RED_ID);
    360a:	82 e0       	ldi	r24, 0x02	; 2
    360c:	0e 94 51 1b 	call	0x36a2	; 0x36a2 <LED_voidTurnOffLed>
	LED_voidTurnOffLed(LED_YEL_ID);
    3610:	83 e0       	ldi	r24, 0x03	; 3
    3612:	0e 94 51 1b 	call	0x36a2	; 0x36a2 <LED_voidTurnOffLed>
}
    3616:	cf 91       	pop	r28
    3618:	df 91       	pop	r29
    361a:	08 95       	ret

0000361c <LED_voidTurnOnLed>:

void LED_voidTurnOnLed(u8 Copy_u8LedID){
    361c:	df 93       	push	r29
    361e:	cf 93       	push	r28
    3620:	00 d0       	rcall	.+0      	; 0x3622 <LED_voidTurnOnLed+0x6>
    3622:	0f 92       	push	r0
    3624:	cd b7       	in	r28, 0x3d	; 61
    3626:	de b7       	in	r29, 0x3e	; 62
    3628:	89 83       	std	Y+1, r24	; 0x01

	switch(Copy_u8LedID){
    362a:	89 81       	ldd	r24, Y+1	; 0x01
    362c:	28 2f       	mov	r18, r24
    362e:	30 e0       	ldi	r19, 0x00	; 0
    3630:	3b 83       	std	Y+3, r19	; 0x03
    3632:	2a 83       	std	Y+2, r18	; 0x02
    3634:	8a 81       	ldd	r24, Y+2	; 0x02
    3636:	9b 81       	ldd	r25, Y+3	; 0x03
    3638:	81 30       	cpi	r24, 0x01	; 1
    363a:	91 05       	cpc	r25, r1
    363c:	d9 f0       	breq	.+54     	; 0x3674 <LED_voidTurnOnLed+0x58>
    363e:	2a 81       	ldd	r18, Y+2	; 0x02
    3640:	3b 81       	ldd	r19, Y+3	; 0x03
    3642:	22 30       	cpi	r18, 0x02	; 2
    3644:	31 05       	cpc	r19, r1
    3646:	2c f4       	brge	.+10     	; 0x3652 <LED_voidTurnOnLed+0x36>
    3648:	8a 81       	ldd	r24, Y+2	; 0x02
    364a:	9b 81       	ldd	r25, Y+3	; 0x03
    364c:	00 97       	sbiw	r24, 0x00	; 0
    364e:	61 f0       	breq	.+24     	; 0x3668 <LED_voidTurnOnLed+0x4c>
    3650:	22 c0       	rjmp	.+68     	; 0x3696 <LED_voidTurnOnLed+0x7a>
    3652:	2a 81       	ldd	r18, Y+2	; 0x02
    3654:	3b 81       	ldd	r19, Y+3	; 0x03
    3656:	22 30       	cpi	r18, 0x02	; 2
    3658:	31 05       	cpc	r19, r1
    365a:	91 f0       	breq	.+36     	; 0x3680 <LED_voidTurnOnLed+0x64>
    365c:	8a 81       	ldd	r24, Y+2	; 0x02
    365e:	9b 81       	ldd	r25, Y+3	; 0x03
    3660:	83 30       	cpi	r24, 0x03	; 3
    3662:	91 05       	cpc	r25, r1
    3664:	99 f0       	breq	.+38     	; 0x368c <LED_voidTurnOnLed+0x70>
    3666:	17 c0       	rjmp	.+46     	; 0x3696 <LED_voidTurnOnLed+0x7a>
	case LED_BLU_ID: DIO_voidSetPinValue(LED_BLU_PORT,LED_BLU_PIN,PIN_HIGH);break;
    3668:	80 e0       	ldi	r24, 0x00	; 0
    366a:	65 e0       	ldi	r22, 0x05	; 5
    366c:	41 e0       	ldi	r20, 0x01	; 1
    366e:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    3672:	11 c0       	rjmp	.+34     	; 0x3696 <LED_voidTurnOnLed+0x7a>
	case LED_GRN_ID: DIO_voidSetPinValue(LED_GRN_PORT,LED_GRN_PIN,PIN_HIGH);break;
    3674:	80 e0       	ldi	r24, 0x00	; 0
    3676:	64 e0       	ldi	r22, 0x04	; 4
    3678:	41 e0       	ldi	r20, 0x01	; 1
    367a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    367e:	0b c0       	rjmp	.+22     	; 0x3696 <LED_voidTurnOnLed+0x7a>
	case LED_RED_ID: DIO_voidSetPinValue(LED_RED_PORT,LED_RED_PIN,PIN_HIGH);break;
    3680:	81 e0       	ldi	r24, 0x01	; 1
    3682:	67 e0       	ldi	r22, 0x07	; 7
    3684:	41 e0       	ldi	r20, 0x01	; 1
    3686:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    368a:	05 c0       	rjmp	.+10     	; 0x3696 <LED_voidTurnOnLed+0x7a>
	case LED_YEL_ID: DIO_voidSetPinValue(LED_YEL_PORT,LED_YEL_PIN,PIN_HIGH);break;
    368c:	80 e0       	ldi	r24, 0x00	; 0
    368e:	66 e0       	ldi	r22, 0x06	; 6
    3690:	41 e0       	ldi	r20, 0x01	; 1
    3692:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	default:break;
	}
}
    3696:	0f 90       	pop	r0
    3698:	0f 90       	pop	r0
    369a:	0f 90       	pop	r0
    369c:	cf 91       	pop	r28
    369e:	df 91       	pop	r29
    36a0:	08 95       	ret

000036a2 <LED_voidTurnOffLed>:

void LED_voidTurnOffLed(u8 Copy_u8LedID){
    36a2:	df 93       	push	r29
    36a4:	cf 93       	push	r28
    36a6:	00 d0       	rcall	.+0      	; 0x36a8 <LED_voidTurnOffLed+0x6>
    36a8:	0f 92       	push	r0
    36aa:	cd b7       	in	r28, 0x3d	; 61
    36ac:	de b7       	in	r29, 0x3e	; 62
    36ae:	89 83       	std	Y+1, r24	; 0x01

	switch(Copy_u8LedID){
    36b0:	89 81       	ldd	r24, Y+1	; 0x01
    36b2:	28 2f       	mov	r18, r24
    36b4:	30 e0       	ldi	r19, 0x00	; 0
    36b6:	3b 83       	std	Y+3, r19	; 0x03
    36b8:	2a 83       	std	Y+2, r18	; 0x02
    36ba:	8a 81       	ldd	r24, Y+2	; 0x02
    36bc:	9b 81       	ldd	r25, Y+3	; 0x03
    36be:	81 30       	cpi	r24, 0x01	; 1
    36c0:	91 05       	cpc	r25, r1
    36c2:	d9 f0       	breq	.+54     	; 0x36fa <LED_voidTurnOffLed+0x58>
    36c4:	2a 81       	ldd	r18, Y+2	; 0x02
    36c6:	3b 81       	ldd	r19, Y+3	; 0x03
    36c8:	22 30       	cpi	r18, 0x02	; 2
    36ca:	31 05       	cpc	r19, r1
    36cc:	2c f4       	brge	.+10     	; 0x36d8 <LED_voidTurnOffLed+0x36>
    36ce:	8a 81       	ldd	r24, Y+2	; 0x02
    36d0:	9b 81       	ldd	r25, Y+3	; 0x03
    36d2:	00 97       	sbiw	r24, 0x00	; 0
    36d4:	61 f0       	breq	.+24     	; 0x36ee <LED_voidTurnOffLed+0x4c>
    36d6:	22 c0       	rjmp	.+68     	; 0x371c <LED_voidTurnOffLed+0x7a>
    36d8:	2a 81       	ldd	r18, Y+2	; 0x02
    36da:	3b 81       	ldd	r19, Y+3	; 0x03
    36dc:	22 30       	cpi	r18, 0x02	; 2
    36de:	31 05       	cpc	r19, r1
    36e0:	91 f0       	breq	.+36     	; 0x3706 <LED_voidTurnOffLed+0x64>
    36e2:	8a 81       	ldd	r24, Y+2	; 0x02
    36e4:	9b 81       	ldd	r25, Y+3	; 0x03
    36e6:	83 30       	cpi	r24, 0x03	; 3
    36e8:	91 05       	cpc	r25, r1
    36ea:	99 f0       	breq	.+38     	; 0x3712 <LED_voidTurnOffLed+0x70>
    36ec:	17 c0       	rjmp	.+46     	; 0x371c <LED_voidTurnOffLed+0x7a>
	case LED_BLU_ID: DIO_voidSetPinValue(LED_BLU_PORT,LED_BLU_PIN,PIN_LOW);break;
    36ee:	80 e0       	ldi	r24, 0x00	; 0
    36f0:	65 e0       	ldi	r22, 0x05	; 5
    36f2:	40 e0       	ldi	r20, 0x00	; 0
    36f4:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    36f8:	11 c0       	rjmp	.+34     	; 0x371c <LED_voidTurnOffLed+0x7a>
	case LED_GRN_ID: DIO_voidSetPinValue(LED_GRN_PORT,LED_GRN_PIN,PIN_LOW);break;
    36fa:	80 e0       	ldi	r24, 0x00	; 0
    36fc:	64 e0       	ldi	r22, 0x04	; 4
    36fe:	40 e0       	ldi	r20, 0x00	; 0
    3700:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    3704:	0b c0       	rjmp	.+22     	; 0x371c <LED_voidTurnOffLed+0x7a>
	case LED_RED_ID: DIO_voidSetPinValue(LED_RED_PORT,LED_RED_PIN,PIN_LOW);break;
    3706:	81 e0       	ldi	r24, 0x01	; 1
    3708:	67 e0       	ldi	r22, 0x07	; 7
    370a:	40 e0       	ldi	r20, 0x00	; 0
    370c:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    3710:	05 c0       	rjmp	.+10     	; 0x371c <LED_voidTurnOffLed+0x7a>
	case LED_YEL_ID: DIO_voidSetPinValue(LED_YEL_PORT,LED_YEL_PIN,PIN_LOW);break;
    3712:	80 e0       	ldi	r24, 0x00	; 0
    3714:	66 e0       	ldi	r22, 0x06	; 6
    3716:	40 e0       	ldi	r20, 0x00	; 0
    3718:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	default:break;
	}
}
    371c:	0f 90       	pop	r0
    371e:	0f 90       	pop	r0
    3720:	0f 90       	pop	r0
    3722:	cf 91       	pop	r28
    3724:	df 91       	pop	r29
    3726:	08 95       	ret

00003728 <LED_voidToggleLed>:

void LED_voidToggleLed(u8 Copy_u8LedID){
    3728:	df 93       	push	r29
    372a:	cf 93       	push	r28
    372c:	00 d0       	rcall	.+0      	; 0x372e <LED_voidToggleLed+0x6>
    372e:	0f 92       	push	r0
    3730:	cd b7       	in	r28, 0x3d	; 61
    3732:	de b7       	in	r29, 0x3e	; 62
    3734:	89 83       	std	Y+1, r24	; 0x01

	switch(Copy_u8LedID){
    3736:	89 81       	ldd	r24, Y+1	; 0x01
    3738:	28 2f       	mov	r18, r24
    373a:	30 e0       	ldi	r19, 0x00	; 0
    373c:	3b 83       	std	Y+3, r19	; 0x03
    373e:	2a 83       	std	Y+2, r18	; 0x02
    3740:	8a 81       	ldd	r24, Y+2	; 0x02
    3742:	9b 81       	ldd	r25, Y+3	; 0x03
    3744:	81 30       	cpi	r24, 0x01	; 1
    3746:	91 05       	cpc	r25, r1
    3748:	d1 f0       	breq	.+52     	; 0x377e <LED_voidToggleLed+0x56>
    374a:	2a 81       	ldd	r18, Y+2	; 0x02
    374c:	3b 81       	ldd	r19, Y+3	; 0x03
    374e:	22 30       	cpi	r18, 0x02	; 2
    3750:	31 05       	cpc	r19, r1
    3752:	2c f4       	brge	.+10     	; 0x375e <LED_voidToggleLed+0x36>
    3754:	8a 81       	ldd	r24, Y+2	; 0x02
    3756:	9b 81       	ldd	r25, Y+3	; 0x03
    3758:	00 97       	sbiw	r24, 0x00	; 0
    375a:	61 f0       	breq	.+24     	; 0x3774 <LED_voidToggleLed+0x4c>
    375c:	1e c0       	rjmp	.+60     	; 0x379a <LED_voidToggleLed+0x72>
    375e:	2a 81       	ldd	r18, Y+2	; 0x02
    3760:	3b 81       	ldd	r19, Y+3	; 0x03
    3762:	22 30       	cpi	r18, 0x02	; 2
    3764:	31 05       	cpc	r19, r1
    3766:	81 f0       	breq	.+32     	; 0x3788 <LED_voidToggleLed+0x60>
    3768:	8a 81       	ldd	r24, Y+2	; 0x02
    376a:	9b 81       	ldd	r25, Y+3	; 0x03
    376c:	83 30       	cpi	r24, 0x03	; 3
    376e:	91 05       	cpc	r25, r1
    3770:	81 f0       	breq	.+32     	; 0x3792 <LED_voidToggleLed+0x6a>
    3772:	13 c0       	rjmp	.+38     	; 0x379a <LED_voidToggleLed+0x72>
	case LED_BLU_ID: DIO_voidToggelPin(LED_BLU_PORT,LED_BLU_PIN);break;
    3774:	80 e0       	ldi	r24, 0x00	; 0
    3776:	65 e0       	ldi	r22, 0x05	; 5
    3778:	0e 94 86 14 	call	0x290c	; 0x290c <DIO_voidToggelPin>
    377c:	0e c0       	rjmp	.+28     	; 0x379a <LED_voidToggleLed+0x72>
	case LED_GRN_ID: DIO_voidToggelPin(LED_GRN_PORT,LED_GRN_PIN);break;
    377e:	80 e0       	ldi	r24, 0x00	; 0
    3780:	64 e0       	ldi	r22, 0x04	; 4
    3782:	0e 94 86 14 	call	0x290c	; 0x290c <DIO_voidToggelPin>
    3786:	09 c0       	rjmp	.+18     	; 0x379a <LED_voidToggleLed+0x72>
	case LED_RED_ID: DIO_voidToggelPin(LED_RED_PORT,LED_RED_PIN);break;
    3788:	81 e0       	ldi	r24, 0x01	; 1
    378a:	67 e0       	ldi	r22, 0x07	; 7
    378c:	0e 94 86 14 	call	0x290c	; 0x290c <DIO_voidToggelPin>
    3790:	04 c0       	rjmp	.+8      	; 0x379a <LED_voidToggleLed+0x72>
	case LED_YEL_ID: DIO_voidToggelPin(LED_YEL_PORT,LED_YEL_PIN);break;
    3792:	80 e0       	ldi	r24, 0x00	; 0
    3794:	66 e0       	ldi	r22, 0x06	; 6
    3796:	0e 94 86 14 	call	0x290c	; 0x290c <DIO_voidToggelPin>
	default:break;
	}
}
    379a:	0f 90       	pop	r0
    379c:	0f 90       	pop	r0
    379e:	0f 90       	pop	r0
    37a0:	cf 91       	pop	r28
    37a2:	df 91       	pop	r29
    37a4:	08 95       	ret

000037a6 <LCD_voidWriteBitsToSend>:


static u8  global_string[MAX_STRING_SIZE]={0};
static u8* global_StringData=NULL_PTR;

static void LCD_voidWriteBitsToSend(u8 copy_u8Byte){
    37a6:	df 93       	push	r29
    37a8:	cf 93       	push	r28
    37aa:	cd b7       	in	r28, 0x3d	; 61
    37ac:	de b7       	in	r29, 0x3e	; 62
    37ae:	e9 97       	sbiw	r28, 0x39	; 57
    37b0:	0f b6       	in	r0, 0x3f	; 63
    37b2:	f8 94       	cli
    37b4:	de bf       	out	0x3e, r29	; 62
    37b6:	0f be       	out	0x3f, r0	; 63
    37b8:	cd bf       	out	0x3d, r28	; 61
    37ba:	89 af       	std	Y+57, r24	; 0x39

	DIO_voidSetPinValue(EN_PORT,EN_PIN, PIN_LOW);
    37bc:	80 e0       	ldi	r24, 0x00	; 0
    37be:	62 e0       	ldi	r22, 0x02	; 2
    37c0:	40 e0       	ldi	r20, 0x00	; 0
    37c2:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>

	DIO_voidSetPinValue(D7_PORT,D7_PIN, GET_BIT(copy_u8Byte,PIN7));
    37c6:	89 ad       	ldd	r24, Y+57	; 0x39
    37c8:	98 2f       	mov	r25, r24
    37ca:	99 1f       	adc	r25, r25
    37cc:	99 27       	eor	r25, r25
    37ce:	99 1f       	adc	r25, r25
    37d0:	81 e0       	ldi	r24, 0x01	; 1
    37d2:	64 e0       	ldi	r22, 0x04	; 4
    37d4:	49 2f       	mov	r20, r25
    37d6:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D6_PORT,D6_PIN, GET_BIT(copy_u8Byte,PIN6));
    37da:	89 ad       	ldd	r24, Y+57	; 0x39
    37dc:	82 95       	swap	r24
    37de:	86 95       	lsr	r24
    37e0:	86 95       	lsr	r24
    37e2:	83 70       	andi	r24, 0x03	; 3
    37e4:	98 2f       	mov	r25, r24
    37e6:	91 70       	andi	r25, 0x01	; 1
    37e8:	81 e0       	ldi	r24, 0x01	; 1
    37ea:	62 e0       	ldi	r22, 0x02	; 2
    37ec:	49 2f       	mov	r20, r25
    37ee:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D5_PORT,D5_PIN, GET_BIT(copy_u8Byte,PIN5));
    37f2:	89 ad       	ldd	r24, Y+57	; 0x39
    37f4:	82 95       	swap	r24
    37f6:	86 95       	lsr	r24
    37f8:	87 70       	andi	r24, 0x07	; 7
    37fa:	98 2f       	mov	r25, r24
    37fc:	91 70       	andi	r25, 0x01	; 1
    37fe:	81 e0       	ldi	r24, 0x01	; 1
    3800:	61 e0       	ldi	r22, 0x01	; 1
    3802:	49 2f       	mov	r20, r25
    3804:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D4_PORT,D4_PIN, GET_BIT(copy_u8Byte,PIN4));
    3808:	89 ad       	ldd	r24, Y+57	; 0x39
    380a:	82 95       	swap	r24
    380c:	8f 70       	andi	r24, 0x0F	; 15
    380e:	98 2f       	mov	r25, r24
    3810:	91 70       	andi	r25, 0x01	; 1
    3812:	81 e0       	ldi	r24, 0x01	; 1
    3814:	60 e0       	ldi	r22, 0x00	; 0
    3816:	49 2f       	mov	r20, r25
    3818:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(EN_PORT,EN_PIN, PIN_HIGH);
    381c:	80 e0       	ldi	r24, 0x00	; 0
    381e:	62 e0       	ldi	r22, 0x02	; 2
    3820:	41 e0       	ldi	r20, 0x01	; 1
    3822:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    3826:	80 e0       	ldi	r24, 0x00	; 0
    3828:	90 e0       	ldi	r25, 0x00	; 0
    382a:	a0 e0       	ldi	r26, 0x00	; 0
    382c:	b0 e4       	ldi	r27, 0x40	; 64
    382e:	8d ab       	std	Y+53, r24	; 0x35
    3830:	9e ab       	std	Y+54, r25	; 0x36
    3832:	af ab       	std	Y+55, r26	; 0x37
    3834:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3836:	6d a9       	ldd	r22, Y+53	; 0x35
    3838:	7e a9       	ldd	r23, Y+54	; 0x36
    383a:	8f a9       	ldd	r24, Y+55	; 0x37
    383c:	98 ad       	ldd	r25, Y+56	; 0x38
    383e:	20 e0       	ldi	r18, 0x00	; 0
    3840:	30 e0       	ldi	r19, 0x00	; 0
    3842:	4a e7       	ldi	r20, 0x7A	; 122
    3844:	55 e4       	ldi	r21, 0x45	; 69
    3846:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    384a:	dc 01       	movw	r26, r24
    384c:	cb 01       	movw	r24, r22
    384e:	89 ab       	std	Y+49, r24	; 0x31
    3850:	9a ab       	std	Y+50, r25	; 0x32
    3852:	ab ab       	std	Y+51, r26	; 0x33
    3854:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    3856:	69 a9       	ldd	r22, Y+49	; 0x31
    3858:	7a a9       	ldd	r23, Y+50	; 0x32
    385a:	8b a9       	ldd	r24, Y+51	; 0x33
    385c:	9c a9       	ldd	r25, Y+52	; 0x34
    385e:	20 e0       	ldi	r18, 0x00	; 0
    3860:	30 e0       	ldi	r19, 0x00	; 0
    3862:	40 e8       	ldi	r20, 0x80	; 128
    3864:	5f e3       	ldi	r21, 0x3F	; 63
    3866:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    386a:	88 23       	and	r24, r24
    386c:	2c f4       	brge	.+10     	; 0x3878 <LCD_voidWriteBitsToSend+0xd2>
		__ticks = 1;
    386e:	81 e0       	ldi	r24, 0x01	; 1
    3870:	90 e0       	ldi	r25, 0x00	; 0
    3872:	98 ab       	std	Y+48, r25	; 0x30
    3874:	8f a7       	std	Y+47, r24	; 0x2f
    3876:	3f c0       	rjmp	.+126    	; 0x38f6 <LCD_voidWriteBitsToSend+0x150>
	else if (__tmp > 65535)
    3878:	69 a9       	ldd	r22, Y+49	; 0x31
    387a:	7a a9       	ldd	r23, Y+50	; 0x32
    387c:	8b a9       	ldd	r24, Y+51	; 0x33
    387e:	9c a9       	ldd	r25, Y+52	; 0x34
    3880:	20 e0       	ldi	r18, 0x00	; 0
    3882:	3f ef       	ldi	r19, 0xFF	; 255
    3884:	4f e7       	ldi	r20, 0x7F	; 127
    3886:	57 e4       	ldi	r21, 0x47	; 71
    3888:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    388c:	18 16       	cp	r1, r24
    388e:	4c f5       	brge	.+82     	; 0x38e2 <LCD_voidWriteBitsToSend+0x13c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3890:	6d a9       	ldd	r22, Y+53	; 0x35
    3892:	7e a9       	ldd	r23, Y+54	; 0x36
    3894:	8f a9       	ldd	r24, Y+55	; 0x37
    3896:	98 ad       	ldd	r25, Y+56	; 0x38
    3898:	20 e0       	ldi	r18, 0x00	; 0
    389a:	30 e0       	ldi	r19, 0x00	; 0
    389c:	40 e2       	ldi	r20, 0x20	; 32
    389e:	51 e4       	ldi	r21, 0x41	; 65
    38a0:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    38a4:	dc 01       	movw	r26, r24
    38a6:	cb 01       	movw	r24, r22
    38a8:	bc 01       	movw	r22, r24
    38aa:	cd 01       	movw	r24, r26
    38ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    38b0:	dc 01       	movw	r26, r24
    38b2:	cb 01       	movw	r24, r22
    38b4:	98 ab       	std	Y+48, r25	; 0x30
    38b6:	8f a7       	std	Y+47, r24	; 0x2f
    38b8:	0f c0       	rjmp	.+30     	; 0x38d8 <LCD_voidWriteBitsToSend+0x132>
    38ba:	80 e9       	ldi	r24, 0x90	; 144
    38bc:	91 e0       	ldi	r25, 0x01	; 1
    38be:	9e a7       	std	Y+46, r25	; 0x2e
    38c0:	8d a7       	std	Y+45, r24	; 0x2d
    38c2:	8d a5       	ldd	r24, Y+45	; 0x2d
    38c4:	9e a5       	ldd	r25, Y+46	; 0x2e
    38c6:	01 97       	sbiw	r24, 0x01	; 1
    38c8:	f1 f7       	brne	.-4      	; 0x38c6 <LCD_voidWriteBitsToSend+0x120>
    38ca:	9e a7       	std	Y+46, r25	; 0x2e
    38cc:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    38ce:	8f a5       	ldd	r24, Y+47	; 0x2f
    38d0:	98 a9       	ldd	r25, Y+48	; 0x30
    38d2:	01 97       	sbiw	r24, 0x01	; 1
    38d4:	98 ab       	std	Y+48, r25	; 0x30
    38d6:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    38d8:	8f a5       	ldd	r24, Y+47	; 0x2f
    38da:	98 a9       	ldd	r25, Y+48	; 0x30
    38dc:	00 97       	sbiw	r24, 0x00	; 0
    38de:	69 f7       	brne	.-38     	; 0x38ba <LCD_voidWriteBitsToSend+0x114>
    38e0:	14 c0       	rjmp	.+40     	; 0x390a <LCD_voidWriteBitsToSend+0x164>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    38e2:	69 a9       	ldd	r22, Y+49	; 0x31
    38e4:	7a a9       	ldd	r23, Y+50	; 0x32
    38e6:	8b a9       	ldd	r24, Y+51	; 0x33
    38e8:	9c a9       	ldd	r25, Y+52	; 0x34
    38ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    38ee:	dc 01       	movw	r26, r24
    38f0:	cb 01       	movw	r24, r22
    38f2:	98 ab       	std	Y+48, r25	; 0x30
    38f4:	8f a7       	std	Y+47, r24	; 0x2f
    38f6:	8f a5       	ldd	r24, Y+47	; 0x2f
    38f8:	98 a9       	ldd	r25, Y+48	; 0x30
    38fa:	9c a7       	std	Y+44, r25	; 0x2c
    38fc:	8b a7       	std	Y+43, r24	; 0x2b
    38fe:	8b a5       	ldd	r24, Y+43	; 0x2b
    3900:	9c a5       	ldd	r25, Y+44	; 0x2c
    3902:	01 97       	sbiw	r24, 0x01	; 1
    3904:	f1 f7       	brne	.-4      	; 0x3902 <LCD_voidWriteBitsToSend+0x15c>
    3906:	9c a7       	std	Y+44, r25	; 0x2c
    3908:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(EN_HIGH_DELAY);
	DIO_voidSetPinValue(EN_PORT,EN_PIN, PIN_LOW);
    390a:	80 e0       	ldi	r24, 0x00	; 0
    390c:	62 e0       	ldi	r22, 0x02	; 2
    390e:	40 e0       	ldi	r20, 0x00	; 0
    3910:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    3914:	80 e0       	ldi	r24, 0x00	; 0
    3916:	90 e0       	ldi	r25, 0x00	; 0
    3918:	a0 ea       	ldi	r26, 0xA0	; 160
    391a:	b1 e4       	ldi	r27, 0x41	; 65
    391c:	8f a3       	std	Y+39, r24	; 0x27
    391e:	98 a7       	std	Y+40, r25	; 0x28
    3920:	a9 a7       	std	Y+41, r26	; 0x29
    3922:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3924:	6f a1       	ldd	r22, Y+39	; 0x27
    3926:	78 a5       	ldd	r23, Y+40	; 0x28
    3928:	89 a5       	ldd	r24, Y+41	; 0x29
    392a:	9a a5       	ldd	r25, Y+42	; 0x2a
    392c:	20 e0       	ldi	r18, 0x00	; 0
    392e:	30 e0       	ldi	r19, 0x00	; 0
    3930:	4a e7       	ldi	r20, 0x7A	; 122
    3932:	55 e4       	ldi	r21, 0x45	; 69
    3934:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3938:	dc 01       	movw	r26, r24
    393a:	cb 01       	movw	r24, r22
    393c:	8b a3       	std	Y+35, r24	; 0x23
    393e:	9c a3       	std	Y+36, r25	; 0x24
    3940:	ad a3       	std	Y+37, r26	; 0x25
    3942:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    3944:	6b a1       	ldd	r22, Y+35	; 0x23
    3946:	7c a1       	ldd	r23, Y+36	; 0x24
    3948:	8d a1       	ldd	r24, Y+37	; 0x25
    394a:	9e a1       	ldd	r25, Y+38	; 0x26
    394c:	20 e0       	ldi	r18, 0x00	; 0
    394e:	30 e0       	ldi	r19, 0x00	; 0
    3950:	40 e8       	ldi	r20, 0x80	; 128
    3952:	5f e3       	ldi	r21, 0x3F	; 63
    3954:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    3958:	88 23       	and	r24, r24
    395a:	2c f4       	brge	.+10     	; 0x3966 <LCD_voidWriteBitsToSend+0x1c0>
		__ticks = 1;
    395c:	81 e0       	ldi	r24, 0x01	; 1
    395e:	90 e0       	ldi	r25, 0x00	; 0
    3960:	9a a3       	std	Y+34, r25	; 0x22
    3962:	89 a3       	std	Y+33, r24	; 0x21
    3964:	3f c0       	rjmp	.+126    	; 0x39e4 <LCD_voidWriteBitsToSend+0x23e>
	else if (__tmp > 65535)
    3966:	6b a1       	ldd	r22, Y+35	; 0x23
    3968:	7c a1       	ldd	r23, Y+36	; 0x24
    396a:	8d a1       	ldd	r24, Y+37	; 0x25
    396c:	9e a1       	ldd	r25, Y+38	; 0x26
    396e:	20 e0       	ldi	r18, 0x00	; 0
    3970:	3f ef       	ldi	r19, 0xFF	; 255
    3972:	4f e7       	ldi	r20, 0x7F	; 127
    3974:	57 e4       	ldi	r21, 0x47	; 71
    3976:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    397a:	18 16       	cp	r1, r24
    397c:	4c f5       	brge	.+82     	; 0x39d0 <LCD_voidWriteBitsToSend+0x22a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    397e:	6f a1       	ldd	r22, Y+39	; 0x27
    3980:	78 a5       	ldd	r23, Y+40	; 0x28
    3982:	89 a5       	ldd	r24, Y+41	; 0x29
    3984:	9a a5       	ldd	r25, Y+42	; 0x2a
    3986:	20 e0       	ldi	r18, 0x00	; 0
    3988:	30 e0       	ldi	r19, 0x00	; 0
    398a:	40 e2       	ldi	r20, 0x20	; 32
    398c:	51 e4       	ldi	r21, 0x41	; 65
    398e:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3992:	dc 01       	movw	r26, r24
    3994:	cb 01       	movw	r24, r22
    3996:	bc 01       	movw	r22, r24
    3998:	cd 01       	movw	r24, r26
    399a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    399e:	dc 01       	movw	r26, r24
    39a0:	cb 01       	movw	r24, r22
    39a2:	9a a3       	std	Y+34, r25	; 0x22
    39a4:	89 a3       	std	Y+33, r24	; 0x21
    39a6:	0f c0       	rjmp	.+30     	; 0x39c6 <LCD_voidWriteBitsToSend+0x220>
    39a8:	80 e9       	ldi	r24, 0x90	; 144
    39aa:	91 e0       	ldi	r25, 0x01	; 1
    39ac:	98 a3       	std	Y+32, r25	; 0x20
    39ae:	8f 8f       	std	Y+31, r24	; 0x1f
    39b0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    39b2:	98 a1       	ldd	r25, Y+32	; 0x20
    39b4:	01 97       	sbiw	r24, 0x01	; 1
    39b6:	f1 f7       	brne	.-4      	; 0x39b4 <LCD_voidWriteBitsToSend+0x20e>
    39b8:	98 a3       	std	Y+32, r25	; 0x20
    39ba:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39bc:	89 a1       	ldd	r24, Y+33	; 0x21
    39be:	9a a1       	ldd	r25, Y+34	; 0x22
    39c0:	01 97       	sbiw	r24, 0x01	; 1
    39c2:	9a a3       	std	Y+34, r25	; 0x22
    39c4:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    39c6:	89 a1       	ldd	r24, Y+33	; 0x21
    39c8:	9a a1       	ldd	r25, Y+34	; 0x22
    39ca:	00 97       	sbiw	r24, 0x00	; 0
    39cc:	69 f7       	brne	.-38     	; 0x39a8 <LCD_voidWriteBitsToSend+0x202>
    39ce:	14 c0       	rjmp	.+40     	; 0x39f8 <LCD_voidWriteBitsToSend+0x252>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    39d0:	6b a1       	ldd	r22, Y+35	; 0x23
    39d2:	7c a1       	ldd	r23, Y+36	; 0x24
    39d4:	8d a1       	ldd	r24, Y+37	; 0x25
    39d6:	9e a1       	ldd	r25, Y+38	; 0x26
    39d8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39dc:	dc 01       	movw	r26, r24
    39de:	cb 01       	movw	r24, r22
    39e0:	9a a3       	std	Y+34, r25	; 0x22
    39e2:	89 a3       	std	Y+33, r24	; 0x21
    39e4:	89 a1       	ldd	r24, Y+33	; 0x21
    39e6:	9a a1       	ldd	r25, Y+34	; 0x22
    39e8:	9e 8f       	std	Y+30, r25	; 0x1e
    39ea:	8d 8f       	std	Y+29, r24	; 0x1d
    39ec:	8d 8d       	ldd	r24, Y+29	; 0x1d
    39ee:	9e 8d       	ldd	r25, Y+30	; 0x1e
    39f0:	01 97       	sbiw	r24, 0x01	; 1
    39f2:	f1 f7       	brne	.-4      	; 0x39f0 <LCD_voidWriteBitsToSend+0x24a>
    39f4:	9e 8f       	std	Y+30, r25	; 0x1e
    39f6:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(EN_LOW_DELAY);

	DIO_voidSetPinValue(D7_PORT,D7_PIN, GET_BIT(copy_u8Byte,PIN3));
    39f8:	89 ad       	ldd	r24, Y+57	; 0x39
    39fa:	86 95       	lsr	r24
    39fc:	86 95       	lsr	r24
    39fe:	86 95       	lsr	r24
    3a00:	98 2f       	mov	r25, r24
    3a02:	91 70       	andi	r25, 0x01	; 1
    3a04:	81 e0       	ldi	r24, 0x01	; 1
    3a06:	64 e0       	ldi	r22, 0x04	; 4
    3a08:	49 2f       	mov	r20, r25
    3a0a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D6_PORT,D6_PIN, GET_BIT(copy_u8Byte,PIN2));
    3a0e:	89 ad       	ldd	r24, Y+57	; 0x39
    3a10:	86 95       	lsr	r24
    3a12:	86 95       	lsr	r24
    3a14:	98 2f       	mov	r25, r24
    3a16:	91 70       	andi	r25, 0x01	; 1
    3a18:	81 e0       	ldi	r24, 0x01	; 1
    3a1a:	62 e0       	ldi	r22, 0x02	; 2
    3a1c:	49 2f       	mov	r20, r25
    3a1e:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D5_PORT,D5_PIN, GET_BIT(copy_u8Byte,PIN1));
    3a22:	89 ad       	ldd	r24, Y+57	; 0x39
    3a24:	86 95       	lsr	r24
    3a26:	98 2f       	mov	r25, r24
    3a28:	91 70       	andi	r25, 0x01	; 1
    3a2a:	81 e0       	ldi	r24, 0x01	; 1
    3a2c:	61 e0       	ldi	r22, 0x01	; 1
    3a2e:	49 2f       	mov	r20, r25
    3a30:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D4_PORT,D4_PIN, GET_BIT(copy_u8Byte,PIN0));
    3a34:	89 ad       	ldd	r24, Y+57	; 0x39
    3a36:	98 2f       	mov	r25, r24
    3a38:	91 70       	andi	r25, 0x01	; 1
    3a3a:	81 e0       	ldi	r24, 0x01	; 1
    3a3c:	60 e0       	ldi	r22, 0x00	; 0
    3a3e:	49 2f       	mov	r20, r25
    3a40:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	DIO_voidSetPinValue(EN_PORT,EN_PIN, PIN_HIGH);
    3a44:	80 e0       	ldi	r24, 0x00	; 0
    3a46:	62 e0       	ldi	r22, 0x02	; 2
    3a48:	41 e0       	ldi	r20, 0x01	; 1
    3a4a:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    3a4e:	80 e0       	ldi	r24, 0x00	; 0
    3a50:	90 e0       	ldi	r25, 0x00	; 0
    3a52:	a0 e0       	ldi	r26, 0x00	; 0
    3a54:	b0 e4       	ldi	r27, 0x40	; 64
    3a56:	89 8f       	std	Y+25, r24	; 0x19
    3a58:	9a 8f       	std	Y+26, r25	; 0x1a
    3a5a:	ab 8f       	std	Y+27, r26	; 0x1b
    3a5c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3a5e:	69 8d       	ldd	r22, Y+25	; 0x19
    3a60:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3a62:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3a64:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3a66:	20 e0       	ldi	r18, 0x00	; 0
    3a68:	30 e0       	ldi	r19, 0x00	; 0
    3a6a:	4a e7       	ldi	r20, 0x7A	; 122
    3a6c:	55 e4       	ldi	r21, 0x45	; 69
    3a6e:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3a72:	dc 01       	movw	r26, r24
    3a74:	cb 01       	movw	r24, r22
    3a76:	8d 8b       	std	Y+21, r24	; 0x15
    3a78:	9e 8b       	std	Y+22, r25	; 0x16
    3a7a:	af 8b       	std	Y+23, r26	; 0x17
    3a7c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    3a7e:	6d 89       	ldd	r22, Y+21	; 0x15
    3a80:	7e 89       	ldd	r23, Y+22	; 0x16
    3a82:	8f 89       	ldd	r24, Y+23	; 0x17
    3a84:	98 8d       	ldd	r25, Y+24	; 0x18
    3a86:	20 e0       	ldi	r18, 0x00	; 0
    3a88:	30 e0       	ldi	r19, 0x00	; 0
    3a8a:	40 e8       	ldi	r20, 0x80	; 128
    3a8c:	5f e3       	ldi	r21, 0x3F	; 63
    3a8e:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    3a92:	88 23       	and	r24, r24
    3a94:	2c f4       	brge	.+10     	; 0x3aa0 <LCD_voidWriteBitsToSend+0x2fa>
		__ticks = 1;
    3a96:	81 e0       	ldi	r24, 0x01	; 1
    3a98:	90 e0       	ldi	r25, 0x00	; 0
    3a9a:	9c 8b       	std	Y+20, r25	; 0x14
    3a9c:	8b 8b       	std	Y+19, r24	; 0x13
    3a9e:	3f c0       	rjmp	.+126    	; 0x3b1e <LCD_voidWriteBitsToSend+0x378>
	else if (__tmp > 65535)
    3aa0:	6d 89       	ldd	r22, Y+21	; 0x15
    3aa2:	7e 89       	ldd	r23, Y+22	; 0x16
    3aa4:	8f 89       	ldd	r24, Y+23	; 0x17
    3aa6:	98 8d       	ldd	r25, Y+24	; 0x18
    3aa8:	20 e0       	ldi	r18, 0x00	; 0
    3aaa:	3f ef       	ldi	r19, 0xFF	; 255
    3aac:	4f e7       	ldi	r20, 0x7F	; 127
    3aae:	57 e4       	ldi	r21, 0x47	; 71
    3ab0:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    3ab4:	18 16       	cp	r1, r24
    3ab6:	4c f5       	brge	.+82     	; 0x3b0a <LCD_voidWriteBitsToSend+0x364>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ab8:	69 8d       	ldd	r22, Y+25	; 0x19
    3aba:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3abc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3abe:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3ac0:	20 e0       	ldi	r18, 0x00	; 0
    3ac2:	30 e0       	ldi	r19, 0x00	; 0
    3ac4:	40 e2       	ldi	r20, 0x20	; 32
    3ac6:	51 e4       	ldi	r21, 0x41	; 65
    3ac8:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3acc:	dc 01       	movw	r26, r24
    3ace:	cb 01       	movw	r24, r22
    3ad0:	bc 01       	movw	r22, r24
    3ad2:	cd 01       	movw	r24, r26
    3ad4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3ad8:	dc 01       	movw	r26, r24
    3ada:	cb 01       	movw	r24, r22
    3adc:	9c 8b       	std	Y+20, r25	; 0x14
    3ade:	8b 8b       	std	Y+19, r24	; 0x13
    3ae0:	0f c0       	rjmp	.+30     	; 0x3b00 <LCD_voidWriteBitsToSend+0x35a>
    3ae2:	80 e9       	ldi	r24, 0x90	; 144
    3ae4:	91 e0       	ldi	r25, 0x01	; 1
    3ae6:	9a 8b       	std	Y+18, r25	; 0x12
    3ae8:	89 8b       	std	Y+17, r24	; 0x11
    3aea:	89 89       	ldd	r24, Y+17	; 0x11
    3aec:	9a 89       	ldd	r25, Y+18	; 0x12
    3aee:	01 97       	sbiw	r24, 0x01	; 1
    3af0:	f1 f7       	brne	.-4      	; 0x3aee <LCD_voidWriteBitsToSend+0x348>
    3af2:	9a 8b       	std	Y+18, r25	; 0x12
    3af4:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3af6:	8b 89       	ldd	r24, Y+19	; 0x13
    3af8:	9c 89       	ldd	r25, Y+20	; 0x14
    3afa:	01 97       	sbiw	r24, 0x01	; 1
    3afc:	9c 8b       	std	Y+20, r25	; 0x14
    3afe:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3b00:	8b 89       	ldd	r24, Y+19	; 0x13
    3b02:	9c 89       	ldd	r25, Y+20	; 0x14
    3b04:	00 97       	sbiw	r24, 0x00	; 0
    3b06:	69 f7       	brne	.-38     	; 0x3ae2 <LCD_voidWriteBitsToSend+0x33c>
    3b08:	14 c0       	rjmp	.+40     	; 0x3b32 <LCD_voidWriteBitsToSend+0x38c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3b0a:	6d 89       	ldd	r22, Y+21	; 0x15
    3b0c:	7e 89       	ldd	r23, Y+22	; 0x16
    3b0e:	8f 89       	ldd	r24, Y+23	; 0x17
    3b10:	98 8d       	ldd	r25, Y+24	; 0x18
    3b12:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b16:	dc 01       	movw	r26, r24
    3b18:	cb 01       	movw	r24, r22
    3b1a:	9c 8b       	std	Y+20, r25	; 0x14
    3b1c:	8b 8b       	std	Y+19, r24	; 0x13
    3b1e:	8b 89       	ldd	r24, Y+19	; 0x13
    3b20:	9c 89       	ldd	r25, Y+20	; 0x14
    3b22:	98 8b       	std	Y+16, r25	; 0x10
    3b24:	8f 87       	std	Y+15, r24	; 0x0f
    3b26:	8f 85       	ldd	r24, Y+15	; 0x0f
    3b28:	98 89       	ldd	r25, Y+16	; 0x10
    3b2a:	01 97       	sbiw	r24, 0x01	; 1
    3b2c:	f1 f7       	brne	.-4      	; 0x3b2a <LCD_voidWriteBitsToSend+0x384>
    3b2e:	98 8b       	std	Y+16, r25	; 0x10
    3b30:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(EN_HIGH_DELAY);
	DIO_voidSetPinValue(EN_PORT,EN_PIN, PIN_LOW);
    3b32:	80 e0       	ldi	r24, 0x00	; 0
    3b34:	62 e0       	ldi	r22, 0x02	; 2
    3b36:	40 e0       	ldi	r20, 0x00	; 0
    3b38:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
    3b3c:	80 e0       	ldi	r24, 0x00	; 0
    3b3e:	90 e0       	ldi	r25, 0x00	; 0
    3b40:	a0 ea       	ldi	r26, 0xA0	; 160
    3b42:	b1 e4       	ldi	r27, 0x41	; 65
    3b44:	8b 87       	std	Y+11, r24	; 0x0b
    3b46:	9c 87       	std	Y+12, r25	; 0x0c
    3b48:	ad 87       	std	Y+13, r26	; 0x0d
    3b4a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3b4c:	6b 85       	ldd	r22, Y+11	; 0x0b
    3b4e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3b50:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b52:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b54:	20 e0       	ldi	r18, 0x00	; 0
    3b56:	30 e0       	ldi	r19, 0x00	; 0
    3b58:	4a e7       	ldi	r20, 0x7A	; 122
    3b5a:	55 e4       	ldi	r21, 0x45	; 69
    3b5c:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3b60:	dc 01       	movw	r26, r24
    3b62:	cb 01       	movw	r24, r22
    3b64:	8f 83       	std	Y+7, r24	; 0x07
    3b66:	98 87       	std	Y+8, r25	; 0x08
    3b68:	a9 87       	std	Y+9, r26	; 0x09
    3b6a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3b6c:	6f 81       	ldd	r22, Y+7	; 0x07
    3b6e:	78 85       	ldd	r23, Y+8	; 0x08
    3b70:	89 85       	ldd	r24, Y+9	; 0x09
    3b72:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b74:	20 e0       	ldi	r18, 0x00	; 0
    3b76:	30 e0       	ldi	r19, 0x00	; 0
    3b78:	40 e8       	ldi	r20, 0x80	; 128
    3b7a:	5f e3       	ldi	r21, 0x3F	; 63
    3b7c:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    3b80:	88 23       	and	r24, r24
    3b82:	2c f4       	brge	.+10     	; 0x3b8e <LCD_voidWriteBitsToSend+0x3e8>
		__ticks = 1;
    3b84:	81 e0       	ldi	r24, 0x01	; 1
    3b86:	90 e0       	ldi	r25, 0x00	; 0
    3b88:	9e 83       	std	Y+6, r25	; 0x06
    3b8a:	8d 83       	std	Y+5, r24	; 0x05
    3b8c:	3f c0       	rjmp	.+126    	; 0x3c0c <LCD_voidWriteBitsToSend+0x466>
	else if (__tmp > 65535)
    3b8e:	6f 81       	ldd	r22, Y+7	; 0x07
    3b90:	78 85       	ldd	r23, Y+8	; 0x08
    3b92:	89 85       	ldd	r24, Y+9	; 0x09
    3b94:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b96:	20 e0       	ldi	r18, 0x00	; 0
    3b98:	3f ef       	ldi	r19, 0xFF	; 255
    3b9a:	4f e7       	ldi	r20, 0x7F	; 127
    3b9c:	57 e4       	ldi	r21, 0x47	; 71
    3b9e:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    3ba2:	18 16       	cp	r1, r24
    3ba4:	4c f5       	brge	.+82     	; 0x3bf8 <LCD_voidWriteBitsToSend+0x452>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ba6:	6b 85       	ldd	r22, Y+11	; 0x0b
    3ba8:	7c 85       	ldd	r23, Y+12	; 0x0c
    3baa:	8d 85       	ldd	r24, Y+13	; 0x0d
    3bac:	9e 85       	ldd	r25, Y+14	; 0x0e
    3bae:	20 e0       	ldi	r18, 0x00	; 0
    3bb0:	30 e0       	ldi	r19, 0x00	; 0
    3bb2:	40 e2       	ldi	r20, 0x20	; 32
    3bb4:	51 e4       	ldi	r21, 0x41	; 65
    3bb6:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3bba:	dc 01       	movw	r26, r24
    3bbc:	cb 01       	movw	r24, r22
    3bbe:	bc 01       	movw	r22, r24
    3bc0:	cd 01       	movw	r24, r26
    3bc2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bc6:	dc 01       	movw	r26, r24
    3bc8:	cb 01       	movw	r24, r22
    3bca:	9e 83       	std	Y+6, r25	; 0x06
    3bcc:	8d 83       	std	Y+5, r24	; 0x05
    3bce:	0f c0       	rjmp	.+30     	; 0x3bee <LCD_voidWriteBitsToSend+0x448>
    3bd0:	80 e9       	ldi	r24, 0x90	; 144
    3bd2:	91 e0       	ldi	r25, 0x01	; 1
    3bd4:	9c 83       	std	Y+4, r25	; 0x04
    3bd6:	8b 83       	std	Y+3, r24	; 0x03
    3bd8:	8b 81       	ldd	r24, Y+3	; 0x03
    3bda:	9c 81       	ldd	r25, Y+4	; 0x04
    3bdc:	01 97       	sbiw	r24, 0x01	; 1
    3bde:	f1 f7       	brne	.-4      	; 0x3bdc <LCD_voidWriteBitsToSend+0x436>
    3be0:	9c 83       	std	Y+4, r25	; 0x04
    3be2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3be4:	8d 81       	ldd	r24, Y+5	; 0x05
    3be6:	9e 81       	ldd	r25, Y+6	; 0x06
    3be8:	01 97       	sbiw	r24, 0x01	; 1
    3bea:	9e 83       	std	Y+6, r25	; 0x06
    3bec:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3bee:	8d 81       	ldd	r24, Y+5	; 0x05
    3bf0:	9e 81       	ldd	r25, Y+6	; 0x06
    3bf2:	00 97       	sbiw	r24, 0x00	; 0
    3bf4:	69 f7       	brne	.-38     	; 0x3bd0 <LCD_voidWriteBitsToSend+0x42a>
    3bf6:	14 c0       	rjmp	.+40     	; 0x3c20 <LCD_voidWriteBitsToSend+0x47a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3bf8:	6f 81       	ldd	r22, Y+7	; 0x07
    3bfa:	78 85       	ldd	r23, Y+8	; 0x08
    3bfc:	89 85       	ldd	r24, Y+9	; 0x09
    3bfe:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c00:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3c04:	dc 01       	movw	r26, r24
    3c06:	cb 01       	movw	r24, r22
    3c08:	9e 83       	std	Y+6, r25	; 0x06
    3c0a:	8d 83       	std	Y+5, r24	; 0x05
    3c0c:	8d 81       	ldd	r24, Y+5	; 0x05
    3c0e:	9e 81       	ldd	r25, Y+6	; 0x06
    3c10:	9a 83       	std	Y+2, r25	; 0x02
    3c12:	89 83       	std	Y+1, r24	; 0x01
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
    3c18:	01 97       	sbiw	r24, 0x01	; 1
    3c1a:	f1 f7       	brne	.-4      	; 0x3c18 <LCD_voidWriteBitsToSend+0x472>
    3c1c:	9a 83       	std	Y+2, r25	; 0x02
    3c1e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(EN_LOW_DELAY);
}
    3c20:	e9 96       	adiw	r28, 0x39	; 57
    3c22:	0f b6       	in	r0, 0x3f	; 63
    3c24:	f8 94       	cli
    3c26:	de bf       	out	0x3e, r29	; 62
    3c28:	0f be       	out	0x3f, r0	; 63
    3c2a:	cd bf       	out	0x3d, r28	; 61
    3c2c:	cf 91       	pop	r28
    3c2e:	df 91       	pop	r29
    3c30:	08 95       	ret

00003c32 <LCD_voidInit>:


void LCD_voidInit(void){
    3c32:	0f 93       	push	r16
    3c34:	1f 93       	push	r17
    3c36:	df 93       	push	r29
    3c38:	cf 93       	push	r28
    3c3a:	cd b7       	in	r28, 0x3d	; 61
    3c3c:	de b7       	in	r29, 0x3e	; 62
    3c3e:	c2 56       	subi	r28, 0x62	; 98
    3c40:	d0 40       	sbci	r29, 0x00	; 0
    3c42:	0f b6       	in	r0, 0x3f	; 63
    3c44:	f8 94       	cli
    3c46:	de bf       	out	0x3e, r29	; 62
    3c48:	0f be       	out	0x3f, r0	; 63
    3c4a:	cd bf       	out	0x3d, r28	; 61
	/***I/O settings***/
	DIO_voidSetPinDirection(RS_PORT,RS_PIN,PIN_OUTPUT);
    3c4c:	80 e0       	ldi	r24, 0x00	; 0
    3c4e:	63 e0       	ldi	r22, 0x03	; 3
    3c50:	41 e0       	ldi	r20, 0x01	; 1
    3c52:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(EN_PORT, EN_PIN,PIN_OUTPUT);
    3c56:	80 e0       	ldi	r24, 0x00	; 0
    3c58:	62 e0       	ldi	r22, 0x02	; 2
    3c5a:	41 e0       	ldi	r20, 0x01	; 1
    3c5c:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(D4_PORT,D4_PIN,PIN_OUTPUT);
    3c60:	81 e0       	ldi	r24, 0x01	; 1
    3c62:	60 e0       	ldi	r22, 0x00	; 0
    3c64:	41 e0       	ldi	r20, 0x01	; 1
    3c66:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(D5_PORT,D5_PIN,PIN_OUTPUT);
    3c6a:	81 e0       	ldi	r24, 0x01	; 1
    3c6c:	61 e0       	ldi	r22, 0x01	; 1
    3c6e:	41 e0       	ldi	r20, 0x01	; 1
    3c70:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(D6_PORT,D6_PIN,PIN_OUTPUT);
    3c74:	81 e0       	ldi	r24, 0x01	; 1
    3c76:	62 e0       	ldi	r22, 0x02	; 2
    3c78:	41 e0       	ldi	r20, 0x01	; 1
    3c7a:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(D7_PORT,D7_PIN,PIN_OUTPUT);
    3c7e:	81 e0       	ldi	r24, 0x01	; 1
    3c80:	64 e0       	ldi	r22, 0x04	; 4
    3c82:	41 e0       	ldi	r20, 0x01	; 1
    3c84:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
    3c88:	fe 01       	movw	r30, r28
    3c8a:	e1 5a       	subi	r30, 0xA1	; 161
    3c8c:	ff 4f       	sbci	r31, 0xFF	; 255
    3c8e:	80 e0       	ldi	r24, 0x00	; 0
    3c90:	90 e0       	ldi	r25, 0x00	; 0
    3c92:	a0 ef       	ldi	r26, 0xF0	; 240
    3c94:	b1 e4       	ldi	r27, 0x41	; 65
    3c96:	80 83       	st	Z, r24
    3c98:	91 83       	std	Z+1, r25	; 0x01
    3c9a:	a2 83       	std	Z+2, r26	; 0x02
    3c9c:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3c9e:	8e 01       	movw	r16, r28
    3ca0:	05 5a       	subi	r16, 0xA5	; 165
    3ca2:	1f 4f       	sbci	r17, 0xFF	; 255
    3ca4:	fe 01       	movw	r30, r28
    3ca6:	e1 5a       	subi	r30, 0xA1	; 161
    3ca8:	ff 4f       	sbci	r31, 0xFF	; 255
    3caa:	60 81       	ld	r22, Z
    3cac:	71 81       	ldd	r23, Z+1	; 0x01
    3cae:	82 81       	ldd	r24, Z+2	; 0x02
    3cb0:	93 81       	ldd	r25, Z+3	; 0x03
    3cb2:	20 e0       	ldi	r18, 0x00	; 0
    3cb4:	30 e0       	ldi	r19, 0x00	; 0
    3cb6:	4a e7       	ldi	r20, 0x7A	; 122
    3cb8:	55 e4       	ldi	r21, 0x45	; 69
    3cba:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3cbe:	dc 01       	movw	r26, r24
    3cc0:	cb 01       	movw	r24, r22
    3cc2:	f8 01       	movw	r30, r16
    3cc4:	80 83       	st	Z, r24
    3cc6:	91 83       	std	Z+1, r25	; 0x01
    3cc8:	a2 83       	std	Z+2, r26	; 0x02
    3cca:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3ccc:	fe 01       	movw	r30, r28
    3cce:	e5 5a       	subi	r30, 0xA5	; 165
    3cd0:	ff 4f       	sbci	r31, 0xFF	; 255
    3cd2:	60 81       	ld	r22, Z
    3cd4:	71 81       	ldd	r23, Z+1	; 0x01
    3cd6:	82 81       	ldd	r24, Z+2	; 0x02
    3cd8:	93 81       	ldd	r25, Z+3	; 0x03
    3cda:	20 e0       	ldi	r18, 0x00	; 0
    3cdc:	30 e0       	ldi	r19, 0x00	; 0
    3cde:	40 e8       	ldi	r20, 0x80	; 128
    3ce0:	5f e3       	ldi	r21, 0x3F	; 63
    3ce2:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    3ce6:	88 23       	and	r24, r24
    3ce8:	44 f4       	brge	.+16     	; 0x3cfa <LCD_voidInit+0xc8>
		__ticks = 1;
    3cea:	fe 01       	movw	r30, r28
    3cec:	e7 5a       	subi	r30, 0xA7	; 167
    3cee:	ff 4f       	sbci	r31, 0xFF	; 255
    3cf0:	81 e0       	ldi	r24, 0x01	; 1
    3cf2:	90 e0       	ldi	r25, 0x00	; 0
    3cf4:	91 83       	std	Z+1, r25	; 0x01
    3cf6:	80 83       	st	Z, r24
    3cf8:	64 c0       	rjmp	.+200    	; 0x3dc2 <LCD_voidInit+0x190>
	else if (__tmp > 65535)
    3cfa:	fe 01       	movw	r30, r28
    3cfc:	e5 5a       	subi	r30, 0xA5	; 165
    3cfe:	ff 4f       	sbci	r31, 0xFF	; 255
    3d00:	60 81       	ld	r22, Z
    3d02:	71 81       	ldd	r23, Z+1	; 0x01
    3d04:	82 81       	ldd	r24, Z+2	; 0x02
    3d06:	93 81       	ldd	r25, Z+3	; 0x03
    3d08:	20 e0       	ldi	r18, 0x00	; 0
    3d0a:	3f ef       	ldi	r19, 0xFF	; 255
    3d0c:	4f e7       	ldi	r20, 0x7F	; 127
    3d0e:	57 e4       	ldi	r21, 0x47	; 71
    3d10:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    3d14:	18 16       	cp	r1, r24
    3d16:	0c f0       	brlt	.+2      	; 0x3d1a <LCD_voidInit+0xe8>
    3d18:	43 c0       	rjmp	.+134    	; 0x3da0 <LCD_voidInit+0x16e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3d1a:	fe 01       	movw	r30, r28
    3d1c:	e1 5a       	subi	r30, 0xA1	; 161
    3d1e:	ff 4f       	sbci	r31, 0xFF	; 255
    3d20:	60 81       	ld	r22, Z
    3d22:	71 81       	ldd	r23, Z+1	; 0x01
    3d24:	82 81       	ldd	r24, Z+2	; 0x02
    3d26:	93 81       	ldd	r25, Z+3	; 0x03
    3d28:	20 e0       	ldi	r18, 0x00	; 0
    3d2a:	30 e0       	ldi	r19, 0x00	; 0
    3d2c:	40 e2       	ldi	r20, 0x20	; 32
    3d2e:	51 e4       	ldi	r21, 0x41	; 65
    3d30:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3d34:	dc 01       	movw	r26, r24
    3d36:	cb 01       	movw	r24, r22
    3d38:	8e 01       	movw	r16, r28
    3d3a:	07 5a       	subi	r16, 0xA7	; 167
    3d3c:	1f 4f       	sbci	r17, 0xFF	; 255
    3d3e:	bc 01       	movw	r22, r24
    3d40:	cd 01       	movw	r24, r26
    3d42:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d46:	dc 01       	movw	r26, r24
    3d48:	cb 01       	movw	r24, r22
    3d4a:	f8 01       	movw	r30, r16
    3d4c:	91 83       	std	Z+1, r25	; 0x01
    3d4e:	80 83       	st	Z, r24
    3d50:	1f c0       	rjmp	.+62     	; 0x3d90 <LCD_voidInit+0x15e>
    3d52:	fe 01       	movw	r30, r28
    3d54:	e9 5a       	subi	r30, 0xA9	; 169
    3d56:	ff 4f       	sbci	r31, 0xFF	; 255
    3d58:	80 e9       	ldi	r24, 0x90	; 144
    3d5a:	91 e0       	ldi	r25, 0x01	; 1
    3d5c:	91 83       	std	Z+1, r25	; 0x01
    3d5e:	80 83       	st	Z, r24
    3d60:	fe 01       	movw	r30, r28
    3d62:	e9 5a       	subi	r30, 0xA9	; 169
    3d64:	ff 4f       	sbci	r31, 0xFF	; 255
    3d66:	80 81       	ld	r24, Z
    3d68:	91 81       	ldd	r25, Z+1	; 0x01
    3d6a:	01 97       	sbiw	r24, 0x01	; 1
    3d6c:	f1 f7       	brne	.-4      	; 0x3d6a <LCD_voidInit+0x138>
    3d6e:	fe 01       	movw	r30, r28
    3d70:	e9 5a       	subi	r30, 0xA9	; 169
    3d72:	ff 4f       	sbci	r31, 0xFF	; 255
    3d74:	91 83       	std	Z+1, r25	; 0x01
    3d76:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3d78:	de 01       	movw	r26, r28
    3d7a:	a7 5a       	subi	r26, 0xA7	; 167
    3d7c:	bf 4f       	sbci	r27, 0xFF	; 255
    3d7e:	fe 01       	movw	r30, r28
    3d80:	e7 5a       	subi	r30, 0xA7	; 167
    3d82:	ff 4f       	sbci	r31, 0xFF	; 255
    3d84:	80 81       	ld	r24, Z
    3d86:	91 81       	ldd	r25, Z+1	; 0x01
    3d88:	01 97       	sbiw	r24, 0x01	; 1
    3d8a:	11 96       	adiw	r26, 0x01	; 1
    3d8c:	9c 93       	st	X, r25
    3d8e:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3d90:	fe 01       	movw	r30, r28
    3d92:	e7 5a       	subi	r30, 0xA7	; 167
    3d94:	ff 4f       	sbci	r31, 0xFF	; 255
    3d96:	80 81       	ld	r24, Z
    3d98:	91 81       	ldd	r25, Z+1	; 0x01
    3d9a:	00 97       	sbiw	r24, 0x00	; 0
    3d9c:	d1 f6       	brne	.-76     	; 0x3d52 <LCD_voidInit+0x120>
    3d9e:	27 c0       	rjmp	.+78     	; 0x3dee <LCD_voidInit+0x1bc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3da0:	8e 01       	movw	r16, r28
    3da2:	07 5a       	subi	r16, 0xA7	; 167
    3da4:	1f 4f       	sbci	r17, 0xFF	; 255
    3da6:	fe 01       	movw	r30, r28
    3da8:	e5 5a       	subi	r30, 0xA5	; 165
    3daa:	ff 4f       	sbci	r31, 0xFF	; 255
    3dac:	60 81       	ld	r22, Z
    3dae:	71 81       	ldd	r23, Z+1	; 0x01
    3db0:	82 81       	ldd	r24, Z+2	; 0x02
    3db2:	93 81       	ldd	r25, Z+3	; 0x03
    3db4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3db8:	dc 01       	movw	r26, r24
    3dba:	cb 01       	movw	r24, r22
    3dbc:	f8 01       	movw	r30, r16
    3dbe:	91 83       	std	Z+1, r25	; 0x01
    3dc0:	80 83       	st	Z, r24
    3dc2:	de 01       	movw	r26, r28
    3dc4:	ab 5a       	subi	r26, 0xAB	; 171
    3dc6:	bf 4f       	sbci	r27, 0xFF	; 255
    3dc8:	fe 01       	movw	r30, r28
    3dca:	e7 5a       	subi	r30, 0xA7	; 167
    3dcc:	ff 4f       	sbci	r31, 0xFF	; 255
    3dce:	80 81       	ld	r24, Z
    3dd0:	91 81       	ldd	r25, Z+1	; 0x01
    3dd2:	8d 93       	st	X+, r24
    3dd4:	9c 93       	st	X, r25
    3dd6:	fe 01       	movw	r30, r28
    3dd8:	eb 5a       	subi	r30, 0xAB	; 171
    3dda:	ff 4f       	sbci	r31, 0xFF	; 255
    3ddc:	80 81       	ld	r24, Z
    3dde:	91 81       	ldd	r25, Z+1	; 0x01
    3de0:	01 97       	sbiw	r24, 0x01	; 1
    3de2:	f1 f7       	brne	.-4      	; 0x3de0 <LCD_voidInit+0x1ae>
    3de4:	fe 01       	movw	r30, r28
    3de6:	eb 5a       	subi	r30, 0xAB	; 171
    3de8:	ff 4f       	sbci	r31, 0xFF	; 255
    3dea:	91 83       	std	Z+1, r25	; 0x01
    3dec:	80 83       	st	Z, r24

    /***LCD Init***/
	_delay_ms(30);
	LCD_voidWriteCommand(LCD_INIT_CMD);
    3dee:	82 e0       	ldi	r24, 0x02	; 2
    3df0:	0e 94 27 22 	call	0x444e	; 0x444e <LCD_voidWriteCommand>
    3df4:	fe 01       	movw	r30, r28
    3df6:	ef 5a       	subi	r30, 0xAF	; 175
    3df8:	ff 4f       	sbci	r31, 0xFF	; 255
    3dfa:	80 e0       	ldi	r24, 0x00	; 0
    3dfc:	90 e0       	ldi	r25, 0x00	; 0
    3dfe:	a0 e0       	ldi	r26, 0x00	; 0
    3e00:	b0 e4       	ldi	r27, 0x40	; 64
    3e02:	80 83       	st	Z, r24
    3e04:	91 83       	std	Z+1, r25	; 0x01
    3e06:	a2 83       	std	Z+2, r26	; 0x02
    3e08:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3e0a:	8e 01       	movw	r16, r28
    3e0c:	03 5b       	subi	r16, 0xB3	; 179
    3e0e:	1f 4f       	sbci	r17, 0xFF	; 255
    3e10:	fe 01       	movw	r30, r28
    3e12:	ef 5a       	subi	r30, 0xAF	; 175
    3e14:	ff 4f       	sbci	r31, 0xFF	; 255
    3e16:	60 81       	ld	r22, Z
    3e18:	71 81       	ldd	r23, Z+1	; 0x01
    3e1a:	82 81       	ldd	r24, Z+2	; 0x02
    3e1c:	93 81       	ldd	r25, Z+3	; 0x03
    3e1e:	20 e0       	ldi	r18, 0x00	; 0
    3e20:	30 e0       	ldi	r19, 0x00	; 0
    3e22:	4a e7       	ldi	r20, 0x7A	; 122
    3e24:	55 e4       	ldi	r21, 0x45	; 69
    3e26:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3e2a:	dc 01       	movw	r26, r24
    3e2c:	cb 01       	movw	r24, r22
    3e2e:	f8 01       	movw	r30, r16
    3e30:	80 83       	st	Z, r24
    3e32:	91 83       	std	Z+1, r25	; 0x01
    3e34:	a2 83       	std	Z+2, r26	; 0x02
    3e36:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3e38:	fe 01       	movw	r30, r28
    3e3a:	e3 5b       	subi	r30, 0xB3	; 179
    3e3c:	ff 4f       	sbci	r31, 0xFF	; 255
    3e3e:	60 81       	ld	r22, Z
    3e40:	71 81       	ldd	r23, Z+1	; 0x01
    3e42:	82 81       	ldd	r24, Z+2	; 0x02
    3e44:	93 81       	ldd	r25, Z+3	; 0x03
    3e46:	20 e0       	ldi	r18, 0x00	; 0
    3e48:	30 e0       	ldi	r19, 0x00	; 0
    3e4a:	40 e8       	ldi	r20, 0x80	; 128
    3e4c:	5f e3       	ldi	r21, 0x3F	; 63
    3e4e:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    3e52:	88 23       	and	r24, r24
    3e54:	44 f4       	brge	.+16     	; 0x3e66 <LCD_voidInit+0x234>
		__ticks = 1;
    3e56:	fe 01       	movw	r30, r28
    3e58:	e5 5b       	subi	r30, 0xB5	; 181
    3e5a:	ff 4f       	sbci	r31, 0xFF	; 255
    3e5c:	81 e0       	ldi	r24, 0x01	; 1
    3e5e:	90 e0       	ldi	r25, 0x00	; 0
    3e60:	91 83       	std	Z+1, r25	; 0x01
    3e62:	80 83       	st	Z, r24
    3e64:	64 c0       	rjmp	.+200    	; 0x3f2e <LCD_voidInit+0x2fc>
	else if (__tmp > 65535)
    3e66:	fe 01       	movw	r30, r28
    3e68:	e3 5b       	subi	r30, 0xB3	; 179
    3e6a:	ff 4f       	sbci	r31, 0xFF	; 255
    3e6c:	60 81       	ld	r22, Z
    3e6e:	71 81       	ldd	r23, Z+1	; 0x01
    3e70:	82 81       	ldd	r24, Z+2	; 0x02
    3e72:	93 81       	ldd	r25, Z+3	; 0x03
    3e74:	20 e0       	ldi	r18, 0x00	; 0
    3e76:	3f ef       	ldi	r19, 0xFF	; 255
    3e78:	4f e7       	ldi	r20, 0x7F	; 127
    3e7a:	57 e4       	ldi	r21, 0x47	; 71
    3e7c:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    3e80:	18 16       	cp	r1, r24
    3e82:	0c f0       	brlt	.+2      	; 0x3e86 <LCD_voidInit+0x254>
    3e84:	43 c0       	rjmp	.+134    	; 0x3f0c <LCD_voidInit+0x2da>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3e86:	fe 01       	movw	r30, r28
    3e88:	ef 5a       	subi	r30, 0xAF	; 175
    3e8a:	ff 4f       	sbci	r31, 0xFF	; 255
    3e8c:	60 81       	ld	r22, Z
    3e8e:	71 81       	ldd	r23, Z+1	; 0x01
    3e90:	82 81       	ldd	r24, Z+2	; 0x02
    3e92:	93 81       	ldd	r25, Z+3	; 0x03
    3e94:	20 e0       	ldi	r18, 0x00	; 0
    3e96:	30 e0       	ldi	r19, 0x00	; 0
    3e98:	40 e2       	ldi	r20, 0x20	; 32
    3e9a:	51 e4       	ldi	r21, 0x41	; 65
    3e9c:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3ea0:	dc 01       	movw	r26, r24
    3ea2:	cb 01       	movw	r24, r22
    3ea4:	8e 01       	movw	r16, r28
    3ea6:	05 5b       	subi	r16, 0xB5	; 181
    3ea8:	1f 4f       	sbci	r17, 0xFF	; 255
    3eaa:	bc 01       	movw	r22, r24
    3eac:	cd 01       	movw	r24, r26
    3eae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3eb2:	dc 01       	movw	r26, r24
    3eb4:	cb 01       	movw	r24, r22
    3eb6:	f8 01       	movw	r30, r16
    3eb8:	91 83       	std	Z+1, r25	; 0x01
    3eba:	80 83       	st	Z, r24
    3ebc:	1f c0       	rjmp	.+62     	; 0x3efc <LCD_voidInit+0x2ca>
    3ebe:	fe 01       	movw	r30, r28
    3ec0:	e7 5b       	subi	r30, 0xB7	; 183
    3ec2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ec4:	80 e9       	ldi	r24, 0x90	; 144
    3ec6:	91 e0       	ldi	r25, 0x01	; 1
    3ec8:	91 83       	std	Z+1, r25	; 0x01
    3eca:	80 83       	st	Z, r24
    3ecc:	fe 01       	movw	r30, r28
    3ece:	e7 5b       	subi	r30, 0xB7	; 183
    3ed0:	ff 4f       	sbci	r31, 0xFF	; 255
    3ed2:	80 81       	ld	r24, Z
    3ed4:	91 81       	ldd	r25, Z+1	; 0x01
    3ed6:	01 97       	sbiw	r24, 0x01	; 1
    3ed8:	f1 f7       	brne	.-4      	; 0x3ed6 <LCD_voidInit+0x2a4>
    3eda:	fe 01       	movw	r30, r28
    3edc:	e7 5b       	subi	r30, 0xB7	; 183
    3ede:	ff 4f       	sbci	r31, 0xFF	; 255
    3ee0:	91 83       	std	Z+1, r25	; 0x01
    3ee2:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3ee4:	de 01       	movw	r26, r28
    3ee6:	a5 5b       	subi	r26, 0xB5	; 181
    3ee8:	bf 4f       	sbci	r27, 0xFF	; 255
    3eea:	fe 01       	movw	r30, r28
    3eec:	e5 5b       	subi	r30, 0xB5	; 181
    3eee:	ff 4f       	sbci	r31, 0xFF	; 255
    3ef0:	80 81       	ld	r24, Z
    3ef2:	91 81       	ldd	r25, Z+1	; 0x01
    3ef4:	01 97       	sbiw	r24, 0x01	; 1
    3ef6:	11 96       	adiw	r26, 0x01	; 1
    3ef8:	9c 93       	st	X, r25
    3efa:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3efc:	fe 01       	movw	r30, r28
    3efe:	e5 5b       	subi	r30, 0xB5	; 181
    3f00:	ff 4f       	sbci	r31, 0xFF	; 255
    3f02:	80 81       	ld	r24, Z
    3f04:	91 81       	ldd	r25, Z+1	; 0x01
    3f06:	00 97       	sbiw	r24, 0x00	; 0
    3f08:	d1 f6       	brne	.-76     	; 0x3ebe <LCD_voidInit+0x28c>
    3f0a:	27 c0       	rjmp	.+78     	; 0x3f5a <LCD_voidInit+0x328>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f0c:	8e 01       	movw	r16, r28
    3f0e:	05 5b       	subi	r16, 0xB5	; 181
    3f10:	1f 4f       	sbci	r17, 0xFF	; 255
    3f12:	fe 01       	movw	r30, r28
    3f14:	e3 5b       	subi	r30, 0xB3	; 179
    3f16:	ff 4f       	sbci	r31, 0xFF	; 255
    3f18:	60 81       	ld	r22, Z
    3f1a:	71 81       	ldd	r23, Z+1	; 0x01
    3f1c:	82 81       	ldd	r24, Z+2	; 0x02
    3f1e:	93 81       	ldd	r25, Z+3	; 0x03
    3f20:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f24:	dc 01       	movw	r26, r24
    3f26:	cb 01       	movw	r24, r22
    3f28:	f8 01       	movw	r30, r16
    3f2a:	91 83       	std	Z+1, r25	; 0x01
    3f2c:	80 83       	st	Z, r24
    3f2e:	de 01       	movw	r26, r28
    3f30:	a9 5b       	subi	r26, 0xB9	; 185
    3f32:	bf 4f       	sbci	r27, 0xFF	; 255
    3f34:	fe 01       	movw	r30, r28
    3f36:	e5 5b       	subi	r30, 0xB5	; 181
    3f38:	ff 4f       	sbci	r31, 0xFF	; 255
    3f3a:	80 81       	ld	r24, Z
    3f3c:	91 81       	ldd	r25, Z+1	; 0x01
    3f3e:	8d 93       	st	X+, r24
    3f40:	9c 93       	st	X, r25
    3f42:	fe 01       	movw	r30, r28
    3f44:	e9 5b       	subi	r30, 0xB9	; 185
    3f46:	ff 4f       	sbci	r31, 0xFF	; 255
    3f48:	80 81       	ld	r24, Z
    3f4a:	91 81       	ldd	r25, Z+1	; 0x01
    3f4c:	01 97       	sbiw	r24, 0x01	; 1
    3f4e:	f1 f7       	brne	.-4      	; 0x3f4c <LCD_voidInit+0x31a>
    3f50:	fe 01       	movw	r30, r28
    3f52:	e9 5b       	subi	r30, 0xB9	; 185
    3f54:	ff 4f       	sbci	r31, 0xFF	; 255
    3f56:	91 83       	std	Z+1, r25	; 0x01
    3f58:	80 83       	st	Z, r24
	_delay_ms(2);
	LCD_voidWriteCommand(FUNCTION_SET);
    3f5a:	88 e2       	ldi	r24, 0x28	; 40
    3f5c:	0e 94 27 22 	call	0x444e	; 0x444e <LCD_voidWriteCommand>
    3f60:	fe 01       	movw	r30, r28
    3f62:	ed 5b       	subi	r30, 0xBD	; 189
    3f64:	ff 4f       	sbci	r31, 0xFF	; 255
    3f66:	80 e0       	ldi	r24, 0x00	; 0
    3f68:	90 e0       	ldi	r25, 0x00	; 0
    3f6a:	a0 e0       	ldi	r26, 0x00	; 0
    3f6c:	b0 e4       	ldi	r27, 0x40	; 64
    3f6e:	80 83       	st	Z, r24
    3f70:	91 83       	std	Z+1, r25	; 0x01
    3f72:	a2 83       	std	Z+2, r26	; 0x02
    3f74:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3f76:	8e 01       	movw	r16, r28
    3f78:	01 5c       	subi	r16, 0xC1	; 193
    3f7a:	1f 4f       	sbci	r17, 0xFF	; 255
    3f7c:	fe 01       	movw	r30, r28
    3f7e:	ed 5b       	subi	r30, 0xBD	; 189
    3f80:	ff 4f       	sbci	r31, 0xFF	; 255
    3f82:	60 81       	ld	r22, Z
    3f84:	71 81       	ldd	r23, Z+1	; 0x01
    3f86:	82 81       	ldd	r24, Z+2	; 0x02
    3f88:	93 81       	ldd	r25, Z+3	; 0x03
    3f8a:	20 e0       	ldi	r18, 0x00	; 0
    3f8c:	30 e0       	ldi	r19, 0x00	; 0
    3f8e:	4a e7       	ldi	r20, 0x7A	; 122
    3f90:	55 e4       	ldi	r21, 0x45	; 69
    3f92:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    3f96:	dc 01       	movw	r26, r24
    3f98:	cb 01       	movw	r24, r22
    3f9a:	f8 01       	movw	r30, r16
    3f9c:	80 83       	st	Z, r24
    3f9e:	91 83       	std	Z+1, r25	; 0x01
    3fa0:	a2 83       	std	Z+2, r26	; 0x02
    3fa2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3fa4:	fe 01       	movw	r30, r28
    3fa6:	ff 96       	adiw	r30, 0x3f	; 63
    3fa8:	60 81       	ld	r22, Z
    3faa:	71 81       	ldd	r23, Z+1	; 0x01
    3fac:	82 81       	ldd	r24, Z+2	; 0x02
    3fae:	93 81       	ldd	r25, Z+3	; 0x03
    3fb0:	20 e0       	ldi	r18, 0x00	; 0
    3fb2:	30 e0       	ldi	r19, 0x00	; 0
    3fb4:	40 e8       	ldi	r20, 0x80	; 128
    3fb6:	5f e3       	ldi	r21, 0x3F	; 63
    3fb8:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    3fbc:	88 23       	and	r24, r24
    3fbe:	2c f4       	brge	.+10     	; 0x3fca <LCD_voidInit+0x398>
		__ticks = 1;
    3fc0:	81 e0       	ldi	r24, 0x01	; 1
    3fc2:	90 e0       	ldi	r25, 0x00	; 0
    3fc4:	9e af       	std	Y+62, r25	; 0x3e
    3fc6:	8d af       	std	Y+61, r24	; 0x3d
    3fc8:	46 c0       	rjmp	.+140    	; 0x4056 <LCD_voidInit+0x424>
	else if (__tmp > 65535)
    3fca:	fe 01       	movw	r30, r28
    3fcc:	ff 96       	adiw	r30, 0x3f	; 63
    3fce:	60 81       	ld	r22, Z
    3fd0:	71 81       	ldd	r23, Z+1	; 0x01
    3fd2:	82 81       	ldd	r24, Z+2	; 0x02
    3fd4:	93 81       	ldd	r25, Z+3	; 0x03
    3fd6:	20 e0       	ldi	r18, 0x00	; 0
    3fd8:	3f ef       	ldi	r19, 0xFF	; 255
    3fda:	4f e7       	ldi	r20, 0x7F	; 127
    3fdc:	57 e4       	ldi	r21, 0x47	; 71
    3fde:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    3fe2:	18 16       	cp	r1, r24
    3fe4:	64 f5       	brge	.+88     	; 0x403e <LCD_voidInit+0x40c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3fe6:	fe 01       	movw	r30, r28
    3fe8:	ed 5b       	subi	r30, 0xBD	; 189
    3fea:	ff 4f       	sbci	r31, 0xFF	; 255
    3fec:	60 81       	ld	r22, Z
    3fee:	71 81       	ldd	r23, Z+1	; 0x01
    3ff0:	82 81       	ldd	r24, Z+2	; 0x02
    3ff2:	93 81       	ldd	r25, Z+3	; 0x03
    3ff4:	20 e0       	ldi	r18, 0x00	; 0
    3ff6:	30 e0       	ldi	r19, 0x00	; 0
    3ff8:	40 e2       	ldi	r20, 0x20	; 32
    3ffa:	51 e4       	ldi	r21, 0x41	; 65
    3ffc:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    4000:	dc 01       	movw	r26, r24
    4002:	cb 01       	movw	r24, r22
    4004:	bc 01       	movw	r22, r24
    4006:	cd 01       	movw	r24, r26
    4008:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    400c:	dc 01       	movw	r26, r24
    400e:	cb 01       	movw	r24, r22
    4010:	9e af       	std	Y+62, r25	; 0x3e
    4012:	8d af       	std	Y+61, r24	; 0x3d
    4014:	0f c0       	rjmp	.+30     	; 0x4034 <LCD_voidInit+0x402>
    4016:	80 e9       	ldi	r24, 0x90	; 144
    4018:	91 e0       	ldi	r25, 0x01	; 1
    401a:	9c af       	std	Y+60, r25	; 0x3c
    401c:	8b af       	std	Y+59, r24	; 0x3b
    401e:	8b ad       	ldd	r24, Y+59	; 0x3b
    4020:	9c ad       	ldd	r25, Y+60	; 0x3c
    4022:	01 97       	sbiw	r24, 0x01	; 1
    4024:	f1 f7       	brne	.-4      	; 0x4022 <LCD_voidInit+0x3f0>
    4026:	9c af       	std	Y+60, r25	; 0x3c
    4028:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    402a:	8d ad       	ldd	r24, Y+61	; 0x3d
    402c:	9e ad       	ldd	r25, Y+62	; 0x3e
    402e:	01 97       	sbiw	r24, 0x01	; 1
    4030:	9e af       	std	Y+62, r25	; 0x3e
    4032:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4034:	8d ad       	ldd	r24, Y+61	; 0x3d
    4036:	9e ad       	ldd	r25, Y+62	; 0x3e
    4038:	00 97       	sbiw	r24, 0x00	; 0
    403a:	69 f7       	brne	.-38     	; 0x4016 <LCD_voidInit+0x3e4>
    403c:	16 c0       	rjmp	.+44     	; 0x406a <LCD_voidInit+0x438>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    403e:	fe 01       	movw	r30, r28
    4040:	ff 96       	adiw	r30, 0x3f	; 63
    4042:	60 81       	ld	r22, Z
    4044:	71 81       	ldd	r23, Z+1	; 0x01
    4046:	82 81       	ldd	r24, Z+2	; 0x02
    4048:	93 81       	ldd	r25, Z+3	; 0x03
    404a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    404e:	dc 01       	movw	r26, r24
    4050:	cb 01       	movw	r24, r22
    4052:	9e af       	std	Y+62, r25	; 0x3e
    4054:	8d af       	std	Y+61, r24	; 0x3d
    4056:	8d ad       	ldd	r24, Y+61	; 0x3d
    4058:	9e ad       	ldd	r25, Y+62	; 0x3e
    405a:	9a af       	std	Y+58, r25	; 0x3a
    405c:	89 af       	std	Y+57, r24	; 0x39
    405e:	89 ad       	ldd	r24, Y+57	; 0x39
    4060:	9a ad       	ldd	r25, Y+58	; 0x3a
    4062:	01 97       	sbiw	r24, 0x01	; 1
    4064:	f1 f7       	brne	.-4      	; 0x4062 <LCD_voidInit+0x430>
    4066:	9a af       	std	Y+58, r25	; 0x3a
    4068:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(2);
	LCD_voidWriteCommand(DISPLAY_SETTINGS);
    406a:	8c e0       	ldi	r24, 0x0C	; 12
    406c:	0e 94 27 22 	call	0x444e	; 0x444e <LCD_voidWriteCommand>
    4070:	80 e0       	ldi	r24, 0x00	; 0
    4072:	90 e0       	ldi	r25, 0x00	; 0
    4074:	a0 e0       	ldi	r26, 0x00	; 0
    4076:	b0 e4       	ldi	r27, 0x40	; 64
    4078:	8d ab       	std	Y+53, r24	; 0x35
    407a:	9e ab       	std	Y+54, r25	; 0x36
    407c:	af ab       	std	Y+55, r26	; 0x37
    407e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4080:	6d a9       	ldd	r22, Y+53	; 0x35
    4082:	7e a9       	ldd	r23, Y+54	; 0x36
    4084:	8f a9       	ldd	r24, Y+55	; 0x37
    4086:	98 ad       	ldd	r25, Y+56	; 0x38
    4088:	20 e0       	ldi	r18, 0x00	; 0
    408a:	30 e0       	ldi	r19, 0x00	; 0
    408c:	4a e7       	ldi	r20, 0x7A	; 122
    408e:	55 e4       	ldi	r21, 0x45	; 69
    4090:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    4094:	dc 01       	movw	r26, r24
    4096:	cb 01       	movw	r24, r22
    4098:	89 ab       	std	Y+49, r24	; 0x31
    409a:	9a ab       	std	Y+50, r25	; 0x32
    409c:	ab ab       	std	Y+51, r26	; 0x33
    409e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    40a0:	69 a9       	ldd	r22, Y+49	; 0x31
    40a2:	7a a9       	ldd	r23, Y+50	; 0x32
    40a4:	8b a9       	ldd	r24, Y+51	; 0x33
    40a6:	9c a9       	ldd	r25, Y+52	; 0x34
    40a8:	20 e0       	ldi	r18, 0x00	; 0
    40aa:	30 e0       	ldi	r19, 0x00	; 0
    40ac:	40 e8       	ldi	r20, 0x80	; 128
    40ae:	5f e3       	ldi	r21, 0x3F	; 63
    40b0:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    40b4:	88 23       	and	r24, r24
    40b6:	2c f4       	brge	.+10     	; 0x40c2 <LCD_voidInit+0x490>
		__ticks = 1;
    40b8:	81 e0       	ldi	r24, 0x01	; 1
    40ba:	90 e0       	ldi	r25, 0x00	; 0
    40bc:	98 ab       	std	Y+48, r25	; 0x30
    40be:	8f a7       	std	Y+47, r24	; 0x2f
    40c0:	3f c0       	rjmp	.+126    	; 0x4140 <LCD_voidInit+0x50e>
	else if (__tmp > 65535)
    40c2:	69 a9       	ldd	r22, Y+49	; 0x31
    40c4:	7a a9       	ldd	r23, Y+50	; 0x32
    40c6:	8b a9       	ldd	r24, Y+51	; 0x33
    40c8:	9c a9       	ldd	r25, Y+52	; 0x34
    40ca:	20 e0       	ldi	r18, 0x00	; 0
    40cc:	3f ef       	ldi	r19, 0xFF	; 255
    40ce:	4f e7       	ldi	r20, 0x7F	; 127
    40d0:	57 e4       	ldi	r21, 0x47	; 71
    40d2:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    40d6:	18 16       	cp	r1, r24
    40d8:	4c f5       	brge	.+82     	; 0x412c <LCD_voidInit+0x4fa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    40da:	6d a9       	ldd	r22, Y+53	; 0x35
    40dc:	7e a9       	ldd	r23, Y+54	; 0x36
    40de:	8f a9       	ldd	r24, Y+55	; 0x37
    40e0:	98 ad       	ldd	r25, Y+56	; 0x38
    40e2:	20 e0       	ldi	r18, 0x00	; 0
    40e4:	30 e0       	ldi	r19, 0x00	; 0
    40e6:	40 e2       	ldi	r20, 0x20	; 32
    40e8:	51 e4       	ldi	r21, 0x41	; 65
    40ea:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    40ee:	dc 01       	movw	r26, r24
    40f0:	cb 01       	movw	r24, r22
    40f2:	bc 01       	movw	r22, r24
    40f4:	cd 01       	movw	r24, r26
    40f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    40fa:	dc 01       	movw	r26, r24
    40fc:	cb 01       	movw	r24, r22
    40fe:	98 ab       	std	Y+48, r25	; 0x30
    4100:	8f a7       	std	Y+47, r24	; 0x2f
    4102:	0f c0       	rjmp	.+30     	; 0x4122 <LCD_voidInit+0x4f0>
    4104:	80 e9       	ldi	r24, 0x90	; 144
    4106:	91 e0       	ldi	r25, 0x01	; 1
    4108:	9e a7       	std	Y+46, r25	; 0x2e
    410a:	8d a7       	std	Y+45, r24	; 0x2d
    410c:	8d a5       	ldd	r24, Y+45	; 0x2d
    410e:	9e a5       	ldd	r25, Y+46	; 0x2e
    4110:	01 97       	sbiw	r24, 0x01	; 1
    4112:	f1 f7       	brne	.-4      	; 0x4110 <LCD_voidInit+0x4de>
    4114:	9e a7       	std	Y+46, r25	; 0x2e
    4116:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4118:	8f a5       	ldd	r24, Y+47	; 0x2f
    411a:	98 a9       	ldd	r25, Y+48	; 0x30
    411c:	01 97       	sbiw	r24, 0x01	; 1
    411e:	98 ab       	std	Y+48, r25	; 0x30
    4120:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4122:	8f a5       	ldd	r24, Y+47	; 0x2f
    4124:	98 a9       	ldd	r25, Y+48	; 0x30
    4126:	00 97       	sbiw	r24, 0x00	; 0
    4128:	69 f7       	brne	.-38     	; 0x4104 <LCD_voidInit+0x4d2>
    412a:	14 c0       	rjmp	.+40     	; 0x4154 <LCD_voidInit+0x522>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    412c:	69 a9       	ldd	r22, Y+49	; 0x31
    412e:	7a a9       	ldd	r23, Y+50	; 0x32
    4130:	8b a9       	ldd	r24, Y+51	; 0x33
    4132:	9c a9       	ldd	r25, Y+52	; 0x34
    4134:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4138:	dc 01       	movw	r26, r24
    413a:	cb 01       	movw	r24, r22
    413c:	98 ab       	std	Y+48, r25	; 0x30
    413e:	8f a7       	std	Y+47, r24	; 0x2f
    4140:	8f a5       	ldd	r24, Y+47	; 0x2f
    4142:	98 a9       	ldd	r25, Y+48	; 0x30
    4144:	9c a7       	std	Y+44, r25	; 0x2c
    4146:	8b a7       	std	Y+43, r24	; 0x2b
    4148:	8b a5       	ldd	r24, Y+43	; 0x2b
    414a:	9c a5       	ldd	r25, Y+44	; 0x2c
    414c:	01 97       	sbiw	r24, 0x01	; 1
    414e:	f1 f7       	brne	.-4      	; 0x414c <LCD_voidInit+0x51a>
    4150:	9c a7       	std	Y+44, r25	; 0x2c
    4152:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(2);
	LCD_voidWriteCommand(DISPLAY_CLEAR);
    4154:	81 e0       	ldi	r24, 0x01	; 1
    4156:	0e 94 27 22 	call	0x444e	; 0x444e <LCD_voidWriteCommand>
    415a:	80 e0       	ldi	r24, 0x00	; 0
    415c:	90 e0       	ldi	r25, 0x00	; 0
    415e:	a0 e0       	ldi	r26, 0x00	; 0
    4160:	b0 e4       	ldi	r27, 0x40	; 64
    4162:	8f a3       	std	Y+39, r24	; 0x27
    4164:	98 a7       	std	Y+40, r25	; 0x28
    4166:	a9 a7       	std	Y+41, r26	; 0x29
    4168:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    416a:	6f a1       	ldd	r22, Y+39	; 0x27
    416c:	78 a5       	ldd	r23, Y+40	; 0x28
    416e:	89 a5       	ldd	r24, Y+41	; 0x29
    4170:	9a a5       	ldd	r25, Y+42	; 0x2a
    4172:	20 e0       	ldi	r18, 0x00	; 0
    4174:	30 e0       	ldi	r19, 0x00	; 0
    4176:	4a e7       	ldi	r20, 0x7A	; 122
    4178:	55 e4       	ldi	r21, 0x45	; 69
    417a:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    417e:	dc 01       	movw	r26, r24
    4180:	cb 01       	movw	r24, r22
    4182:	8b a3       	std	Y+35, r24	; 0x23
    4184:	9c a3       	std	Y+36, r25	; 0x24
    4186:	ad a3       	std	Y+37, r26	; 0x25
    4188:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    418a:	6b a1       	ldd	r22, Y+35	; 0x23
    418c:	7c a1       	ldd	r23, Y+36	; 0x24
    418e:	8d a1       	ldd	r24, Y+37	; 0x25
    4190:	9e a1       	ldd	r25, Y+38	; 0x26
    4192:	20 e0       	ldi	r18, 0x00	; 0
    4194:	30 e0       	ldi	r19, 0x00	; 0
    4196:	40 e8       	ldi	r20, 0x80	; 128
    4198:	5f e3       	ldi	r21, 0x3F	; 63
    419a:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    419e:	88 23       	and	r24, r24
    41a0:	2c f4       	brge	.+10     	; 0x41ac <LCD_voidInit+0x57a>
		__ticks = 1;
    41a2:	81 e0       	ldi	r24, 0x01	; 1
    41a4:	90 e0       	ldi	r25, 0x00	; 0
    41a6:	9a a3       	std	Y+34, r25	; 0x22
    41a8:	89 a3       	std	Y+33, r24	; 0x21
    41aa:	3f c0       	rjmp	.+126    	; 0x422a <LCD_voidInit+0x5f8>
	else if (__tmp > 65535)
    41ac:	6b a1       	ldd	r22, Y+35	; 0x23
    41ae:	7c a1       	ldd	r23, Y+36	; 0x24
    41b0:	8d a1       	ldd	r24, Y+37	; 0x25
    41b2:	9e a1       	ldd	r25, Y+38	; 0x26
    41b4:	20 e0       	ldi	r18, 0x00	; 0
    41b6:	3f ef       	ldi	r19, 0xFF	; 255
    41b8:	4f e7       	ldi	r20, 0x7F	; 127
    41ba:	57 e4       	ldi	r21, 0x47	; 71
    41bc:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    41c0:	18 16       	cp	r1, r24
    41c2:	4c f5       	brge	.+82     	; 0x4216 <LCD_voidInit+0x5e4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    41c4:	6f a1       	ldd	r22, Y+39	; 0x27
    41c6:	78 a5       	ldd	r23, Y+40	; 0x28
    41c8:	89 a5       	ldd	r24, Y+41	; 0x29
    41ca:	9a a5       	ldd	r25, Y+42	; 0x2a
    41cc:	20 e0       	ldi	r18, 0x00	; 0
    41ce:	30 e0       	ldi	r19, 0x00	; 0
    41d0:	40 e2       	ldi	r20, 0x20	; 32
    41d2:	51 e4       	ldi	r21, 0x41	; 65
    41d4:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    41d8:	dc 01       	movw	r26, r24
    41da:	cb 01       	movw	r24, r22
    41dc:	bc 01       	movw	r22, r24
    41de:	cd 01       	movw	r24, r26
    41e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41e4:	dc 01       	movw	r26, r24
    41e6:	cb 01       	movw	r24, r22
    41e8:	9a a3       	std	Y+34, r25	; 0x22
    41ea:	89 a3       	std	Y+33, r24	; 0x21
    41ec:	0f c0       	rjmp	.+30     	; 0x420c <LCD_voidInit+0x5da>
    41ee:	80 e9       	ldi	r24, 0x90	; 144
    41f0:	91 e0       	ldi	r25, 0x01	; 1
    41f2:	98 a3       	std	Y+32, r25	; 0x20
    41f4:	8f 8f       	std	Y+31, r24	; 0x1f
    41f6:	8f 8d       	ldd	r24, Y+31	; 0x1f
    41f8:	98 a1       	ldd	r25, Y+32	; 0x20
    41fa:	01 97       	sbiw	r24, 0x01	; 1
    41fc:	f1 f7       	brne	.-4      	; 0x41fa <LCD_voidInit+0x5c8>
    41fe:	98 a3       	std	Y+32, r25	; 0x20
    4200:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4202:	89 a1       	ldd	r24, Y+33	; 0x21
    4204:	9a a1       	ldd	r25, Y+34	; 0x22
    4206:	01 97       	sbiw	r24, 0x01	; 1
    4208:	9a a3       	std	Y+34, r25	; 0x22
    420a:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    420c:	89 a1       	ldd	r24, Y+33	; 0x21
    420e:	9a a1       	ldd	r25, Y+34	; 0x22
    4210:	00 97       	sbiw	r24, 0x00	; 0
    4212:	69 f7       	brne	.-38     	; 0x41ee <LCD_voidInit+0x5bc>
    4214:	14 c0       	rjmp	.+40     	; 0x423e <LCD_voidInit+0x60c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4216:	6b a1       	ldd	r22, Y+35	; 0x23
    4218:	7c a1       	ldd	r23, Y+36	; 0x24
    421a:	8d a1       	ldd	r24, Y+37	; 0x25
    421c:	9e a1       	ldd	r25, Y+38	; 0x26
    421e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4222:	dc 01       	movw	r26, r24
    4224:	cb 01       	movw	r24, r22
    4226:	9a a3       	std	Y+34, r25	; 0x22
    4228:	89 a3       	std	Y+33, r24	; 0x21
    422a:	89 a1       	ldd	r24, Y+33	; 0x21
    422c:	9a a1       	ldd	r25, Y+34	; 0x22
    422e:	9e 8f       	std	Y+30, r25	; 0x1e
    4230:	8d 8f       	std	Y+29, r24	; 0x1d
    4232:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4234:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4236:	01 97       	sbiw	r24, 0x01	; 1
    4238:	f1 f7       	brne	.-4      	; 0x4236 <LCD_voidInit+0x604>
    423a:	9e 8f       	std	Y+30, r25	; 0x1e
    423c:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);
	LCD_voidWriteCommand(ENTRY_MODE_SET);
    423e:	86 e0       	ldi	r24, 0x06	; 6
    4240:	0e 94 27 22 	call	0x444e	; 0x444e <LCD_voidWriteCommand>
    4244:	80 e0       	ldi	r24, 0x00	; 0
    4246:	90 e0       	ldi	r25, 0x00	; 0
    4248:	a0 e0       	ldi	r26, 0x00	; 0
    424a:	b0 e4       	ldi	r27, 0x40	; 64
    424c:	89 8f       	std	Y+25, r24	; 0x19
    424e:	9a 8f       	std	Y+26, r25	; 0x1a
    4250:	ab 8f       	std	Y+27, r26	; 0x1b
    4252:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4254:	69 8d       	ldd	r22, Y+25	; 0x19
    4256:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4258:	8b 8d       	ldd	r24, Y+27	; 0x1b
    425a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    425c:	20 e0       	ldi	r18, 0x00	; 0
    425e:	30 e0       	ldi	r19, 0x00	; 0
    4260:	4a e7       	ldi	r20, 0x7A	; 122
    4262:	55 e4       	ldi	r21, 0x45	; 69
    4264:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    4268:	dc 01       	movw	r26, r24
    426a:	cb 01       	movw	r24, r22
    426c:	8d 8b       	std	Y+21, r24	; 0x15
    426e:	9e 8b       	std	Y+22, r25	; 0x16
    4270:	af 8b       	std	Y+23, r26	; 0x17
    4272:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4274:	6d 89       	ldd	r22, Y+21	; 0x15
    4276:	7e 89       	ldd	r23, Y+22	; 0x16
    4278:	8f 89       	ldd	r24, Y+23	; 0x17
    427a:	98 8d       	ldd	r25, Y+24	; 0x18
    427c:	20 e0       	ldi	r18, 0x00	; 0
    427e:	30 e0       	ldi	r19, 0x00	; 0
    4280:	40 e8       	ldi	r20, 0x80	; 128
    4282:	5f e3       	ldi	r21, 0x3F	; 63
    4284:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    4288:	88 23       	and	r24, r24
    428a:	2c f4       	brge	.+10     	; 0x4296 <LCD_voidInit+0x664>
		__ticks = 1;
    428c:	81 e0       	ldi	r24, 0x01	; 1
    428e:	90 e0       	ldi	r25, 0x00	; 0
    4290:	9c 8b       	std	Y+20, r25	; 0x14
    4292:	8b 8b       	std	Y+19, r24	; 0x13
    4294:	3f c0       	rjmp	.+126    	; 0x4314 <LCD_voidInit+0x6e2>
	else if (__tmp > 65535)
    4296:	6d 89       	ldd	r22, Y+21	; 0x15
    4298:	7e 89       	ldd	r23, Y+22	; 0x16
    429a:	8f 89       	ldd	r24, Y+23	; 0x17
    429c:	98 8d       	ldd	r25, Y+24	; 0x18
    429e:	20 e0       	ldi	r18, 0x00	; 0
    42a0:	3f ef       	ldi	r19, 0xFF	; 255
    42a2:	4f e7       	ldi	r20, 0x7F	; 127
    42a4:	57 e4       	ldi	r21, 0x47	; 71
    42a6:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    42aa:	18 16       	cp	r1, r24
    42ac:	4c f5       	brge	.+82     	; 0x4300 <LCD_voidInit+0x6ce>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    42ae:	69 8d       	ldd	r22, Y+25	; 0x19
    42b0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    42b2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    42b4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    42b6:	20 e0       	ldi	r18, 0x00	; 0
    42b8:	30 e0       	ldi	r19, 0x00	; 0
    42ba:	40 e2       	ldi	r20, 0x20	; 32
    42bc:	51 e4       	ldi	r21, 0x41	; 65
    42be:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    42c2:	dc 01       	movw	r26, r24
    42c4:	cb 01       	movw	r24, r22
    42c6:	bc 01       	movw	r22, r24
    42c8:	cd 01       	movw	r24, r26
    42ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    42ce:	dc 01       	movw	r26, r24
    42d0:	cb 01       	movw	r24, r22
    42d2:	9c 8b       	std	Y+20, r25	; 0x14
    42d4:	8b 8b       	std	Y+19, r24	; 0x13
    42d6:	0f c0       	rjmp	.+30     	; 0x42f6 <LCD_voidInit+0x6c4>
    42d8:	80 e9       	ldi	r24, 0x90	; 144
    42da:	91 e0       	ldi	r25, 0x01	; 1
    42dc:	9a 8b       	std	Y+18, r25	; 0x12
    42de:	89 8b       	std	Y+17, r24	; 0x11
    42e0:	89 89       	ldd	r24, Y+17	; 0x11
    42e2:	9a 89       	ldd	r25, Y+18	; 0x12
    42e4:	01 97       	sbiw	r24, 0x01	; 1
    42e6:	f1 f7       	brne	.-4      	; 0x42e4 <LCD_voidInit+0x6b2>
    42e8:	9a 8b       	std	Y+18, r25	; 0x12
    42ea:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    42ec:	8b 89       	ldd	r24, Y+19	; 0x13
    42ee:	9c 89       	ldd	r25, Y+20	; 0x14
    42f0:	01 97       	sbiw	r24, 0x01	; 1
    42f2:	9c 8b       	std	Y+20, r25	; 0x14
    42f4:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    42f6:	8b 89       	ldd	r24, Y+19	; 0x13
    42f8:	9c 89       	ldd	r25, Y+20	; 0x14
    42fa:	00 97       	sbiw	r24, 0x00	; 0
    42fc:	69 f7       	brne	.-38     	; 0x42d8 <LCD_voidInit+0x6a6>
    42fe:	14 c0       	rjmp	.+40     	; 0x4328 <LCD_voidInit+0x6f6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4300:	6d 89       	ldd	r22, Y+21	; 0x15
    4302:	7e 89       	ldd	r23, Y+22	; 0x16
    4304:	8f 89       	ldd	r24, Y+23	; 0x17
    4306:	98 8d       	ldd	r25, Y+24	; 0x18
    4308:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    430c:	dc 01       	movw	r26, r24
    430e:	cb 01       	movw	r24, r22
    4310:	9c 8b       	std	Y+20, r25	; 0x14
    4312:	8b 8b       	std	Y+19, r24	; 0x13
    4314:	8b 89       	ldd	r24, Y+19	; 0x13
    4316:	9c 89       	ldd	r25, Y+20	; 0x14
    4318:	98 8b       	std	Y+16, r25	; 0x10
    431a:	8f 87       	std	Y+15, r24	; 0x0f
    431c:	8f 85       	ldd	r24, Y+15	; 0x0f
    431e:	98 89       	ldd	r25, Y+16	; 0x10
    4320:	01 97       	sbiw	r24, 0x01	; 1
    4322:	f1 f7       	brne	.-4      	; 0x4320 <LCD_voidInit+0x6ee>
    4324:	98 8b       	std	Y+16, r25	; 0x10
    4326:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	LCD_voidWriteCommand(DISPLAY_CLEAR);
    4328:	81 e0       	ldi	r24, 0x01	; 1
    432a:	0e 94 27 22 	call	0x444e	; 0x444e <LCD_voidWriteCommand>
    432e:	80 e0       	ldi	r24, 0x00	; 0
    4330:	90 e0       	ldi	r25, 0x00	; 0
    4332:	a0 e0       	ldi	r26, 0x00	; 0
    4334:	b0 e4       	ldi	r27, 0x40	; 64
    4336:	8b 87       	std	Y+11, r24	; 0x0b
    4338:	9c 87       	std	Y+12, r25	; 0x0c
    433a:	ad 87       	std	Y+13, r26	; 0x0d
    433c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    433e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4340:	7c 85       	ldd	r23, Y+12	; 0x0c
    4342:	8d 85       	ldd	r24, Y+13	; 0x0d
    4344:	9e 85       	ldd	r25, Y+14	; 0x0e
    4346:	20 e0       	ldi	r18, 0x00	; 0
    4348:	30 e0       	ldi	r19, 0x00	; 0
    434a:	4a e7       	ldi	r20, 0x7A	; 122
    434c:	55 e4       	ldi	r21, 0x45	; 69
    434e:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    4352:	dc 01       	movw	r26, r24
    4354:	cb 01       	movw	r24, r22
    4356:	8f 83       	std	Y+7, r24	; 0x07
    4358:	98 87       	std	Y+8, r25	; 0x08
    435a:	a9 87       	std	Y+9, r26	; 0x09
    435c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    435e:	6f 81       	ldd	r22, Y+7	; 0x07
    4360:	78 85       	ldd	r23, Y+8	; 0x08
    4362:	89 85       	ldd	r24, Y+9	; 0x09
    4364:	9a 85       	ldd	r25, Y+10	; 0x0a
    4366:	20 e0       	ldi	r18, 0x00	; 0
    4368:	30 e0       	ldi	r19, 0x00	; 0
    436a:	40 e8       	ldi	r20, 0x80	; 128
    436c:	5f e3       	ldi	r21, 0x3F	; 63
    436e:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    4372:	88 23       	and	r24, r24
    4374:	2c f4       	brge	.+10     	; 0x4380 <LCD_voidInit+0x74e>
		__ticks = 1;
    4376:	81 e0       	ldi	r24, 0x01	; 1
    4378:	90 e0       	ldi	r25, 0x00	; 0
    437a:	9e 83       	std	Y+6, r25	; 0x06
    437c:	8d 83       	std	Y+5, r24	; 0x05
    437e:	3f c0       	rjmp	.+126    	; 0x43fe <LCD_voidInit+0x7cc>
	else if (__tmp > 65535)
    4380:	6f 81       	ldd	r22, Y+7	; 0x07
    4382:	78 85       	ldd	r23, Y+8	; 0x08
    4384:	89 85       	ldd	r24, Y+9	; 0x09
    4386:	9a 85       	ldd	r25, Y+10	; 0x0a
    4388:	20 e0       	ldi	r18, 0x00	; 0
    438a:	3f ef       	ldi	r19, 0xFF	; 255
    438c:	4f e7       	ldi	r20, 0x7F	; 127
    438e:	57 e4       	ldi	r21, 0x47	; 71
    4390:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    4394:	18 16       	cp	r1, r24
    4396:	4c f5       	brge	.+82     	; 0x43ea <LCD_voidInit+0x7b8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4398:	6b 85       	ldd	r22, Y+11	; 0x0b
    439a:	7c 85       	ldd	r23, Y+12	; 0x0c
    439c:	8d 85       	ldd	r24, Y+13	; 0x0d
    439e:	9e 85       	ldd	r25, Y+14	; 0x0e
    43a0:	20 e0       	ldi	r18, 0x00	; 0
    43a2:	30 e0       	ldi	r19, 0x00	; 0
    43a4:	40 e2       	ldi	r20, 0x20	; 32
    43a6:	51 e4       	ldi	r21, 0x41	; 65
    43a8:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    43ac:	dc 01       	movw	r26, r24
    43ae:	cb 01       	movw	r24, r22
    43b0:	bc 01       	movw	r22, r24
    43b2:	cd 01       	movw	r24, r26
    43b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    43b8:	dc 01       	movw	r26, r24
    43ba:	cb 01       	movw	r24, r22
    43bc:	9e 83       	std	Y+6, r25	; 0x06
    43be:	8d 83       	std	Y+5, r24	; 0x05
    43c0:	0f c0       	rjmp	.+30     	; 0x43e0 <LCD_voidInit+0x7ae>
    43c2:	80 e9       	ldi	r24, 0x90	; 144
    43c4:	91 e0       	ldi	r25, 0x01	; 1
    43c6:	9c 83       	std	Y+4, r25	; 0x04
    43c8:	8b 83       	std	Y+3, r24	; 0x03
    43ca:	8b 81       	ldd	r24, Y+3	; 0x03
    43cc:	9c 81       	ldd	r25, Y+4	; 0x04
    43ce:	01 97       	sbiw	r24, 0x01	; 1
    43d0:	f1 f7       	brne	.-4      	; 0x43ce <LCD_voidInit+0x79c>
    43d2:	9c 83       	std	Y+4, r25	; 0x04
    43d4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    43d6:	8d 81       	ldd	r24, Y+5	; 0x05
    43d8:	9e 81       	ldd	r25, Y+6	; 0x06
    43da:	01 97       	sbiw	r24, 0x01	; 1
    43dc:	9e 83       	std	Y+6, r25	; 0x06
    43de:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    43e0:	8d 81       	ldd	r24, Y+5	; 0x05
    43e2:	9e 81       	ldd	r25, Y+6	; 0x06
    43e4:	00 97       	sbiw	r24, 0x00	; 0
    43e6:	69 f7       	brne	.-38     	; 0x43c2 <LCD_voidInit+0x790>
    43e8:	14 c0       	rjmp	.+40     	; 0x4412 <LCD_voidInit+0x7e0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    43ea:	6f 81       	ldd	r22, Y+7	; 0x07
    43ec:	78 85       	ldd	r23, Y+8	; 0x08
    43ee:	89 85       	ldd	r24, Y+9	; 0x09
    43f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    43f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    43f6:	dc 01       	movw	r26, r24
    43f8:	cb 01       	movw	r24, r22
    43fa:	9e 83       	std	Y+6, r25	; 0x06
    43fc:	8d 83       	std	Y+5, r24	; 0x05
    43fe:	8d 81       	ldd	r24, Y+5	; 0x05
    4400:	9e 81       	ldd	r25, Y+6	; 0x06
    4402:	9a 83       	std	Y+2, r25	; 0x02
    4404:	89 83       	std	Y+1, r24	; 0x01
    4406:	89 81       	ldd	r24, Y+1	; 0x01
    4408:	9a 81       	ldd	r25, Y+2	; 0x02
    440a:	01 97       	sbiw	r24, 0x01	; 1
    440c:	f1 f7       	brne	.-4      	; 0x440a <LCD_voidInit+0x7d8>
    440e:	9a 83       	std	Y+2, r25	; 0x02
    4410:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
}
    4412:	ce 59       	subi	r28, 0x9E	; 158
    4414:	df 4f       	sbci	r29, 0xFF	; 255
    4416:	0f b6       	in	r0, 0x3f	; 63
    4418:	f8 94       	cli
    441a:	de bf       	out	0x3e, r29	; 62
    441c:	0f be       	out	0x3f, r0	; 63
    441e:	cd bf       	out	0x3d, r28	; 61
    4420:	cf 91       	pop	r28
    4422:	df 91       	pop	r29
    4424:	1f 91       	pop	r17
    4426:	0f 91       	pop	r16
    4428:	08 95       	ret

0000442a <LCD_voidWriteData>:

void LCD_voidWriteData(u8 copy_u8data){
    442a:	df 93       	push	r29
    442c:	cf 93       	push	r28
    442e:	0f 92       	push	r0
    4430:	cd b7       	in	r28, 0x3d	; 61
    4432:	de b7       	in	r29, 0x3e	; 62
    4434:	89 83       	std	Y+1, r24	; 0x01
	DIO_voidSetPinValue(RS_PORT, RS_PIN, RS_DATA_VAL);
    4436:	80 e0       	ldi	r24, 0x00	; 0
    4438:	63 e0       	ldi	r22, 0x03	; 3
    443a:	41 e0       	ldi	r20, 0x01	; 1
    443c:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	LCD_voidWriteBitsToSend(copy_u8data);
    4440:	89 81       	ldd	r24, Y+1	; 0x01
    4442:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <LCD_voidWriteBitsToSend>
}
    4446:	0f 90       	pop	r0
    4448:	cf 91       	pop	r28
    444a:	df 91       	pop	r29
    444c:	08 95       	ret

0000444e <LCD_voidWriteCommand>:

void LCD_voidWriteCommand(u8 copy_u8Command){
    444e:	df 93       	push	r29
    4450:	cf 93       	push	r28
    4452:	0f 92       	push	r0
    4454:	cd b7       	in	r28, 0x3d	; 61
    4456:	de b7       	in	r29, 0x3e	; 62
    4458:	89 83       	std	Y+1, r24	; 0x01
	DIO_voidSetPinValue(RS_PORT, RS_PIN, RS_CMD_VAL);
    445a:	80 e0       	ldi	r24, 0x00	; 0
    445c:	63 e0       	ldi	r22, 0x03	; 3
    445e:	40 e0       	ldi	r20, 0x00	; 0
    4460:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	LCD_voidWriteBitsToSend(copy_u8Command);
    4464:	89 81       	ldd	r24, Y+1	; 0x01
    4466:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <LCD_voidWriteBitsToSend>
}
    446a:	0f 90       	pop	r0
    446c:	cf 91       	pop	r28
    446e:	df 91       	pop	r29
    4470:	08 95       	ret

00004472 <LCD_voidWriteString>:

void LCD_voidWriteString(u8 * copy_str){
    4472:	df 93       	push	r29
    4474:	cf 93       	push	r28
    4476:	00 d0       	rcall	.+0      	; 0x4478 <LCD_voidWriteString+0x6>
    4478:	00 d0       	rcall	.+0      	; 0x447a <LCD_voidWriteString+0x8>
    447a:	00 d0       	rcall	.+0      	; 0x447c <LCD_voidWriteString+0xa>
    447c:	cd b7       	in	r28, 0x3d	; 61
    447e:	de b7       	in	r29, 0x3e	; 62
    4480:	9e 83       	std	Y+6, r25	; 0x06
    4482:	8d 83       	std	Y+5, r24	; 0x05
	u32 i= 0;
    4484:	19 82       	std	Y+1, r1	; 0x01
    4486:	1a 82       	std	Y+2, r1	; 0x02
    4488:	1b 82       	std	Y+3, r1	; 0x03
    448a:	1c 82       	std	Y+4, r1	; 0x04
    448c:	15 c0       	rjmp	.+42     	; 0x44b8 <LCD_voidWriteString+0x46>
	while(copy_str[i] != '\0'){
		LCD_voidWriteData(copy_str[i]);
    448e:	29 81       	ldd	r18, Y+1	; 0x01
    4490:	3a 81       	ldd	r19, Y+2	; 0x02
    4492:	8d 81       	ldd	r24, Y+5	; 0x05
    4494:	9e 81       	ldd	r25, Y+6	; 0x06
    4496:	fc 01       	movw	r30, r24
    4498:	e2 0f       	add	r30, r18
    449a:	f3 1f       	adc	r31, r19
    449c:	80 81       	ld	r24, Z
    449e:	0e 94 15 22 	call	0x442a	; 0x442a <LCD_voidWriteData>
		i++;
    44a2:	89 81       	ldd	r24, Y+1	; 0x01
    44a4:	9a 81       	ldd	r25, Y+2	; 0x02
    44a6:	ab 81       	ldd	r26, Y+3	; 0x03
    44a8:	bc 81       	ldd	r27, Y+4	; 0x04
    44aa:	01 96       	adiw	r24, 0x01	; 1
    44ac:	a1 1d       	adc	r26, r1
    44ae:	b1 1d       	adc	r27, r1
    44b0:	89 83       	std	Y+1, r24	; 0x01
    44b2:	9a 83       	std	Y+2, r25	; 0x02
    44b4:	ab 83       	std	Y+3, r26	; 0x03
    44b6:	bc 83       	std	Y+4, r27	; 0x04
	LCD_voidWriteBitsToSend(copy_u8Command);
}

void LCD_voidWriteString(u8 * copy_str){
	u32 i= 0;
	while(copy_str[i] != '\0'){
    44b8:	29 81       	ldd	r18, Y+1	; 0x01
    44ba:	3a 81       	ldd	r19, Y+2	; 0x02
    44bc:	8d 81       	ldd	r24, Y+5	; 0x05
    44be:	9e 81       	ldd	r25, Y+6	; 0x06
    44c0:	fc 01       	movw	r30, r24
    44c2:	e2 0f       	add	r30, r18
    44c4:	f3 1f       	adc	r31, r19
    44c6:	80 81       	ld	r24, Z
    44c8:	88 23       	and	r24, r24
    44ca:	09 f7       	brne	.-62     	; 0x448e <LCD_voidWriteString+0x1c>
		LCD_voidWriteData(copy_str[i]);
		i++;
	}
}
    44cc:	26 96       	adiw	r28, 0x06	; 6
    44ce:	0f b6       	in	r0, 0x3f	; 63
    44d0:	f8 94       	cli
    44d2:	de bf       	out	0x3e, r29	; 62
    44d4:	0f be       	out	0x3f, r0	; 63
    44d6:	cd bf       	out	0x3d, r28	; 61
    44d8:	cf 91       	pop	r28
    44da:	df 91       	pop	r29
    44dc:	08 95       	ret

000044de <LCD_voidWriteNum>:

void LCD_voidWriteNum(u32 copy_u32Num){
    44de:	ef 92       	push	r14
    44e0:	ff 92       	push	r15
    44e2:	0f 93       	push	r16
    44e4:	1f 93       	push	r17
    44e6:	df 93       	push	r29
    44e8:	cf 93       	push	r28
    44ea:	cd b7       	in	r28, 0x3d	; 61
    44ec:	de b7       	in	r29, 0x3e	; 62
    44ee:	28 97       	sbiw	r28, 0x08	; 8
    44f0:	0f b6       	in	r0, 0x3f	; 63
    44f2:	f8 94       	cli
    44f4:	de bf       	out	0x3e, r29	; 62
    44f6:	0f be       	out	0x3f, r0	; 63
    44f8:	cd bf       	out	0x3d, r28	; 61
    44fa:	6d 83       	std	Y+5, r22	; 0x05
    44fc:	7e 83       	std	Y+6, r23	; 0x06
    44fe:	8f 83       	std	Y+7, r24	; 0x07
    4500:	98 87       	std	Y+8, r25	; 0x08
	u32 i;
	global_string[MAX_STRING_SIZE-1]='\0';
    4502:	10 92 b7 01 	sts	0x01B7, r1
	for(i=MAX_STRING_SIZE-1; copy_u32Num!=0 ; copy_u32Num/=10){
    4506:	83 e1       	ldi	r24, 0x13	; 19
    4508:	90 e0       	ldi	r25, 0x00	; 0
    450a:	a0 e0       	ldi	r26, 0x00	; 0
    450c:	b0 e0       	ldi	r27, 0x00	; 0
    450e:	89 83       	std	Y+1, r24	; 0x01
    4510:	9a 83       	std	Y+2, r25	; 0x02
    4512:	ab 83       	std	Y+3, r26	; 0x03
    4514:	bc 83       	std	Y+4, r27	; 0x04
    4516:	34 c0       	rjmp	.+104    	; 0x4580 <LCD_voidWriteNum+0xa2>
		global_string[--i]= (u8)((copy_u32Num%10) + 48); // '0' = 48 (Ascii Code)
    4518:	89 81       	ldd	r24, Y+1	; 0x01
    451a:	9a 81       	ldd	r25, Y+2	; 0x02
    451c:	ab 81       	ldd	r26, Y+3	; 0x03
    451e:	bc 81       	ldd	r27, Y+4	; 0x04
    4520:	01 97       	sbiw	r24, 0x01	; 1
    4522:	a1 09       	sbc	r26, r1
    4524:	b1 09       	sbc	r27, r1
    4526:	89 83       	std	Y+1, r24	; 0x01
    4528:	9a 83       	std	Y+2, r25	; 0x02
    452a:	ab 83       	std	Y+3, r26	; 0x03
    452c:	bc 83       	std	Y+4, r27	; 0x04
    452e:	e9 80       	ldd	r14, Y+1	; 0x01
    4530:	fa 80       	ldd	r15, Y+2	; 0x02
    4532:	0b 81       	ldd	r16, Y+3	; 0x03
    4534:	1c 81       	ldd	r17, Y+4	; 0x04
    4536:	8d 81       	ldd	r24, Y+5	; 0x05
    4538:	9e 81       	ldd	r25, Y+6	; 0x06
    453a:	af 81       	ldd	r26, Y+7	; 0x07
    453c:	b8 85       	ldd	r27, Y+8	; 0x08
    453e:	2a e0       	ldi	r18, 0x0A	; 10
    4540:	30 e0       	ldi	r19, 0x00	; 0
    4542:	40 e0       	ldi	r20, 0x00	; 0
    4544:	50 e0       	ldi	r21, 0x00	; 0
    4546:	bc 01       	movw	r22, r24
    4548:	cd 01       	movw	r24, r26
    454a:	0e 94 bf 3a 	call	0x757e	; 0x757e <__udivmodsi4>
    454e:	dc 01       	movw	r26, r24
    4550:	cb 01       	movw	r24, r22
    4552:	80 5d       	subi	r24, 0xD0	; 208
    4554:	f7 01       	movw	r30, r14
    4556:	ec 55       	subi	r30, 0x5C	; 92
    4558:	fe 4f       	sbci	r31, 0xFE	; 254
    455a:	80 83       	st	Z, r24
}

void LCD_voidWriteNum(u32 copy_u32Num){
	u32 i;
	global_string[MAX_STRING_SIZE-1]='\0';
	for(i=MAX_STRING_SIZE-1; copy_u32Num!=0 ; copy_u32Num/=10){
    455c:	8d 81       	ldd	r24, Y+5	; 0x05
    455e:	9e 81       	ldd	r25, Y+6	; 0x06
    4560:	af 81       	ldd	r26, Y+7	; 0x07
    4562:	b8 85       	ldd	r27, Y+8	; 0x08
    4564:	2a e0       	ldi	r18, 0x0A	; 10
    4566:	30 e0       	ldi	r19, 0x00	; 0
    4568:	40 e0       	ldi	r20, 0x00	; 0
    456a:	50 e0       	ldi	r21, 0x00	; 0
    456c:	bc 01       	movw	r22, r24
    456e:	cd 01       	movw	r24, r26
    4570:	0e 94 bf 3a 	call	0x757e	; 0x757e <__udivmodsi4>
    4574:	da 01       	movw	r26, r20
    4576:	c9 01       	movw	r24, r18
    4578:	8d 83       	std	Y+5, r24	; 0x05
    457a:	9e 83       	std	Y+6, r25	; 0x06
    457c:	af 83       	std	Y+7, r26	; 0x07
    457e:	b8 87       	std	Y+8, r27	; 0x08
    4580:	8d 81       	ldd	r24, Y+5	; 0x05
    4582:	9e 81       	ldd	r25, Y+6	; 0x06
    4584:	af 81       	ldd	r26, Y+7	; 0x07
    4586:	b8 85       	ldd	r27, Y+8	; 0x08
    4588:	00 97       	sbiw	r24, 0x00	; 0
    458a:	a1 05       	cpc	r26, r1
    458c:	b1 05       	cpc	r27, r1
    458e:	21 f6       	brne	.-120    	; 0x4518 <LCD_voidWriteNum+0x3a>
		global_string[--i]= (u8)((copy_u32Num%10) + 48); // '0' = 48 (Ascii Code)
	}
	global_StringData = (&global_string[i]);
    4590:	89 81       	ldd	r24, Y+1	; 0x01
    4592:	9a 81       	ldd	r25, Y+2	; 0x02
    4594:	8c 55       	subi	r24, 0x5C	; 92
    4596:	9e 4f       	sbci	r25, 0xFE	; 254
    4598:	90 93 b9 01 	sts	0x01B9, r25
    459c:	80 93 b8 01 	sts	0x01B8, r24
	LCD_voidWriteString((u8*)global_StringData);
    45a0:	80 91 b8 01 	lds	r24, 0x01B8
    45a4:	90 91 b9 01 	lds	r25, 0x01B9
    45a8:	0e 94 39 22 	call	0x4472	; 0x4472 <LCD_voidWriteString>
}
    45ac:	28 96       	adiw	r28, 0x08	; 8
    45ae:	0f b6       	in	r0, 0x3f	; 63
    45b0:	f8 94       	cli
    45b2:	de bf       	out	0x3e, r29	; 62
    45b4:	0f be       	out	0x3f, r0	; 63
    45b6:	cd bf       	out	0x3d, r28	; 61
    45b8:	cf 91       	pop	r28
    45ba:	df 91       	pop	r29
    45bc:	1f 91       	pop	r17
    45be:	0f 91       	pop	r16
    45c0:	ff 90       	pop	r15
    45c2:	ef 90       	pop	r14
    45c4:	08 95       	ret

000045c6 <LCD_voidGoToXY>:

void LCD_voidGoToXY(u8 copy_u8row,u8 copy_u8col){
    45c6:	df 93       	push	r29
    45c8:	cf 93       	push	r28
    45ca:	00 d0       	rcall	.+0      	; 0x45cc <LCD_voidGoToXY+0x6>
    45cc:	00 d0       	rcall	.+0      	; 0x45ce <LCD_voidGoToXY+0x8>
    45ce:	0f 92       	push	r0
    45d0:	cd b7       	in	r28, 0x3d	; 61
    45d2:	de b7       	in	r29, 0x3e	; 62
    45d4:	8a 83       	std	Y+2, r24	; 0x02
    45d6:	6b 83       	std	Y+3, r22	; 0x03

	u8 local_address ;
	switch(copy_u8row){
    45d8:	8a 81       	ldd	r24, Y+2	; 0x02
    45da:	28 2f       	mov	r18, r24
    45dc:	30 e0       	ldi	r19, 0x00	; 0
    45de:	3d 83       	std	Y+5, r19	; 0x05
    45e0:	2c 83       	std	Y+4, r18	; 0x04
    45e2:	8c 81       	ldd	r24, Y+4	; 0x04
    45e4:	9d 81       	ldd	r25, Y+5	; 0x05
    45e6:	00 97       	sbiw	r24, 0x00	; 0
    45e8:	31 f0       	breq	.+12     	; 0x45f6 <LCD_voidGoToXY+0x30>
    45ea:	2c 81       	ldd	r18, Y+4	; 0x04
    45ec:	3d 81       	ldd	r19, Y+5	; 0x05
    45ee:	21 30       	cpi	r18, 0x01	; 1
    45f0:	31 05       	cpc	r19, r1
    45f2:	21 f0       	breq	.+8      	; 0x45fc <LCD_voidGoToXY+0x36>
    45f4:	06 c0       	rjmp	.+12     	; 0x4602 <LCD_voidGoToXY+0x3c>
		case 0 : local_address = copy_u8col ;
    45f6:	8b 81       	ldd	r24, Y+3	; 0x03
    45f8:	89 83       	std	Y+1, r24	; 0x01
    45fa:	03 c0       	rjmp	.+6      	; 0x4602 <LCD_voidGoToXY+0x3c>
		break ;

		case 1 : local_address = copy_u8col+0x40 ;
    45fc:	8b 81       	ldd	r24, Y+3	; 0x03
    45fe:	80 5c       	subi	r24, 0xC0	; 192
    4600:	89 83       	std	Y+1, r24	; 0x01
		break ;
	}
	LCD_voidWriteCommand(local_address+SET_DDRAM_ADDRESS);
    4602:	89 81       	ldd	r24, Y+1	; 0x01
    4604:	80 58       	subi	r24, 0x80	; 128
    4606:	0e 94 27 22 	call	0x444e	; 0x444e <LCD_voidWriteCommand>

}
    460a:	0f 90       	pop	r0
    460c:	0f 90       	pop	r0
    460e:	0f 90       	pop	r0
    4610:	0f 90       	pop	r0
    4612:	0f 90       	pop	r0
    4614:	cf 91       	pop	r28
    4616:	df 91       	pop	r29
    4618:	08 95       	ret

0000461a <LCD_voidClear>:

void LCD_voidClear(void){
    461a:	df 93       	push	r29
    461c:	cf 93       	push	r28
    461e:	cd b7       	in	r28, 0x3d	; 61
    4620:	de b7       	in	r29, 0x3e	; 62
	LCD_voidWriteCommand(DISPLAY_CLEAR);
    4622:	81 e0       	ldi	r24, 0x01	; 1
    4624:	0e 94 27 22 	call	0x444e	; 0x444e <LCD_voidWriteCommand>
}
    4628:	cf 91       	pop	r28
    462a:	df 91       	pop	r29
    462c:	08 95       	ret

0000462e <KPD_voidInit>:

/*************************************************************************************
 *                               Public Function Definition                          *
 *************************************************************************************/

void KPD_voidInit(void) {
    462e:	df 93       	push	r29
    4630:	cf 93       	push	r28
    4632:	00 d0       	rcall	.+0      	; 0x4634 <KPD_voidInit+0x6>
    4634:	cd b7       	in	r28, 0x3d	; 61
    4636:	de b7       	in	r29, 0x3e	; 62
	/* Set Rows as  Output */
	for (u8 local_u8PinID = 0; local_u8PinID < 4; local_u8PinID++){
    4638:	1a 82       	std	Y+2, r1	; 0x02
    463a:	0f c0       	rjmp	.+30     	; 0x465a <KPD_voidInit+0x2c>
		DIO_voidSetPinDirection(KPD_ROW_PORT, global_Au8RowsPins[local_u8PinID], PIN_OUTPUT);
    463c:	8a 81       	ldd	r24, Y+2	; 0x02
    463e:	88 2f       	mov	r24, r24
    4640:	90 e0       	ldi	r25, 0x00	; 0
    4642:	fc 01       	movw	r30, r24
    4644:	ea 58       	subi	r30, 0x8A	; 138
    4646:	fe 4f       	sbci	r31, 0xFE	; 254
    4648:	90 81       	ld	r25, Z
    464a:	82 e0       	ldi	r24, 0x02	; 2
    464c:	69 2f       	mov	r22, r25
    464e:	41 e0       	ldi	r20, 0x01	; 1
    4650:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
 *                               Public Function Definition                          *
 *************************************************************************************/

void KPD_voidInit(void) {
	/* Set Rows as  Output */
	for (u8 local_u8PinID = 0; local_u8PinID < 4; local_u8PinID++){
    4654:	8a 81       	ldd	r24, Y+2	; 0x02
    4656:	8f 5f       	subi	r24, 0xFF	; 255
    4658:	8a 83       	std	Y+2, r24	; 0x02
    465a:	8a 81       	ldd	r24, Y+2	; 0x02
    465c:	84 30       	cpi	r24, 0x04	; 4
    465e:	70 f3       	brcs	.-36     	; 0x463c <KPD_voidInit+0xe>
		DIO_voidSetPinDirection(KPD_ROW_PORT, global_Au8RowsPins[local_u8PinID], PIN_OUTPUT);
	}

	/* Set Columns as Inputs & Pulled up */
	for (u8 local_u8PinID = 0; local_u8PinID < 4; local_u8PinID++){
    4660:	19 82       	std	Y+1, r1	; 0x01
    4662:	1b c0       	rjmp	.+54     	; 0x469a <KPD_voidInit+0x6c>
		DIO_voidSetPinDirection(KPD_COL_PORT, global_Au8ColsPins[local_u8PinID], PIN_INPUT);
    4664:	89 81       	ldd	r24, Y+1	; 0x01
    4666:	88 2f       	mov	r24, r24
    4668:	90 e0       	ldi	r25, 0x00	; 0
    466a:	fc 01       	movw	r30, r24
    466c:	ee 58       	subi	r30, 0x8E	; 142
    466e:	fe 4f       	sbci	r31, 0xFE	; 254
    4670:	90 81       	ld	r25, Z
    4672:	83 e0       	ldi	r24, 0x03	; 3
    4674:	69 2f       	mov	r22, r25
    4676:	40 e0       	ldi	r20, 0x00	; 0
    4678:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
		DIO_voidSetPinValue(KPD_COL_PORT, global_Au8ColsPins[local_u8PinID], PIN_HIGH);
    467c:	89 81       	ldd	r24, Y+1	; 0x01
    467e:	88 2f       	mov	r24, r24
    4680:	90 e0       	ldi	r25, 0x00	; 0
    4682:	fc 01       	movw	r30, r24
    4684:	ee 58       	subi	r30, 0x8E	; 142
    4686:	fe 4f       	sbci	r31, 0xFE	; 254
    4688:	90 81       	ld	r25, Z
    468a:	83 e0       	ldi	r24, 0x03	; 3
    468c:	69 2f       	mov	r22, r25
    468e:	41 e0       	ldi	r20, 0x01	; 1
    4690:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	for (u8 local_u8PinID = 0; local_u8PinID < 4; local_u8PinID++){
		DIO_voidSetPinDirection(KPD_ROW_PORT, global_Au8RowsPins[local_u8PinID], PIN_OUTPUT);
	}

	/* Set Columns as Inputs & Pulled up */
	for (u8 local_u8PinID = 0; local_u8PinID < 4; local_u8PinID++){
    4694:	89 81       	ldd	r24, Y+1	; 0x01
    4696:	8f 5f       	subi	r24, 0xFF	; 255
    4698:	89 83       	std	Y+1, r24	; 0x01
    469a:	89 81       	ldd	r24, Y+1	; 0x01
    469c:	84 30       	cpi	r24, 0x04	; 4
    469e:	10 f3       	brcs	.-60     	; 0x4664 <KPD_voidInit+0x36>
		DIO_voidSetPinDirection(KPD_COL_PORT, global_Au8ColsPins[local_u8PinID], PIN_INPUT);
		DIO_voidSetPinValue(KPD_COL_PORT, global_Au8ColsPins[local_u8PinID], PIN_HIGH);
	}
}
    46a0:	0f 90       	pop	r0
    46a2:	0f 90       	pop	r0
    46a4:	cf 91       	pop	r28
    46a6:	df 91       	pop	r29
    46a8:	08 95       	ret

000046aa <KPD_voidGetPressedKey>:

u8 KPD_voidGetPressedKey(void)
{
    46aa:	df 93       	push	r29
    46ac:	cf 93       	push	r28
    46ae:	cd b7       	in	r28, 0x3d	; 61
    46b0:	de b7       	in	r29, 0x3e	; 62
    46b2:	63 97       	sbiw	r28, 0x13	; 19
    46b4:	0f b6       	in	r0, 0x3f	; 63
    46b6:	f8 94       	cli
    46b8:	de bf       	out	0x3e, r29	; 62
    46ba:	0f be       	out	0x3f, r0	; 63
    46bc:	cd bf       	out	0x3d, r28	; 61
	u8 local_u8ColID, local_u8RowID, local_u8PinVal;
	/* Initialize the switch status to NOT Pressed as a default value */
	u8 local_u8_PressedKey = KPD_NOT_PRESSED;
    46be:	8f ef       	ldi	r24, 0xFF	; 255
    46c0:	8f 87       	std	Y+15, r24	; 0x0f

	/* Loop on the rows of the Key Pad */
	for (local_u8RowID = 0; local_u8RowID < 4; local_u8RowID++){
    46c2:	19 8a       	std	Y+17, r1	; 0x11
    46c4:	cb c0       	rjmp	.+406    	; 0x485c <KPD_voidGetPressedKey+0x1b2>
		/* Activate the All Columns in Current Row */
		DIO_voidSetPinValue(KPD_ROW_PORT, global_Au8RowsPins[local_u8RowID], PIN_LOW);
    46c6:	89 89       	ldd	r24, Y+17	; 0x11
    46c8:	88 2f       	mov	r24, r24
    46ca:	90 e0       	ldi	r25, 0x00	; 0
    46cc:	fc 01       	movw	r30, r24
    46ce:	ea 58       	subi	r30, 0x8A	; 138
    46d0:	fe 4f       	sbci	r31, 0xFE	; 254
    46d2:	90 81       	ld	r25, Z
    46d4:	82 e0       	ldi	r24, 0x02	; 2
    46d6:	69 2f       	mov	r22, r25
    46d8:	40 e0       	ldi	r20, 0x00	; 0
    46da:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>

		/* Looping on columns of the Key Pad */
		for (local_u8ColID = 0; local_u8ColID < 4; local_u8ColID++){
    46de:	1a 8a       	std	Y+18, r1	; 0x12
    46e0:	aa c0       	rjmp	.+340    	; 0x4836 <KPD_voidGetPressedKey+0x18c>
			/* Check the status of the switch */
			local_u8PinVal = DIO_voidGetPinValue(KPD_COL_PORT, global_Au8ColsPins[local_u8ColID]);
    46e2:	8a 89       	ldd	r24, Y+18	; 0x12
    46e4:	88 2f       	mov	r24, r24
    46e6:	90 e0       	ldi	r25, 0x00	; 0
    46e8:	fc 01       	movw	r30, r24
    46ea:	ee 58       	subi	r30, 0x8E	; 142
    46ec:	fe 4f       	sbci	r31, 0xFE	; 254
    46ee:	90 81       	ld	r25, Z
    46f0:	83 e0       	ldi	r24, 0x03	; 3
    46f2:	69 2f       	mov	r22, r25
    46f4:	0e 94 07 14 	call	0x280e	; 0x280e <DIO_voidGetPinValue>
    46f8:	88 8b       	std	Y+16, r24	; 0x10
			if (local_u8PinVal == 0){
    46fa:	88 89       	ldd	r24, Y+16	; 0x10
    46fc:	88 23       	and	r24, r24
    46fe:	09 f0       	breq	.+2      	; 0x4702 <KPD_voidGetPressedKey+0x58>
    4700:	97 c0       	rjmp	.+302    	; 0x4830 <KPD_voidGetPressedKey+0x186>
				/* Get the value of the currently pressed switch */
				local_u8_PressedKey = global_Au8SwitchVal[local_u8RowID][local_u8ColID];
    4702:	89 89       	ldd	r24, Y+17	; 0x11
    4704:	48 2f       	mov	r20, r24
    4706:	50 e0       	ldi	r21, 0x00	; 0
    4708:	8a 89       	ldd	r24, Y+18	; 0x12
    470a:	28 2f       	mov	r18, r24
    470c:	30 e0       	ldi	r19, 0x00	; 0
    470e:	ca 01       	movw	r24, r20
    4710:	88 0f       	add	r24, r24
    4712:	99 1f       	adc	r25, r25
    4714:	88 0f       	add	r24, r24
    4716:	99 1f       	adc	r25, r25
    4718:	82 0f       	add	r24, r18
    471a:	93 1f       	adc	r25, r19
    471c:	fc 01       	movw	r30, r24
    471e:	e6 58       	subi	r30, 0x86	; 134
    4720:	fe 4f       	sbci	r31, 0xFE	; 254
    4722:	80 81       	ld	r24, Z
    4724:	8f 87       	std	Y+15, r24	; 0x0f
    4726:	0c c0       	rjmp	.+24     	; 0x4740 <KPD_voidGetPressedKey+0x96>

				/* Wait until the switch is released (Single Press) */
				while (local_u8PinVal == 0){
					local_u8PinVal = DIO_voidGetPinValue(KPD_COL_PORT, global_Au8ColsPins[local_u8ColID]);
    4728:	8a 89       	ldd	r24, Y+18	; 0x12
    472a:	88 2f       	mov	r24, r24
    472c:	90 e0       	ldi	r25, 0x00	; 0
    472e:	fc 01       	movw	r30, r24
    4730:	ee 58       	subi	r30, 0x8E	; 142
    4732:	fe 4f       	sbci	r31, 0xFE	; 254
    4734:	90 81       	ld	r25, Z
    4736:	83 e0       	ldi	r24, 0x03	; 3
    4738:	69 2f       	mov	r22, r25
    473a:	0e 94 07 14 	call	0x280e	; 0x280e <DIO_voidGetPinValue>
    473e:	88 8b       	std	Y+16, r24	; 0x10
			if (local_u8PinVal == 0){
				/* Get the value of the currently pressed switch */
				local_u8_PressedKey = global_Au8SwitchVal[local_u8RowID][local_u8ColID];

				/* Wait until the switch is released (Single Press) */
				while (local_u8PinVal == 0){
    4740:	88 89       	ldd	r24, Y+16	; 0x10
    4742:	88 23       	and	r24, r24
    4744:	89 f3       	breq	.-30     	; 0x4728 <KPD_voidGetPressedKey+0x7e>
    4746:	80 e0       	ldi	r24, 0x00	; 0
    4748:	90 e0       	ldi	r25, 0x00	; 0
    474a:	a0 ea       	ldi	r26, 0xA0	; 160
    474c:	b1 e4       	ldi	r27, 0x41	; 65
    474e:	8b 87       	std	Y+11, r24	; 0x0b
    4750:	9c 87       	std	Y+12, r25	; 0x0c
    4752:	ad 87       	std	Y+13, r26	; 0x0d
    4754:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4756:	6b 85       	ldd	r22, Y+11	; 0x0b
    4758:	7c 85       	ldd	r23, Y+12	; 0x0c
    475a:	8d 85       	ldd	r24, Y+13	; 0x0d
    475c:	9e 85       	ldd	r25, Y+14	; 0x0e
    475e:	20 e0       	ldi	r18, 0x00	; 0
    4760:	30 e0       	ldi	r19, 0x00	; 0
    4762:	4a e7       	ldi	r20, 0x7A	; 122
    4764:	55 e4       	ldi	r21, 0x45	; 69
    4766:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    476a:	dc 01       	movw	r26, r24
    476c:	cb 01       	movw	r24, r22
    476e:	8f 83       	std	Y+7, r24	; 0x07
    4770:	98 87       	std	Y+8, r25	; 0x08
    4772:	a9 87       	std	Y+9, r26	; 0x09
    4774:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4776:	6f 81       	ldd	r22, Y+7	; 0x07
    4778:	78 85       	ldd	r23, Y+8	; 0x08
    477a:	89 85       	ldd	r24, Y+9	; 0x09
    477c:	9a 85       	ldd	r25, Y+10	; 0x0a
    477e:	20 e0       	ldi	r18, 0x00	; 0
    4780:	30 e0       	ldi	r19, 0x00	; 0
    4782:	40 e8       	ldi	r20, 0x80	; 128
    4784:	5f e3       	ldi	r21, 0x3F	; 63
    4786:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    478a:	88 23       	and	r24, r24
    478c:	2c f4       	brge	.+10     	; 0x4798 <KPD_voidGetPressedKey+0xee>
		__ticks = 1;
    478e:	81 e0       	ldi	r24, 0x01	; 1
    4790:	90 e0       	ldi	r25, 0x00	; 0
    4792:	9e 83       	std	Y+6, r25	; 0x06
    4794:	8d 83       	std	Y+5, r24	; 0x05
    4796:	3f c0       	rjmp	.+126    	; 0x4816 <KPD_voidGetPressedKey+0x16c>
	else if (__tmp > 65535)
    4798:	6f 81       	ldd	r22, Y+7	; 0x07
    479a:	78 85       	ldd	r23, Y+8	; 0x08
    479c:	89 85       	ldd	r24, Y+9	; 0x09
    479e:	9a 85       	ldd	r25, Y+10	; 0x0a
    47a0:	20 e0       	ldi	r18, 0x00	; 0
    47a2:	3f ef       	ldi	r19, 0xFF	; 255
    47a4:	4f e7       	ldi	r20, 0x7F	; 127
    47a6:	57 e4       	ldi	r21, 0x47	; 71
    47a8:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    47ac:	18 16       	cp	r1, r24
    47ae:	4c f5       	brge	.+82     	; 0x4802 <KPD_voidGetPressedKey+0x158>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    47b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    47b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    47b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    47b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    47b8:	20 e0       	ldi	r18, 0x00	; 0
    47ba:	30 e0       	ldi	r19, 0x00	; 0
    47bc:	40 e2       	ldi	r20, 0x20	; 32
    47be:	51 e4       	ldi	r21, 0x41	; 65
    47c0:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    47c4:	dc 01       	movw	r26, r24
    47c6:	cb 01       	movw	r24, r22
    47c8:	bc 01       	movw	r22, r24
    47ca:	cd 01       	movw	r24, r26
    47cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    47d0:	dc 01       	movw	r26, r24
    47d2:	cb 01       	movw	r24, r22
    47d4:	9e 83       	std	Y+6, r25	; 0x06
    47d6:	8d 83       	std	Y+5, r24	; 0x05
    47d8:	0f c0       	rjmp	.+30     	; 0x47f8 <KPD_voidGetPressedKey+0x14e>
    47da:	80 e9       	ldi	r24, 0x90	; 144
    47dc:	91 e0       	ldi	r25, 0x01	; 1
    47de:	9c 83       	std	Y+4, r25	; 0x04
    47e0:	8b 83       	std	Y+3, r24	; 0x03
    47e2:	8b 81       	ldd	r24, Y+3	; 0x03
    47e4:	9c 81       	ldd	r25, Y+4	; 0x04
    47e6:	01 97       	sbiw	r24, 0x01	; 1
    47e8:	f1 f7       	brne	.-4      	; 0x47e6 <KPD_voidGetPressedKey+0x13c>
    47ea:	9c 83       	std	Y+4, r25	; 0x04
    47ec:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    47ee:	8d 81       	ldd	r24, Y+5	; 0x05
    47f0:	9e 81       	ldd	r25, Y+6	; 0x06
    47f2:	01 97       	sbiw	r24, 0x01	; 1
    47f4:	9e 83       	std	Y+6, r25	; 0x06
    47f6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    47f8:	8d 81       	ldd	r24, Y+5	; 0x05
    47fa:	9e 81       	ldd	r25, Y+6	; 0x06
    47fc:	00 97       	sbiw	r24, 0x00	; 0
    47fe:	69 f7       	brne	.-38     	; 0x47da <KPD_voidGetPressedKey+0x130>
    4800:	14 c0       	rjmp	.+40     	; 0x482a <KPD_voidGetPressedKey+0x180>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4802:	6f 81       	ldd	r22, Y+7	; 0x07
    4804:	78 85       	ldd	r23, Y+8	; 0x08
    4806:	89 85       	ldd	r24, Y+9	; 0x09
    4808:	9a 85       	ldd	r25, Y+10	; 0x0a
    480a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    480e:	dc 01       	movw	r26, r24
    4810:	cb 01       	movw	r24, r22
    4812:	9e 83       	std	Y+6, r25	; 0x06
    4814:	8d 83       	std	Y+5, r24	; 0x05
    4816:	8d 81       	ldd	r24, Y+5	; 0x05
    4818:	9e 81       	ldd	r25, Y+6	; 0x06
    481a:	9a 83       	std	Y+2, r25	; 0x02
    481c:	89 83       	std	Y+1, r24	; 0x01
    481e:	89 81       	ldd	r24, Y+1	; 0x01
    4820:	9a 81       	ldd	r25, Y+2	; 0x02
    4822:	01 97       	sbiw	r24, 0x01	; 1
    4824:	f1 f7       	brne	.-4      	; 0x4822 <KPD_voidGetPressedKey+0x178>
    4826:	9a 83       	std	Y+2, r25	; 0x02
    4828:	89 83       	std	Y+1, r24	; 0x01
					local_u8PinVal = DIO_voidGetPinValue(KPD_COL_PORT, global_Au8ColsPins[local_u8ColID]);
				}
				_delay_ms(20); /* Delay to avoid bouncing */
				return local_u8_PressedKey; /* Returning the value */
    482a:	8f 85       	ldd	r24, Y+15	; 0x0f
    482c:	8b 8b       	std	Y+19, r24	; 0x13
    482e:	1c c0       	rjmp	.+56     	; 0x4868 <KPD_voidGetPressedKey+0x1be>
	for (local_u8RowID = 0; local_u8RowID < 4; local_u8RowID++){
		/* Activate the All Columns in Current Row */
		DIO_voidSetPinValue(KPD_ROW_PORT, global_Au8RowsPins[local_u8RowID], PIN_LOW);

		/* Looping on columns of the Key Pad */
		for (local_u8ColID = 0; local_u8ColID < 4; local_u8ColID++){
    4830:	8a 89       	ldd	r24, Y+18	; 0x12
    4832:	8f 5f       	subi	r24, 0xFF	; 255
    4834:	8a 8b       	std	Y+18, r24	; 0x12
    4836:	8a 89       	ldd	r24, Y+18	; 0x12
    4838:	84 30       	cpi	r24, 0x04	; 4
    483a:	08 f4       	brcc	.+2      	; 0x483e <KPD_voidGetPressedKey+0x194>
    483c:	52 cf       	rjmp	.-348    	; 0x46e2 <KPD_voidGetPressedKey+0x38>
				_delay_ms(20); /* Delay to avoid bouncing */
				return local_u8_PressedKey; /* Returning the value */
			}
		}
		/* Deactivate the All Columns in Current Row */
		DIO_voidSetPinValue(KPD_ROW_PORT, global_Au8RowsPins[local_u8RowID], PIN_HIGH);
    483e:	89 89       	ldd	r24, Y+17	; 0x11
    4840:	88 2f       	mov	r24, r24
    4842:	90 e0       	ldi	r25, 0x00	; 0
    4844:	fc 01       	movw	r30, r24
    4846:	ea 58       	subi	r30, 0x8A	; 138
    4848:	fe 4f       	sbci	r31, 0xFE	; 254
    484a:	90 81       	ld	r25, Z
    484c:	82 e0       	ldi	r24, 0x02	; 2
    484e:	69 2f       	mov	r22, r25
    4850:	41 e0       	ldi	r20, 0x01	; 1
    4852:	0e 94 85 12 	call	0x250a	; 0x250a <DIO_voidSetPinValue>
	u8 local_u8ColID, local_u8RowID, local_u8PinVal;
	/* Initialize the switch status to NOT Pressed as a default value */
	u8 local_u8_PressedKey = KPD_NOT_PRESSED;

	/* Loop on the rows of the Key Pad */
	for (local_u8RowID = 0; local_u8RowID < 4; local_u8RowID++){
    4856:	89 89       	ldd	r24, Y+17	; 0x11
    4858:	8f 5f       	subi	r24, 0xFF	; 255
    485a:	89 8b       	std	Y+17, r24	; 0x11
    485c:	89 89       	ldd	r24, Y+17	; 0x11
    485e:	84 30       	cpi	r24, 0x04	; 4
    4860:	08 f4       	brcc	.+2      	; 0x4864 <KPD_voidGetPressedKey+0x1ba>
    4862:	31 cf       	rjmp	.-414    	; 0x46c6 <KPD_voidGetPressedKey+0x1c>
		}
		/* Deactivate the All Columns in Current Row */
		DIO_voidSetPinValue(KPD_ROW_PORT, global_Au8RowsPins[local_u8RowID], PIN_HIGH);
	}

	return local_u8_PressedKey; /* Returning the value */
    4864:	8f 85       	ldd	r24, Y+15	; 0x0f
    4866:	8b 8b       	std	Y+19, r24	; 0x13
    4868:	8b 89       	ldd	r24, Y+19	; 0x13
}
    486a:	63 96       	adiw	r28, 0x13	; 19
    486c:	0f b6       	in	r0, 0x3f	; 63
    486e:	f8 94       	cli
    4870:	de bf       	out	0x3e, r29	; 62
    4872:	0f be       	out	0x3f, r0	; 63
    4874:	cd bf       	out	0x3d, r28	; 61
    4876:	cf 91       	pop	r28
    4878:	df 91       	pop	r29
    487a:	08 95       	ret

0000487c <BTN_u8BtnDebounce>:
/****BTN****/
#include "BTN_Interface.h"
#include "BTN_Private.h"
#include "BTN_Config.h"

static u8 BTN_u8BtnDebounce(u8 copy_u8BtnID){
    487c:	df 93       	push	r29
    487e:	cf 93       	push	r28
    4880:	cd b7       	in	r28, 0x3d	; 61
    4882:	de b7       	in	r29, 0x3e	; 62
    4884:	ae 97       	sbiw	r28, 0x2e	; 46
    4886:	0f b6       	in	r0, 0x3f	; 63
    4888:	f8 94       	cli
    488a:	de bf       	out	0x3e, r29	; 62
    488c:	0f be       	out	0x3f, r0	; 63
    488e:	cd bf       	out	0x3d, r28	; 61
    4890:	8b a7       	std	Y+43, r24	; 0x2b

	switch(copy_u8BtnID){
    4892:	8b a5       	ldd	r24, Y+43	; 0x2b
    4894:	28 2f       	mov	r18, r24
    4896:	30 e0       	ldi	r19, 0x00	; 0
    4898:	3e a7       	std	Y+46, r19	; 0x2e
    489a:	2d a7       	std	Y+45, r18	; 0x2d
    489c:	8d a5       	ldd	r24, Y+45	; 0x2d
    489e:	9e a5       	ldd	r25, Y+46	; 0x2e
    48a0:	81 30       	cpi	r24, 0x01	; 1
    48a2:	91 05       	cpc	r25, r1
    48a4:	09 f4       	brne	.+2      	; 0x48a8 <BTN_u8BtnDebounce+0x2c>
    48a6:	83 c0       	rjmp	.+262    	; 0x49ae <BTN_u8BtnDebounce+0x132>
    48a8:	2d a5       	ldd	r18, Y+45	; 0x2d
    48aa:	3e a5       	ldd	r19, Y+46	; 0x2e
    48ac:	22 30       	cpi	r18, 0x02	; 2
    48ae:	31 05       	cpc	r19, r1
    48b0:	09 f4       	brne	.+2      	; 0x48b4 <BTN_u8BtnDebounce+0x38>
    48b2:	f5 c0       	rjmp	.+490    	; 0x4a9e <BTN_u8BtnDebounce+0x222>
    48b4:	8d a5       	ldd	r24, Y+45	; 0x2d
    48b6:	9e a5       	ldd	r25, Y+46	; 0x2e
    48b8:	00 97       	sbiw	r24, 0x00	; 0
    48ba:	09 f0       	breq	.+2      	; 0x48be <BTN_u8BtnDebounce+0x42>
    48bc:	68 c1       	rjmp	.+720    	; 0x4b8e <BTN_u8BtnDebounce+0x312>
    48be:	80 e0       	ldi	r24, 0x00	; 0
    48c0:	90 e0       	ldi	r25, 0x00	; 0
    48c2:	a0 e2       	ldi	r26, 0x20	; 32
    48c4:	b2 e4       	ldi	r27, 0x42	; 66
    48c6:	8f a3       	std	Y+39, r24	; 0x27
    48c8:	98 a7       	std	Y+40, r25	; 0x28
    48ca:	a9 a7       	std	Y+41, r26	; 0x29
    48cc:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    48ce:	6f a1       	ldd	r22, Y+39	; 0x27
    48d0:	78 a5       	ldd	r23, Y+40	; 0x28
    48d2:	89 a5       	ldd	r24, Y+41	; 0x29
    48d4:	9a a5       	ldd	r25, Y+42	; 0x2a
    48d6:	20 e0       	ldi	r18, 0x00	; 0
    48d8:	30 e0       	ldi	r19, 0x00	; 0
    48da:	4a e7       	ldi	r20, 0x7A	; 122
    48dc:	55 e4       	ldi	r21, 0x45	; 69
    48de:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    48e2:	dc 01       	movw	r26, r24
    48e4:	cb 01       	movw	r24, r22
    48e6:	8b a3       	std	Y+35, r24	; 0x23
    48e8:	9c a3       	std	Y+36, r25	; 0x24
    48ea:	ad a3       	std	Y+37, r26	; 0x25
    48ec:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    48ee:	6b a1       	ldd	r22, Y+35	; 0x23
    48f0:	7c a1       	ldd	r23, Y+36	; 0x24
    48f2:	8d a1       	ldd	r24, Y+37	; 0x25
    48f4:	9e a1       	ldd	r25, Y+38	; 0x26
    48f6:	20 e0       	ldi	r18, 0x00	; 0
    48f8:	30 e0       	ldi	r19, 0x00	; 0
    48fa:	40 e8       	ldi	r20, 0x80	; 128
    48fc:	5f e3       	ldi	r21, 0x3F	; 63
    48fe:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    4902:	88 23       	and	r24, r24
    4904:	2c f4       	brge	.+10     	; 0x4910 <BTN_u8BtnDebounce+0x94>
		__ticks = 1;
    4906:	81 e0       	ldi	r24, 0x01	; 1
    4908:	90 e0       	ldi	r25, 0x00	; 0
    490a:	9a a3       	std	Y+34, r25	; 0x22
    490c:	89 a3       	std	Y+33, r24	; 0x21
    490e:	3f c0       	rjmp	.+126    	; 0x498e <BTN_u8BtnDebounce+0x112>
	else if (__tmp > 65535)
    4910:	6b a1       	ldd	r22, Y+35	; 0x23
    4912:	7c a1       	ldd	r23, Y+36	; 0x24
    4914:	8d a1       	ldd	r24, Y+37	; 0x25
    4916:	9e a1       	ldd	r25, Y+38	; 0x26
    4918:	20 e0       	ldi	r18, 0x00	; 0
    491a:	3f ef       	ldi	r19, 0xFF	; 255
    491c:	4f e7       	ldi	r20, 0x7F	; 127
    491e:	57 e4       	ldi	r21, 0x47	; 71
    4920:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    4924:	18 16       	cp	r1, r24
    4926:	4c f5       	brge	.+82     	; 0x497a <BTN_u8BtnDebounce+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4928:	6f a1       	ldd	r22, Y+39	; 0x27
    492a:	78 a5       	ldd	r23, Y+40	; 0x28
    492c:	89 a5       	ldd	r24, Y+41	; 0x29
    492e:	9a a5       	ldd	r25, Y+42	; 0x2a
    4930:	20 e0       	ldi	r18, 0x00	; 0
    4932:	30 e0       	ldi	r19, 0x00	; 0
    4934:	40 e2       	ldi	r20, 0x20	; 32
    4936:	51 e4       	ldi	r21, 0x41	; 65
    4938:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    493c:	dc 01       	movw	r26, r24
    493e:	cb 01       	movw	r24, r22
    4940:	bc 01       	movw	r22, r24
    4942:	cd 01       	movw	r24, r26
    4944:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4948:	dc 01       	movw	r26, r24
    494a:	cb 01       	movw	r24, r22
    494c:	9a a3       	std	Y+34, r25	; 0x22
    494e:	89 a3       	std	Y+33, r24	; 0x21
    4950:	0f c0       	rjmp	.+30     	; 0x4970 <BTN_u8BtnDebounce+0xf4>
    4952:	80 e9       	ldi	r24, 0x90	; 144
    4954:	91 e0       	ldi	r25, 0x01	; 1
    4956:	98 a3       	std	Y+32, r25	; 0x20
    4958:	8f 8f       	std	Y+31, r24	; 0x1f
    495a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    495c:	98 a1       	ldd	r25, Y+32	; 0x20
    495e:	01 97       	sbiw	r24, 0x01	; 1
    4960:	f1 f7       	brne	.-4      	; 0x495e <BTN_u8BtnDebounce+0xe2>
    4962:	98 a3       	std	Y+32, r25	; 0x20
    4964:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4966:	89 a1       	ldd	r24, Y+33	; 0x21
    4968:	9a a1       	ldd	r25, Y+34	; 0x22
    496a:	01 97       	sbiw	r24, 0x01	; 1
    496c:	9a a3       	std	Y+34, r25	; 0x22
    496e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4970:	89 a1       	ldd	r24, Y+33	; 0x21
    4972:	9a a1       	ldd	r25, Y+34	; 0x22
    4974:	00 97       	sbiw	r24, 0x00	; 0
    4976:	69 f7       	brne	.-38     	; 0x4952 <BTN_u8BtnDebounce+0xd6>
    4978:	14 c0       	rjmp	.+40     	; 0x49a2 <BTN_u8BtnDebounce+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    497a:	6b a1       	ldd	r22, Y+35	; 0x23
    497c:	7c a1       	ldd	r23, Y+36	; 0x24
    497e:	8d a1       	ldd	r24, Y+37	; 0x25
    4980:	9e a1       	ldd	r25, Y+38	; 0x26
    4982:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4986:	dc 01       	movw	r26, r24
    4988:	cb 01       	movw	r24, r22
    498a:	9a a3       	std	Y+34, r25	; 0x22
    498c:	89 a3       	std	Y+33, r24	; 0x21
    498e:	89 a1       	ldd	r24, Y+33	; 0x21
    4990:	9a a1       	ldd	r25, Y+34	; 0x22
    4992:	9e 8f       	std	Y+30, r25	; 0x1e
    4994:	8d 8f       	std	Y+29, r24	; 0x1d
    4996:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4998:	9e 8d       	ldd	r25, Y+30	; 0x1e
    499a:	01 97       	sbiw	r24, 0x01	; 1
    499c:	f1 f7       	brne	.-4      	; 0x499a <BTN_u8BtnDebounce+0x11e>
    499e:	9e 8f       	std	Y+30, r25	; 0x1e
    49a0:	8d 8f       	std	Y+29, r24	; 0x1d
	case BTN_INT0_ID:
		_delay_ms(DEBOUNCE_DELAY);
		return DIO_voidGetPinValue(BTN_INT0_REG, BTN_INT0_PIN);
    49a2:	83 e0       	ldi	r24, 0x03	; 3
    49a4:	62 e0       	ldi	r22, 0x02	; 2
    49a6:	0e 94 07 14 	call	0x280e	; 0x280e <DIO_voidGetPinValue>
    49aa:	8c a7       	std	Y+44, r24	; 0x2c
    49ac:	f2 c0       	rjmp	.+484    	; 0x4b92 <BTN_u8BtnDebounce+0x316>
    49ae:	80 e0       	ldi	r24, 0x00	; 0
    49b0:	90 e0       	ldi	r25, 0x00	; 0
    49b2:	a0 e2       	ldi	r26, 0x20	; 32
    49b4:	b2 e4       	ldi	r27, 0x42	; 66
    49b6:	89 8f       	std	Y+25, r24	; 0x19
    49b8:	9a 8f       	std	Y+26, r25	; 0x1a
    49ba:	ab 8f       	std	Y+27, r26	; 0x1b
    49bc:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    49be:	69 8d       	ldd	r22, Y+25	; 0x19
    49c0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    49c2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    49c4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    49c6:	20 e0       	ldi	r18, 0x00	; 0
    49c8:	30 e0       	ldi	r19, 0x00	; 0
    49ca:	4a e7       	ldi	r20, 0x7A	; 122
    49cc:	55 e4       	ldi	r21, 0x45	; 69
    49ce:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    49d2:	dc 01       	movw	r26, r24
    49d4:	cb 01       	movw	r24, r22
    49d6:	8d 8b       	std	Y+21, r24	; 0x15
    49d8:	9e 8b       	std	Y+22, r25	; 0x16
    49da:	af 8b       	std	Y+23, r26	; 0x17
    49dc:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    49de:	6d 89       	ldd	r22, Y+21	; 0x15
    49e0:	7e 89       	ldd	r23, Y+22	; 0x16
    49e2:	8f 89       	ldd	r24, Y+23	; 0x17
    49e4:	98 8d       	ldd	r25, Y+24	; 0x18
    49e6:	20 e0       	ldi	r18, 0x00	; 0
    49e8:	30 e0       	ldi	r19, 0x00	; 0
    49ea:	40 e8       	ldi	r20, 0x80	; 128
    49ec:	5f e3       	ldi	r21, 0x3F	; 63
    49ee:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    49f2:	88 23       	and	r24, r24
    49f4:	2c f4       	brge	.+10     	; 0x4a00 <BTN_u8BtnDebounce+0x184>
		__ticks = 1;
    49f6:	81 e0       	ldi	r24, 0x01	; 1
    49f8:	90 e0       	ldi	r25, 0x00	; 0
    49fa:	9c 8b       	std	Y+20, r25	; 0x14
    49fc:	8b 8b       	std	Y+19, r24	; 0x13
    49fe:	3f c0       	rjmp	.+126    	; 0x4a7e <BTN_u8BtnDebounce+0x202>
	else if (__tmp > 65535)
    4a00:	6d 89       	ldd	r22, Y+21	; 0x15
    4a02:	7e 89       	ldd	r23, Y+22	; 0x16
    4a04:	8f 89       	ldd	r24, Y+23	; 0x17
    4a06:	98 8d       	ldd	r25, Y+24	; 0x18
    4a08:	20 e0       	ldi	r18, 0x00	; 0
    4a0a:	3f ef       	ldi	r19, 0xFF	; 255
    4a0c:	4f e7       	ldi	r20, 0x7F	; 127
    4a0e:	57 e4       	ldi	r21, 0x47	; 71
    4a10:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    4a14:	18 16       	cp	r1, r24
    4a16:	4c f5       	brge	.+82     	; 0x4a6a <BTN_u8BtnDebounce+0x1ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4a18:	69 8d       	ldd	r22, Y+25	; 0x19
    4a1a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4a1c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4a1e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4a20:	20 e0       	ldi	r18, 0x00	; 0
    4a22:	30 e0       	ldi	r19, 0x00	; 0
    4a24:	40 e2       	ldi	r20, 0x20	; 32
    4a26:	51 e4       	ldi	r21, 0x41	; 65
    4a28:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    4a2c:	dc 01       	movw	r26, r24
    4a2e:	cb 01       	movw	r24, r22
    4a30:	bc 01       	movw	r22, r24
    4a32:	cd 01       	movw	r24, r26
    4a34:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a38:	dc 01       	movw	r26, r24
    4a3a:	cb 01       	movw	r24, r22
    4a3c:	9c 8b       	std	Y+20, r25	; 0x14
    4a3e:	8b 8b       	std	Y+19, r24	; 0x13
    4a40:	0f c0       	rjmp	.+30     	; 0x4a60 <BTN_u8BtnDebounce+0x1e4>
    4a42:	80 e9       	ldi	r24, 0x90	; 144
    4a44:	91 e0       	ldi	r25, 0x01	; 1
    4a46:	9a 8b       	std	Y+18, r25	; 0x12
    4a48:	89 8b       	std	Y+17, r24	; 0x11
    4a4a:	89 89       	ldd	r24, Y+17	; 0x11
    4a4c:	9a 89       	ldd	r25, Y+18	; 0x12
    4a4e:	01 97       	sbiw	r24, 0x01	; 1
    4a50:	f1 f7       	brne	.-4      	; 0x4a4e <BTN_u8BtnDebounce+0x1d2>
    4a52:	9a 8b       	std	Y+18, r25	; 0x12
    4a54:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a56:	8b 89       	ldd	r24, Y+19	; 0x13
    4a58:	9c 89       	ldd	r25, Y+20	; 0x14
    4a5a:	01 97       	sbiw	r24, 0x01	; 1
    4a5c:	9c 8b       	std	Y+20, r25	; 0x14
    4a5e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a60:	8b 89       	ldd	r24, Y+19	; 0x13
    4a62:	9c 89       	ldd	r25, Y+20	; 0x14
    4a64:	00 97       	sbiw	r24, 0x00	; 0
    4a66:	69 f7       	brne	.-38     	; 0x4a42 <BTN_u8BtnDebounce+0x1c6>
    4a68:	14 c0       	rjmp	.+40     	; 0x4a92 <BTN_u8BtnDebounce+0x216>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a6a:	6d 89       	ldd	r22, Y+21	; 0x15
    4a6c:	7e 89       	ldd	r23, Y+22	; 0x16
    4a6e:	8f 89       	ldd	r24, Y+23	; 0x17
    4a70:	98 8d       	ldd	r25, Y+24	; 0x18
    4a72:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a76:	dc 01       	movw	r26, r24
    4a78:	cb 01       	movw	r24, r22
    4a7a:	9c 8b       	std	Y+20, r25	; 0x14
    4a7c:	8b 8b       	std	Y+19, r24	; 0x13
    4a7e:	8b 89       	ldd	r24, Y+19	; 0x13
    4a80:	9c 89       	ldd	r25, Y+20	; 0x14
    4a82:	98 8b       	std	Y+16, r25	; 0x10
    4a84:	8f 87       	std	Y+15, r24	; 0x0f
    4a86:	8f 85       	ldd	r24, Y+15	; 0x0f
    4a88:	98 89       	ldd	r25, Y+16	; 0x10
    4a8a:	01 97       	sbiw	r24, 0x01	; 1
    4a8c:	f1 f7       	brne	.-4      	; 0x4a8a <BTN_u8BtnDebounce+0x20e>
    4a8e:	98 8b       	std	Y+16, r25	; 0x10
    4a90:	8f 87       	std	Y+15, r24	; 0x0f
		break;
	case BTN_INT1_ID:
		_delay_ms(DEBOUNCE_DELAY);
		return DIO_voidGetPinValue(BTN_INT1_REG, BTN_INT1_PIN);
    4a92:	83 e0       	ldi	r24, 0x03	; 3
    4a94:	63 e0       	ldi	r22, 0x03	; 3
    4a96:	0e 94 07 14 	call	0x280e	; 0x280e <DIO_voidGetPinValue>
    4a9a:	8c a7       	std	Y+44, r24	; 0x2c
    4a9c:	7a c0       	rjmp	.+244    	; 0x4b92 <BTN_u8BtnDebounce+0x316>
    4a9e:	80 e0       	ldi	r24, 0x00	; 0
    4aa0:	90 e0       	ldi	r25, 0x00	; 0
    4aa2:	a0 e2       	ldi	r26, 0x20	; 32
    4aa4:	b2 e4       	ldi	r27, 0x42	; 66
    4aa6:	8b 87       	std	Y+11, r24	; 0x0b
    4aa8:	9c 87       	std	Y+12, r25	; 0x0c
    4aaa:	ad 87       	std	Y+13, r26	; 0x0d
    4aac:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4aae:	6b 85       	ldd	r22, Y+11	; 0x0b
    4ab0:	7c 85       	ldd	r23, Y+12	; 0x0c
    4ab2:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ab4:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ab6:	20 e0       	ldi	r18, 0x00	; 0
    4ab8:	30 e0       	ldi	r19, 0x00	; 0
    4aba:	4a e7       	ldi	r20, 0x7A	; 122
    4abc:	55 e4       	ldi	r21, 0x45	; 69
    4abe:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    4ac2:	dc 01       	movw	r26, r24
    4ac4:	cb 01       	movw	r24, r22
    4ac6:	8f 83       	std	Y+7, r24	; 0x07
    4ac8:	98 87       	std	Y+8, r25	; 0x08
    4aca:	a9 87       	std	Y+9, r26	; 0x09
    4acc:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4ace:	6f 81       	ldd	r22, Y+7	; 0x07
    4ad0:	78 85       	ldd	r23, Y+8	; 0x08
    4ad2:	89 85       	ldd	r24, Y+9	; 0x09
    4ad4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ad6:	20 e0       	ldi	r18, 0x00	; 0
    4ad8:	30 e0       	ldi	r19, 0x00	; 0
    4ada:	40 e8       	ldi	r20, 0x80	; 128
    4adc:	5f e3       	ldi	r21, 0x3F	; 63
    4ade:	0e 94 cd 04 	call	0x99a	; 0x99a <__ltsf2>
    4ae2:	88 23       	and	r24, r24
    4ae4:	2c f4       	brge	.+10     	; 0x4af0 <BTN_u8BtnDebounce+0x274>
		__ticks = 1;
    4ae6:	81 e0       	ldi	r24, 0x01	; 1
    4ae8:	90 e0       	ldi	r25, 0x00	; 0
    4aea:	9e 83       	std	Y+6, r25	; 0x06
    4aec:	8d 83       	std	Y+5, r24	; 0x05
    4aee:	3f c0       	rjmp	.+126    	; 0x4b6e <BTN_u8BtnDebounce+0x2f2>
	else if (__tmp > 65535)
    4af0:	6f 81       	ldd	r22, Y+7	; 0x07
    4af2:	78 85       	ldd	r23, Y+8	; 0x08
    4af4:	89 85       	ldd	r24, Y+9	; 0x09
    4af6:	9a 85       	ldd	r25, Y+10	; 0x0a
    4af8:	20 e0       	ldi	r18, 0x00	; 0
    4afa:	3f ef       	ldi	r19, 0xFF	; 255
    4afc:	4f e7       	ldi	r20, 0x7F	; 127
    4afe:	57 e4       	ldi	r21, 0x47	; 71
    4b00:	0e 94 6d 04 	call	0x8da	; 0x8da <__gtsf2>
    4b04:	18 16       	cp	r1, r24
    4b06:	4c f5       	brge	.+82     	; 0x4b5a <BTN_u8BtnDebounce+0x2de>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4b08:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b0a:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b0c:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b0e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b10:	20 e0       	ldi	r18, 0x00	; 0
    4b12:	30 e0       	ldi	r19, 0x00	; 0
    4b14:	40 e2       	ldi	r20, 0x20	; 32
    4b16:	51 e4       	ldi	r21, 0x41	; 65
    4b18:	0e 94 c7 02 	call	0x58e	; 0x58e <__mulsf3>
    4b1c:	dc 01       	movw	r26, r24
    4b1e:	cb 01       	movw	r24, r22
    4b20:	bc 01       	movw	r22, r24
    4b22:	cd 01       	movw	r24, r26
    4b24:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b28:	dc 01       	movw	r26, r24
    4b2a:	cb 01       	movw	r24, r22
    4b2c:	9e 83       	std	Y+6, r25	; 0x06
    4b2e:	8d 83       	std	Y+5, r24	; 0x05
    4b30:	0f c0       	rjmp	.+30     	; 0x4b50 <BTN_u8BtnDebounce+0x2d4>
    4b32:	80 e9       	ldi	r24, 0x90	; 144
    4b34:	91 e0       	ldi	r25, 0x01	; 1
    4b36:	9c 83       	std	Y+4, r25	; 0x04
    4b38:	8b 83       	std	Y+3, r24	; 0x03
    4b3a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b3c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b3e:	01 97       	sbiw	r24, 0x01	; 1
    4b40:	f1 f7       	brne	.-4      	; 0x4b3e <BTN_u8BtnDebounce+0x2c2>
    4b42:	9c 83       	std	Y+4, r25	; 0x04
    4b44:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b46:	8d 81       	ldd	r24, Y+5	; 0x05
    4b48:	9e 81       	ldd	r25, Y+6	; 0x06
    4b4a:	01 97       	sbiw	r24, 0x01	; 1
    4b4c:	9e 83       	std	Y+6, r25	; 0x06
    4b4e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b50:	8d 81       	ldd	r24, Y+5	; 0x05
    4b52:	9e 81       	ldd	r25, Y+6	; 0x06
    4b54:	00 97       	sbiw	r24, 0x00	; 0
    4b56:	69 f7       	brne	.-38     	; 0x4b32 <BTN_u8BtnDebounce+0x2b6>
    4b58:	14 c0       	rjmp	.+40     	; 0x4b82 <BTN_u8BtnDebounce+0x306>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4b5a:	6f 81       	ldd	r22, Y+7	; 0x07
    4b5c:	78 85       	ldd	r23, Y+8	; 0x08
    4b5e:	89 85       	ldd	r24, Y+9	; 0x09
    4b60:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b62:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b66:	dc 01       	movw	r26, r24
    4b68:	cb 01       	movw	r24, r22
    4b6a:	9e 83       	std	Y+6, r25	; 0x06
    4b6c:	8d 83       	std	Y+5, r24	; 0x05
    4b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    4b70:	9e 81       	ldd	r25, Y+6	; 0x06
    4b72:	9a 83       	std	Y+2, r25	; 0x02
    4b74:	89 83       	std	Y+1, r24	; 0x01
    4b76:	89 81       	ldd	r24, Y+1	; 0x01
    4b78:	9a 81       	ldd	r25, Y+2	; 0x02
    4b7a:	01 97       	sbiw	r24, 0x01	; 1
    4b7c:	f1 f7       	brne	.-4      	; 0x4b7a <BTN_u8BtnDebounce+0x2fe>
    4b7e:	9a 83       	std	Y+2, r25	; 0x02
    4b80:	89 83       	std	Y+1, r24	; 0x01
		break;
	case BTN_INT2_ID:
		_delay_ms(DEBOUNCE_DELAY);
		return DIO_voidGetPinValue(BTN_INT2_REG, BTN_INT2_PIN);
    4b82:	81 e0       	ldi	r24, 0x01	; 1
    4b84:	62 e0       	ldi	r22, 0x02	; 2
    4b86:	0e 94 07 14 	call	0x280e	; 0x280e <DIO_voidGetPinValue>
    4b8a:	8c a7       	std	Y+44, r24	; 0x2c
    4b8c:	02 c0       	rjmp	.+4      	; 0x4b92 <BTN_u8BtnDebounce+0x316>
		break;
	default:
		return PIN_HIGH;
    4b8e:	91 e0       	ldi	r25, 0x01	; 1
    4b90:	9c a7       	std	Y+44, r25	; 0x2c
    4b92:	8c a5       	ldd	r24, Y+44	; 0x2c
		break;
	}
}
    4b94:	ae 96       	adiw	r28, 0x2e	; 46
    4b96:	0f b6       	in	r0, 0x3f	; 63
    4b98:	f8 94       	cli
    4b9a:	de bf       	out	0x3e, r29	; 62
    4b9c:	0f be       	out	0x3f, r0	; 63
    4b9e:	cd bf       	out	0x3d, r28	; 61
    4ba0:	cf 91       	pop	r28
    4ba2:	df 91       	pop	r29
    4ba4:	08 95       	ret

00004ba6 <BTN_voidInit>:

void BTN_voidInit(){
    4ba6:	df 93       	push	r29
    4ba8:	cf 93       	push	r28
    4baa:	cd b7       	in	r28, 0x3d	; 61
    4bac:	de b7       	in	r29, 0x3e	; 62

	/*** Pull up (Normally high) ***/
	DIO_voidSetPinDirection(BTN_INT0_REG, BTN_INT0_PIN, PIN_INPUT);
    4bae:	83 e0       	ldi	r24, 0x03	; 3
    4bb0:	62 e0       	ldi	r22, 0x02	; 2
    4bb2:	40 e0       	ldi	r20, 0x00	; 0
    4bb4:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(BTN_INT1_REG, BTN_INT1_PIN, PIN_INPUT);
    4bb8:	83 e0       	ldi	r24, 0x03	; 3
    4bba:	63 e0       	ldi	r22, 0x03	; 3
    4bbc:	40 e0       	ldi	r20, 0x00	; 0
    4bbe:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(BTN_INT2_REG, BTN_INT2_PIN, PIN_INPUT);
    4bc2:	81 e0       	ldi	r24, 0x01	; 1
    4bc4:	62 e0       	ldi	r22, 0x02	; 2
    4bc6:	40 e0       	ldi	r20, 0x00	; 0
    4bc8:	0e 94 85 11 	call	0x230a	; 0x230a <DIO_voidSetPinDirection>

}
    4bcc:	cf 91       	pop	r28
    4bce:	df 91       	pop	r29
    4bd0:	08 95       	ret

00004bd2 <BTN_u8IsBtnPressed>:

u8 BTN_u8IsBtnPressed(u8 copy_u8BtnID){
    4bd2:	df 93       	push	r29
    4bd4:	cf 93       	push	r28
    4bd6:	00 d0       	rcall	.+0      	; 0x4bd8 <BTN_u8IsBtnPressed+0x6>
    4bd8:	00 d0       	rcall	.+0      	; 0x4bda <BTN_u8IsBtnPressed+0x8>
    4bda:	cd b7       	in	r28, 0x3d	; 61
    4bdc:	de b7       	in	r29, 0x3e	; 62
    4bde:	89 83       	std	Y+1, r24	; 0x01

	switch(copy_u8BtnID){
    4be0:	89 81       	ldd	r24, Y+1	; 0x01
    4be2:	28 2f       	mov	r18, r24
    4be4:	30 e0       	ldi	r19, 0x00	; 0
    4be6:	3c 83       	std	Y+4, r19	; 0x04
    4be8:	2b 83       	std	Y+3, r18	; 0x03
    4bea:	8b 81       	ldd	r24, Y+3	; 0x03
    4bec:	9c 81       	ldd	r25, Y+4	; 0x04
    4bee:	81 30       	cpi	r24, 0x01	; 1
    4bf0:	91 05       	cpc	r25, r1
    4bf2:	91 f0       	breq	.+36     	; 0x4c18 <BTN_u8IsBtnPressed+0x46>
    4bf4:	2b 81       	ldd	r18, Y+3	; 0x03
    4bf6:	3c 81       	ldd	r19, Y+4	; 0x04
    4bf8:	22 30       	cpi	r18, 0x02	; 2
    4bfa:	31 05       	cpc	r19, r1
    4bfc:	b1 f0       	breq	.+44     	; 0x4c2a <BTN_u8IsBtnPressed+0x58>
    4bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    4c00:	9c 81       	ldd	r25, Y+4	; 0x04
    4c02:	00 97       	sbiw	r24, 0x00	; 0
    4c04:	d9 f4       	brne	.+54     	; 0x4c3c <BTN_u8IsBtnPressed+0x6a>
	case BTN_INT0_ID:
		return !BTN_u8BtnDebounce(BTN_INT0_ID);
    4c06:	80 e0       	ldi	r24, 0x00	; 0
    4c08:	0e 94 3e 24 	call	0x487c	; 0x487c <BTN_u8BtnDebounce>
    4c0c:	1a 82       	std	Y+2, r1	; 0x02
    4c0e:	88 23       	and	r24, r24
    4c10:	b1 f4       	brne	.+44     	; 0x4c3e <BTN_u8IsBtnPressed+0x6c>
    4c12:	91 e0       	ldi	r25, 0x01	; 1
    4c14:	9a 83       	std	Y+2, r25	; 0x02
    4c16:	13 c0       	rjmp	.+38     	; 0x4c3e <BTN_u8IsBtnPressed+0x6c>
		break;
	case BTN_INT1_ID:
		return !BTN_u8BtnDebounce(BTN_INT1_ID);
    4c18:	81 e0       	ldi	r24, 0x01	; 1
    4c1a:	0e 94 3e 24 	call	0x487c	; 0x487c <BTN_u8BtnDebounce>
    4c1e:	1a 82       	std	Y+2, r1	; 0x02
    4c20:	88 23       	and	r24, r24
    4c22:	69 f4       	brne	.+26     	; 0x4c3e <BTN_u8IsBtnPressed+0x6c>
    4c24:	21 e0       	ldi	r18, 0x01	; 1
    4c26:	2a 83       	std	Y+2, r18	; 0x02
    4c28:	0a c0       	rjmp	.+20     	; 0x4c3e <BTN_u8IsBtnPressed+0x6c>
		break;
	case BTN_INT2_ID:
		return !BTN_u8BtnDebounce(BTN_INT2_ID);
    4c2a:	82 e0       	ldi	r24, 0x02	; 2
    4c2c:	0e 94 3e 24 	call	0x487c	; 0x487c <BTN_u8BtnDebounce>
    4c30:	1a 82       	std	Y+2, r1	; 0x02
    4c32:	88 23       	and	r24, r24
    4c34:	21 f4       	brne	.+8      	; 0x4c3e <BTN_u8IsBtnPressed+0x6c>
    4c36:	31 e0       	ldi	r19, 0x01	; 1
    4c38:	3a 83       	std	Y+2, r19	; 0x02
    4c3a:	01 c0       	rjmp	.+2      	; 0x4c3e <BTN_u8IsBtnPressed+0x6c>
		break;
	default:
		return 0;
    4c3c:	1a 82       	std	Y+2, r1	; 0x02
    4c3e:	8a 81       	ldd	r24, Y+2	; 0x02
		break;
	}

}
    4c40:	0f 90       	pop	r0
    4c42:	0f 90       	pop	r0
    4c44:	0f 90       	pop	r0
    4c46:	0f 90       	pop	r0
    4c48:	cf 91       	pop	r28
    4c4a:	df 91       	pop	r29
    4c4c:	08 95       	ret

00004c4e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    4c4e:	df 93       	push	r29
    4c50:	cf 93       	push	r28
    4c52:	cd b7       	in	r28, 0x3d	; 61
    4c54:	de b7       	in	r29, 0x3e	; 62
    4c56:	27 97       	sbiw	r28, 0x07	; 7
    4c58:	0f b6       	in	r0, 0x3f	; 63
    4c5a:	f8 94       	cli
    4c5c:	de bf       	out	0x3e, r29	; 62
    4c5e:	0f be       	out	0x3f, r0	; 63
    4c60:	cd bf       	out	0x3d, r28	; 61
    4c62:	9d 83       	std	Y+5, r25	; 0x05
    4c64:	8c 83       	std	Y+4, r24	; 0x04
    4c66:	6e 83       	std	Y+6, r22	; 0x06
    4c68:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    4c6a:	8a e1       	ldi	r24, 0x1A	; 26
    4c6c:	90 e0       	ldi	r25, 0x00	; 0
    4c6e:	0e 94 ff 28 	call	0x51fe	; 0x51fe <pvPortMalloc>
    4c72:	9a 83       	std	Y+2, r25	; 0x02
    4c74:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    4c76:	89 81       	ldd	r24, Y+1	; 0x01
    4c78:	9a 81       	ldd	r25, Y+2	; 0x02
    4c7a:	00 97       	sbiw	r24, 0x00	; 0
    4c7c:	09 f4       	brne	.+2      	; 0x4c80 <xCoRoutineCreate+0x32>
    4c7e:	6f c0       	rjmp	.+222    	; 0x4d5e <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    4c80:	80 91 ca 01 	lds	r24, 0x01CA
    4c84:	90 91 cb 01 	lds	r25, 0x01CB
    4c88:	00 97       	sbiw	r24, 0x00	; 0
    4c8a:	41 f4       	brne	.+16     	; 0x4c9c <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    4c8c:	89 81       	ldd	r24, Y+1	; 0x01
    4c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    4c90:	90 93 cb 01 	sts	0x01CB, r25
    4c94:	80 93 ca 01 	sts	0x01CA, r24
			prvInitialiseCoRoutineLists();
    4c98:	0e 94 8e 28 	call	0x511c	; 0x511c <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    4c9c:	8e 81       	ldd	r24, Y+6	; 0x06
    4c9e:	82 30       	cpi	r24, 0x02	; 2
    4ca0:	10 f0       	brcs	.+4      	; 0x4ca6 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    4ca2:	81 e0       	ldi	r24, 0x01	; 1
    4ca4:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    4ca6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ca8:	fa 81       	ldd	r31, Y+2	; 0x02
    4caa:	11 8e       	std	Z+25, r1	; 0x19
    4cac:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    4cae:	e9 81       	ldd	r30, Y+1	; 0x01
    4cb0:	fa 81       	ldd	r31, Y+2	; 0x02
    4cb2:	8e 81       	ldd	r24, Y+6	; 0x06
    4cb4:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    4cb6:	e9 81       	ldd	r30, Y+1	; 0x01
    4cb8:	fa 81       	ldd	r31, Y+2	; 0x02
    4cba:	8f 81       	ldd	r24, Y+7	; 0x07
    4cbc:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    4cbe:	e9 81       	ldd	r30, Y+1	; 0x01
    4cc0:	fa 81       	ldd	r31, Y+2	; 0x02
    4cc2:	8c 81       	ldd	r24, Y+4	; 0x04
    4cc4:	9d 81       	ldd	r25, Y+5	; 0x05
    4cc6:	91 83       	std	Z+1, r25	; 0x01
    4cc8:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    4cca:	89 81       	ldd	r24, Y+1	; 0x01
    4ccc:	9a 81       	ldd	r25, Y+2	; 0x02
    4cce:	02 96       	adiw	r24, 0x02	; 2
    4cd0:	0e 94 95 29 	call	0x532a	; 0x532a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    4cd4:	89 81       	ldd	r24, Y+1	; 0x01
    4cd6:	9a 81       	ldd	r25, Y+2	; 0x02
    4cd8:	0c 96       	adiw	r24, 0x0c	; 12
    4cda:	0e 94 95 29 	call	0x532a	; 0x532a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    4cde:	e9 81       	ldd	r30, Y+1	; 0x01
    4ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ce2:	89 81       	ldd	r24, Y+1	; 0x01
    4ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ce6:	91 87       	std	Z+9, r25	; 0x09
    4ce8:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    4cea:	e9 81       	ldd	r30, Y+1	; 0x01
    4cec:	fa 81       	ldd	r31, Y+2	; 0x02
    4cee:	89 81       	ldd	r24, Y+1	; 0x01
    4cf0:	9a 81       	ldd	r25, Y+2	; 0x02
    4cf2:	93 8b       	std	Z+19, r25	; 0x13
    4cf4:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4cf6:	8e 81       	ldd	r24, Y+6	; 0x06
    4cf8:	28 2f       	mov	r18, r24
    4cfa:	30 e0       	ldi	r19, 0x00	; 0
    4cfc:	86 e0       	ldi	r24, 0x06	; 6
    4cfe:	90 e0       	ldi	r25, 0x00	; 0
    4d00:	82 1b       	sub	r24, r18
    4d02:	93 0b       	sbc	r25, r19
    4d04:	e9 81       	ldd	r30, Y+1	; 0x01
    4d06:	fa 81       	ldd	r31, Y+2	; 0x02
    4d08:	95 87       	std	Z+13, r25	; 0x0d
    4d0a:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    4d0c:	e9 81       	ldd	r30, Y+1	; 0x01
    4d0e:	fa 81       	ldd	r31, Y+2	; 0x02
    4d10:	96 89       	ldd	r25, Z+22	; 0x16
    4d12:	80 91 cc 01 	lds	r24, 0x01CC
    4d16:	89 17       	cp	r24, r25
    4d18:	28 f4       	brcc	.+10     	; 0x4d24 <xCoRoutineCreate+0xd6>
    4d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d1e:	86 89       	ldd	r24, Z+22	; 0x16
    4d20:	80 93 cc 01 	sts	0x01CC, r24
    4d24:	e9 81       	ldd	r30, Y+1	; 0x01
    4d26:	fa 81       	ldd	r31, Y+2	; 0x02
    4d28:	86 89       	ldd	r24, Z+22	; 0x16
    4d2a:	28 2f       	mov	r18, r24
    4d2c:	30 e0       	ldi	r19, 0x00	; 0
    4d2e:	c9 01       	movw	r24, r18
    4d30:	88 0f       	add	r24, r24
    4d32:	99 1f       	adc	r25, r25
    4d34:	88 0f       	add	r24, r24
    4d36:	99 1f       	adc	r25, r25
    4d38:	88 0f       	add	r24, r24
    4d3a:	99 1f       	adc	r25, r25
    4d3c:	82 0f       	add	r24, r18
    4d3e:	93 1f       	adc	r25, r19
    4d40:	ac 01       	movw	r20, r24
    4d42:	4d 52       	subi	r20, 0x2D	; 45
    4d44:	5e 4f       	sbci	r21, 0xFE	; 254
    4d46:	89 81       	ldd	r24, Y+1	; 0x01
    4d48:	9a 81       	ldd	r25, Y+2	; 0x02
    4d4a:	9c 01       	movw	r18, r24
    4d4c:	2e 5f       	subi	r18, 0xFE	; 254
    4d4e:	3f 4f       	sbci	r19, 0xFF	; 255
    4d50:	ca 01       	movw	r24, r20
    4d52:	b9 01       	movw	r22, r18
    4d54:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>

		xReturn = pdPASS;
    4d58:	81 e0       	ldi	r24, 0x01	; 1
    4d5a:	8b 83       	std	Y+3, r24	; 0x03
    4d5c:	02 c0       	rjmp	.+4      	; 0x4d62 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4d5e:	8f ef       	ldi	r24, 0xFF	; 255
    4d60:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    4d62:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4d64:	27 96       	adiw	r28, 0x07	; 7
    4d66:	0f b6       	in	r0, 0x3f	; 63
    4d68:	f8 94       	cli
    4d6a:	de bf       	out	0x3e, r29	; 62
    4d6c:	0f be       	out	0x3f, r0	; 63
    4d6e:	cd bf       	out	0x3d, r28	; 61
    4d70:	cf 91       	pop	r28
    4d72:	df 91       	pop	r29
    4d74:	08 95       	ret

00004d76 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    4d76:	df 93       	push	r29
    4d78:	cf 93       	push	r28
    4d7a:	00 d0       	rcall	.+0      	; 0x4d7c <vCoRoutineAddToDelayedList+0x6>
    4d7c:	00 d0       	rcall	.+0      	; 0x4d7e <vCoRoutineAddToDelayedList+0x8>
    4d7e:	00 d0       	rcall	.+0      	; 0x4d80 <vCoRoutineAddToDelayedList+0xa>
    4d80:	cd b7       	in	r28, 0x3d	; 61
    4d82:	de b7       	in	r29, 0x3e	; 62
    4d84:	9c 83       	std	Y+4, r25	; 0x04
    4d86:	8b 83       	std	Y+3, r24	; 0x03
    4d88:	7e 83       	std	Y+6, r23	; 0x06
    4d8a:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    4d8c:	20 91 cd 01 	lds	r18, 0x01CD
    4d90:	30 91 ce 01 	lds	r19, 0x01CE
    4d94:	8b 81       	ldd	r24, Y+3	; 0x03
    4d96:	9c 81       	ldd	r25, Y+4	; 0x04
    4d98:	82 0f       	add	r24, r18
    4d9a:	93 1f       	adc	r25, r19
    4d9c:	9a 83       	std	Y+2, r25	; 0x02
    4d9e:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4da0:	80 91 ca 01 	lds	r24, 0x01CA
    4da4:	90 91 cb 01 	lds	r25, 0x01CB
    4da8:	02 96       	adiw	r24, 0x02	; 2
    4daa:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    4dae:	e0 91 ca 01 	lds	r30, 0x01CA
    4db2:	f0 91 cb 01 	lds	r31, 0x01CB
    4db6:	89 81       	ldd	r24, Y+1	; 0x01
    4db8:	9a 81       	ldd	r25, Y+2	; 0x02
    4dba:	93 83       	std	Z+3, r25	; 0x03
    4dbc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    4dbe:	20 91 cd 01 	lds	r18, 0x01CD
    4dc2:	30 91 ce 01 	lds	r19, 0x01CE
    4dc6:	89 81       	ldd	r24, Y+1	; 0x01
    4dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    4dca:	82 17       	cp	r24, r18
    4dcc:	93 07       	cpc	r25, r19
    4dce:	70 f4       	brcc	.+28     	; 0x4dec <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4dd0:	80 91 f9 01 	lds	r24, 0x01F9
    4dd4:	90 91 fa 01 	lds	r25, 0x01FA
    4dd8:	20 91 ca 01 	lds	r18, 0x01CA
    4ddc:	30 91 cb 01 	lds	r19, 0x01CB
    4de0:	2e 5f       	subi	r18, 0xFE	; 254
    4de2:	3f 4f       	sbci	r19, 0xFF	; 255
    4de4:	b9 01       	movw	r22, r18
    4de6:	0e 94 f1 29 	call	0x53e2	; 0x53e2 <vListInsert>
    4dea:	0d c0       	rjmp	.+26     	; 0x4e06 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    4dec:	80 91 f7 01 	lds	r24, 0x01F7
    4df0:	90 91 f8 01 	lds	r25, 0x01F8
    4df4:	20 91 ca 01 	lds	r18, 0x01CA
    4df8:	30 91 cb 01 	lds	r19, 0x01CB
    4dfc:	2e 5f       	subi	r18, 0xFE	; 254
    4dfe:	3f 4f       	sbci	r19, 0xFF	; 255
    4e00:	b9 01       	movw	r22, r18
    4e02:	0e 94 f1 29 	call	0x53e2	; 0x53e2 <vListInsert>
	}

	if( pxEventList )
    4e06:	8d 81       	ldd	r24, Y+5	; 0x05
    4e08:	9e 81       	ldd	r25, Y+6	; 0x06
    4e0a:	00 97       	sbiw	r24, 0x00	; 0
    4e0c:	61 f0       	breq	.+24     	; 0x4e26 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    4e0e:	80 91 ca 01 	lds	r24, 0x01CA
    4e12:	90 91 cb 01 	lds	r25, 0x01CB
    4e16:	9c 01       	movw	r18, r24
    4e18:	24 5f       	subi	r18, 0xF4	; 244
    4e1a:	3f 4f       	sbci	r19, 0xFF	; 255
    4e1c:	8d 81       	ldd	r24, Y+5	; 0x05
    4e1e:	9e 81       	ldd	r25, Y+6	; 0x06
    4e20:	b9 01       	movw	r22, r18
    4e22:	0e 94 f1 29 	call	0x53e2	; 0x53e2 <vListInsert>
	}
}
    4e26:	26 96       	adiw	r28, 0x06	; 6
    4e28:	0f b6       	in	r0, 0x3f	; 63
    4e2a:	f8 94       	cli
    4e2c:	de bf       	out	0x3e, r29	; 62
    4e2e:	0f be       	out	0x3f, r0	; 63
    4e30:	cd bf       	out	0x3d, r28	; 61
    4e32:	cf 91       	pop	r28
    4e34:	df 91       	pop	r29
    4e36:	08 95       	ret

00004e38 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    4e38:	df 93       	push	r29
    4e3a:	cf 93       	push	r28
    4e3c:	00 d0       	rcall	.+0      	; 0x4e3e <prvCheckPendingReadyList+0x6>
    4e3e:	cd b7       	in	r28, 0x3d	; 61
    4e40:	de b7       	in	r29, 0x3e	; 62
    4e42:	3a c0       	rjmp	.+116    	; 0x4eb8 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    4e44:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    4e46:	e0 91 00 02 	lds	r30, 0x0200
    4e4a:	f0 91 01 02 	lds	r31, 0x0201
    4e4e:	86 81       	ldd	r24, Z+6	; 0x06
    4e50:	97 81       	ldd	r25, Z+7	; 0x07
    4e52:	9a 83       	std	Y+2, r25	; 0x02
    4e54:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    4e56:	89 81       	ldd	r24, Y+1	; 0x01
    4e58:	9a 81       	ldd	r25, Y+2	; 0x02
    4e5a:	0c 96       	adiw	r24, 0x0c	; 12
    4e5c:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
		}
		portENABLE_INTERRUPTS();
    4e60:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    4e62:	89 81       	ldd	r24, Y+1	; 0x01
    4e64:	9a 81       	ldd	r25, Y+2	; 0x02
    4e66:	02 96       	adiw	r24, 0x02	; 2
    4e68:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    4e6c:	e9 81       	ldd	r30, Y+1	; 0x01
    4e6e:	fa 81       	ldd	r31, Y+2	; 0x02
    4e70:	96 89       	ldd	r25, Z+22	; 0x16
    4e72:	80 91 cc 01 	lds	r24, 0x01CC
    4e76:	89 17       	cp	r24, r25
    4e78:	28 f4       	brcc	.+10     	; 0x4e84 <prvCheckPendingReadyList+0x4c>
    4e7a:	e9 81       	ldd	r30, Y+1	; 0x01
    4e7c:	fa 81       	ldd	r31, Y+2	; 0x02
    4e7e:	86 89       	ldd	r24, Z+22	; 0x16
    4e80:	80 93 cc 01 	sts	0x01CC, r24
    4e84:	e9 81       	ldd	r30, Y+1	; 0x01
    4e86:	fa 81       	ldd	r31, Y+2	; 0x02
    4e88:	86 89       	ldd	r24, Z+22	; 0x16
    4e8a:	28 2f       	mov	r18, r24
    4e8c:	30 e0       	ldi	r19, 0x00	; 0
    4e8e:	c9 01       	movw	r24, r18
    4e90:	88 0f       	add	r24, r24
    4e92:	99 1f       	adc	r25, r25
    4e94:	88 0f       	add	r24, r24
    4e96:	99 1f       	adc	r25, r25
    4e98:	88 0f       	add	r24, r24
    4e9a:	99 1f       	adc	r25, r25
    4e9c:	82 0f       	add	r24, r18
    4e9e:	93 1f       	adc	r25, r19
    4ea0:	ac 01       	movw	r20, r24
    4ea2:	4d 52       	subi	r20, 0x2D	; 45
    4ea4:	5e 4f       	sbci	r21, 0xFE	; 254
    4ea6:	89 81       	ldd	r24, Y+1	; 0x01
    4ea8:	9a 81       	ldd	r25, Y+2	; 0x02
    4eaa:	9c 01       	movw	r18, r24
    4eac:	2e 5f       	subi	r18, 0xFE	; 254
    4eae:	3f 4f       	sbci	r19, 0xFF	; 255
    4eb0:	ca 01       	movw	r24, r20
    4eb2:	b9 01       	movw	r22, r18
    4eb4:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    4eb8:	80 91 fb 01 	lds	r24, 0x01FB
    4ebc:	88 23       	and	r24, r24
    4ebe:	09 f0       	breq	.+2      	; 0x4ec2 <prvCheckPendingReadyList+0x8a>
    4ec0:	c1 cf       	rjmp	.-126    	; 0x4e44 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    4ec2:	0f 90       	pop	r0
    4ec4:	0f 90       	pop	r0
    4ec6:	cf 91       	pop	r28
    4ec8:	df 91       	pop	r29
    4eca:	08 95       	ret

00004ecc <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    4ecc:	df 93       	push	r29
    4ece:	cf 93       	push	r28
    4ed0:	00 d0       	rcall	.+0      	; 0x4ed2 <prvCheckDelayedList+0x6>
    4ed2:	00 d0       	rcall	.+0      	; 0x4ed4 <prvCheckDelayedList+0x8>
    4ed4:	cd b7       	in	r28, 0x3d	; 61
    4ed6:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    4ed8:	0e 94 49 36 	call	0x6c92	; 0x6c92 <xTaskGetTickCount>
    4edc:	20 91 cf 01 	lds	r18, 0x01CF
    4ee0:	30 91 d0 01 	lds	r19, 0x01D0
    4ee4:	82 1b       	sub	r24, r18
    4ee6:	93 0b       	sbc	r25, r19
    4ee8:	90 93 d2 01 	sts	0x01D2, r25
    4eec:	80 93 d1 01 	sts	0x01D1, r24
    4ef0:	85 c0       	rjmp	.+266    	; 0x4ffc <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    4ef2:	80 91 cd 01 	lds	r24, 0x01CD
    4ef6:	90 91 ce 01 	lds	r25, 0x01CE
    4efa:	01 96       	adiw	r24, 0x01	; 1
    4efc:	90 93 ce 01 	sts	0x01CE, r25
    4f00:	80 93 cd 01 	sts	0x01CD, r24
		xPassedTicks--;
    4f04:	80 91 d1 01 	lds	r24, 0x01D1
    4f08:	90 91 d2 01 	lds	r25, 0x01D2
    4f0c:	01 97       	sbiw	r24, 0x01	; 1
    4f0e:	90 93 d2 01 	sts	0x01D2, r25
    4f12:	80 93 d1 01 	sts	0x01D1, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    4f16:	80 91 cd 01 	lds	r24, 0x01CD
    4f1a:	90 91 ce 01 	lds	r25, 0x01CE
    4f1e:	00 97       	sbiw	r24, 0x00	; 0
    4f20:	09 f0       	breq	.+2      	; 0x4f24 <prvCheckDelayedList+0x58>
    4f22:	64 c0       	rjmp	.+200    	; 0x4fec <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    4f24:	80 91 f7 01 	lds	r24, 0x01F7
    4f28:	90 91 f8 01 	lds	r25, 0x01F8
    4f2c:	9a 83       	std	Y+2, r25	; 0x02
    4f2e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    4f30:	80 91 f9 01 	lds	r24, 0x01F9
    4f34:	90 91 fa 01 	lds	r25, 0x01FA
    4f38:	90 93 f8 01 	sts	0x01F8, r25
    4f3c:	80 93 f7 01 	sts	0x01F7, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    4f40:	89 81       	ldd	r24, Y+1	; 0x01
    4f42:	9a 81       	ldd	r25, Y+2	; 0x02
    4f44:	90 93 fa 01 	sts	0x01FA, r25
    4f48:	80 93 f9 01 	sts	0x01F9, r24
    4f4c:	4f c0       	rjmp	.+158    	; 0x4fec <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    4f4e:	e0 91 f7 01 	lds	r30, 0x01F7
    4f52:	f0 91 f8 01 	lds	r31, 0x01F8
    4f56:	05 80       	ldd	r0, Z+5	; 0x05
    4f58:	f6 81       	ldd	r31, Z+6	; 0x06
    4f5a:	e0 2d       	mov	r30, r0
    4f5c:	86 81       	ldd	r24, Z+6	; 0x06
    4f5e:	97 81       	ldd	r25, Z+7	; 0x07
    4f60:	9c 83       	std	Y+4, r25	; 0x04
    4f62:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    4f64:	eb 81       	ldd	r30, Y+3	; 0x03
    4f66:	fc 81       	ldd	r31, Y+4	; 0x04
    4f68:	22 81       	ldd	r18, Z+2	; 0x02
    4f6a:	33 81       	ldd	r19, Z+3	; 0x03
    4f6c:	80 91 cd 01 	lds	r24, 0x01CD
    4f70:	90 91 ce 01 	lds	r25, 0x01CE
    4f74:	82 17       	cp	r24, r18
    4f76:	93 07       	cpc	r25, r19
    4f78:	08 f4       	brcc	.+2      	; 0x4f7c <prvCheckDelayedList+0xb0>
    4f7a:	40 c0       	rjmp	.+128    	; 0x4ffc <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    4f7c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    4f7e:	8b 81       	ldd	r24, Y+3	; 0x03
    4f80:	9c 81       	ldd	r25, Y+4	; 0x04
    4f82:	02 96       	adiw	r24, 0x02	; 2
    4f84:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    4f88:	eb 81       	ldd	r30, Y+3	; 0x03
    4f8a:	fc 81       	ldd	r31, Y+4	; 0x04
    4f8c:	84 89       	ldd	r24, Z+20	; 0x14
    4f8e:	95 89       	ldd	r25, Z+21	; 0x15
    4f90:	00 97       	sbiw	r24, 0x00	; 0
    4f92:	29 f0       	breq	.+10     	; 0x4f9e <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    4f94:	8b 81       	ldd	r24, Y+3	; 0x03
    4f96:	9c 81       	ldd	r25, Y+4	; 0x04
    4f98:	0c 96       	adiw	r24, 0x0c	; 12
    4f9a:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    4f9e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    4fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    4fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    4fa4:	96 89       	ldd	r25, Z+22	; 0x16
    4fa6:	80 91 cc 01 	lds	r24, 0x01CC
    4faa:	89 17       	cp	r24, r25
    4fac:	28 f4       	brcc	.+10     	; 0x4fb8 <prvCheckDelayedList+0xec>
    4fae:	eb 81       	ldd	r30, Y+3	; 0x03
    4fb0:	fc 81       	ldd	r31, Y+4	; 0x04
    4fb2:	86 89       	ldd	r24, Z+22	; 0x16
    4fb4:	80 93 cc 01 	sts	0x01CC, r24
    4fb8:	eb 81       	ldd	r30, Y+3	; 0x03
    4fba:	fc 81       	ldd	r31, Y+4	; 0x04
    4fbc:	86 89       	ldd	r24, Z+22	; 0x16
    4fbe:	28 2f       	mov	r18, r24
    4fc0:	30 e0       	ldi	r19, 0x00	; 0
    4fc2:	c9 01       	movw	r24, r18
    4fc4:	88 0f       	add	r24, r24
    4fc6:	99 1f       	adc	r25, r25
    4fc8:	88 0f       	add	r24, r24
    4fca:	99 1f       	adc	r25, r25
    4fcc:	88 0f       	add	r24, r24
    4fce:	99 1f       	adc	r25, r25
    4fd0:	82 0f       	add	r24, r18
    4fd2:	93 1f       	adc	r25, r19
    4fd4:	ac 01       	movw	r20, r24
    4fd6:	4d 52       	subi	r20, 0x2D	; 45
    4fd8:	5e 4f       	sbci	r21, 0xFE	; 254
    4fda:	8b 81       	ldd	r24, Y+3	; 0x03
    4fdc:	9c 81       	ldd	r25, Y+4	; 0x04
    4fde:	9c 01       	movw	r18, r24
    4fe0:	2e 5f       	subi	r18, 0xFE	; 254
    4fe2:	3f 4f       	sbci	r19, 0xFF	; 255
    4fe4:	ca 01       	movw	r24, r20
    4fe6:	b9 01       	movw	r22, r18
    4fe8:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    4fec:	e0 91 f7 01 	lds	r30, 0x01F7
    4ff0:	f0 91 f8 01 	lds	r31, 0x01F8
    4ff4:	80 81       	ld	r24, Z
    4ff6:	88 23       	and	r24, r24
    4ff8:	09 f0       	breq	.+2      	; 0x4ffc <prvCheckDelayedList+0x130>
    4ffa:	a9 cf       	rjmp	.-174    	; 0x4f4e <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    4ffc:	80 91 d1 01 	lds	r24, 0x01D1
    5000:	90 91 d2 01 	lds	r25, 0x01D2
    5004:	00 97       	sbiw	r24, 0x00	; 0
    5006:	09 f0       	breq	.+2      	; 0x500a <prvCheckDelayedList+0x13e>
    5008:	74 cf       	rjmp	.-280    	; 0x4ef2 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    500a:	80 91 cd 01 	lds	r24, 0x01CD
    500e:	90 91 ce 01 	lds	r25, 0x01CE
    5012:	90 93 d0 01 	sts	0x01D0, r25
    5016:	80 93 cf 01 	sts	0x01CF, r24
}
    501a:	0f 90       	pop	r0
    501c:	0f 90       	pop	r0
    501e:	0f 90       	pop	r0
    5020:	0f 90       	pop	r0
    5022:	cf 91       	pop	r28
    5024:	df 91       	pop	r29
    5026:	08 95       	ret

00005028 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    5028:	df 93       	push	r29
    502a:	cf 93       	push	r28
    502c:	00 d0       	rcall	.+0      	; 0x502e <vCoRoutineSchedule+0x6>
    502e:	cd b7       	in	r28, 0x3d	; 61
    5030:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    5032:	0e 94 1c 27 	call	0x4e38	; 0x4e38 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    5036:	0e 94 66 27 	call	0x4ecc	; 0x4ecc <prvCheckDelayedList>
    503a:	0a c0       	rjmp	.+20     	; 0x5050 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    503c:	80 91 cc 01 	lds	r24, 0x01CC
    5040:	88 23       	and	r24, r24
    5042:	09 f4       	brne	.+2      	; 0x5046 <vCoRoutineSchedule+0x1e>
    5044:	66 c0       	rjmp	.+204    	; 0x5112 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    5046:	80 91 cc 01 	lds	r24, 0x01CC
    504a:	81 50       	subi	r24, 0x01	; 1
    504c:	80 93 cc 01 	sts	0x01CC, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    5050:	80 91 cc 01 	lds	r24, 0x01CC
    5054:	28 2f       	mov	r18, r24
    5056:	30 e0       	ldi	r19, 0x00	; 0
    5058:	c9 01       	movw	r24, r18
    505a:	88 0f       	add	r24, r24
    505c:	99 1f       	adc	r25, r25
    505e:	88 0f       	add	r24, r24
    5060:	99 1f       	adc	r25, r25
    5062:	88 0f       	add	r24, r24
    5064:	99 1f       	adc	r25, r25
    5066:	82 0f       	add	r24, r18
    5068:	93 1f       	adc	r25, r19
    506a:	fc 01       	movw	r30, r24
    506c:	ed 52       	subi	r30, 0x2D	; 45
    506e:	fe 4f       	sbci	r31, 0xFE	; 254
    5070:	80 81       	ld	r24, Z
    5072:	88 23       	and	r24, r24
    5074:	19 f3       	breq	.-58     	; 0x503c <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    5076:	80 91 cc 01 	lds	r24, 0x01CC
    507a:	28 2f       	mov	r18, r24
    507c:	30 e0       	ldi	r19, 0x00	; 0
    507e:	c9 01       	movw	r24, r18
    5080:	88 0f       	add	r24, r24
    5082:	99 1f       	adc	r25, r25
    5084:	88 0f       	add	r24, r24
    5086:	99 1f       	adc	r25, r25
    5088:	88 0f       	add	r24, r24
    508a:	99 1f       	adc	r25, r25
    508c:	82 0f       	add	r24, r18
    508e:	93 1f       	adc	r25, r19
    5090:	8d 52       	subi	r24, 0x2D	; 45
    5092:	9e 4f       	sbci	r25, 0xFE	; 254
    5094:	9a 83       	std	Y+2, r25	; 0x02
    5096:	89 83       	std	Y+1, r24	; 0x01
    5098:	e9 81       	ldd	r30, Y+1	; 0x01
    509a:	fa 81       	ldd	r31, Y+2	; 0x02
    509c:	01 80       	ldd	r0, Z+1	; 0x01
    509e:	f2 81       	ldd	r31, Z+2	; 0x02
    50a0:	e0 2d       	mov	r30, r0
    50a2:	82 81       	ldd	r24, Z+2	; 0x02
    50a4:	93 81       	ldd	r25, Z+3	; 0x03
    50a6:	e9 81       	ldd	r30, Y+1	; 0x01
    50a8:	fa 81       	ldd	r31, Y+2	; 0x02
    50aa:	92 83       	std	Z+2, r25	; 0x02
    50ac:	81 83       	std	Z+1, r24	; 0x01
    50ae:	e9 81       	ldd	r30, Y+1	; 0x01
    50b0:	fa 81       	ldd	r31, Y+2	; 0x02
    50b2:	21 81       	ldd	r18, Z+1	; 0x01
    50b4:	32 81       	ldd	r19, Z+2	; 0x02
    50b6:	89 81       	ldd	r24, Y+1	; 0x01
    50b8:	9a 81       	ldd	r25, Y+2	; 0x02
    50ba:	03 96       	adiw	r24, 0x03	; 3
    50bc:	28 17       	cp	r18, r24
    50be:	39 07       	cpc	r19, r25
    50c0:	59 f4       	brne	.+22     	; 0x50d8 <vCoRoutineSchedule+0xb0>
    50c2:	e9 81       	ldd	r30, Y+1	; 0x01
    50c4:	fa 81       	ldd	r31, Y+2	; 0x02
    50c6:	01 80       	ldd	r0, Z+1	; 0x01
    50c8:	f2 81       	ldd	r31, Z+2	; 0x02
    50ca:	e0 2d       	mov	r30, r0
    50cc:	82 81       	ldd	r24, Z+2	; 0x02
    50ce:	93 81       	ldd	r25, Z+3	; 0x03
    50d0:	e9 81       	ldd	r30, Y+1	; 0x01
    50d2:	fa 81       	ldd	r31, Y+2	; 0x02
    50d4:	92 83       	std	Z+2, r25	; 0x02
    50d6:	81 83       	std	Z+1, r24	; 0x01
    50d8:	e9 81       	ldd	r30, Y+1	; 0x01
    50da:	fa 81       	ldd	r31, Y+2	; 0x02
    50dc:	01 80       	ldd	r0, Z+1	; 0x01
    50de:	f2 81       	ldd	r31, Z+2	; 0x02
    50e0:	e0 2d       	mov	r30, r0
    50e2:	86 81       	ldd	r24, Z+6	; 0x06
    50e4:	97 81       	ldd	r25, Z+7	; 0x07
    50e6:	90 93 cb 01 	sts	0x01CB, r25
    50ea:	80 93 ca 01 	sts	0x01CA, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    50ee:	e0 91 ca 01 	lds	r30, 0x01CA
    50f2:	f0 91 cb 01 	lds	r31, 0x01CB
    50f6:	40 81       	ld	r20, Z
    50f8:	51 81       	ldd	r21, Z+1	; 0x01
    50fa:	80 91 ca 01 	lds	r24, 0x01CA
    50fe:	90 91 cb 01 	lds	r25, 0x01CB
    5102:	e0 91 ca 01 	lds	r30, 0x01CA
    5106:	f0 91 cb 01 	lds	r31, 0x01CB
    510a:	27 89       	ldd	r18, Z+23	; 0x17
    510c:	62 2f       	mov	r22, r18
    510e:	fa 01       	movw	r30, r20
    5110:	09 95       	icall

	return;
}
    5112:	0f 90       	pop	r0
    5114:	0f 90       	pop	r0
    5116:	cf 91       	pop	r28
    5118:	df 91       	pop	r29
    511a:	08 95       	ret

0000511c <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    511c:	df 93       	push	r29
    511e:	cf 93       	push	r28
    5120:	0f 92       	push	r0
    5122:	cd b7       	in	r28, 0x3d	; 61
    5124:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    5126:	19 82       	std	Y+1, r1	; 0x01
    5128:	13 c0       	rjmp	.+38     	; 0x5150 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    512a:	89 81       	ldd	r24, Y+1	; 0x01
    512c:	28 2f       	mov	r18, r24
    512e:	30 e0       	ldi	r19, 0x00	; 0
    5130:	c9 01       	movw	r24, r18
    5132:	88 0f       	add	r24, r24
    5134:	99 1f       	adc	r25, r25
    5136:	88 0f       	add	r24, r24
    5138:	99 1f       	adc	r25, r25
    513a:	88 0f       	add	r24, r24
    513c:	99 1f       	adc	r25, r25
    513e:	82 0f       	add	r24, r18
    5140:	93 1f       	adc	r25, r19
    5142:	8d 52       	subi	r24, 0x2D	; 45
    5144:	9e 4f       	sbci	r25, 0xFE	; 254
    5146:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    514a:	89 81       	ldd	r24, Y+1	; 0x01
    514c:	8f 5f       	subi	r24, 0xFF	; 255
    514e:	89 83       	std	Y+1, r24	; 0x01
    5150:	89 81       	ldd	r24, Y+1	; 0x01
    5152:	82 30       	cpi	r24, 0x02	; 2
    5154:	50 f3       	brcs	.-44     	; 0x512a <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    5156:	85 ee       	ldi	r24, 0xE5	; 229
    5158:	91 e0       	ldi	r25, 0x01	; 1
    515a:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    515e:	8e ee       	ldi	r24, 0xEE	; 238
    5160:	91 e0       	ldi	r25, 0x01	; 1
    5162:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    5166:	8b ef       	ldi	r24, 0xFB	; 251
    5168:	91 e0       	ldi	r25, 0x01	; 1
    516a:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    516e:	85 ee       	ldi	r24, 0xE5	; 229
    5170:	91 e0       	ldi	r25, 0x01	; 1
    5172:	90 93 f8 01 	sts	0x01F8, r25
    5176:	80 93 f7 01 	sts	0x01F7, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    517a:	8e ee       	ldi	r24, 0xEE	; 238
    517c:	91 e0       	ldi	r25, 0x01	; 1
    517e:	90 93 fa 01 	sts	0x01FA, r25
    5182:	80 93 f9 01 	sts	0x01F9, r24
}
    5186:	0f 90       	pop	r0
    5188:	cf 91       	pop	r28
    518a:	df 91       	pop	r29
    518c:	08 95       	ret

0000518e <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    518e:	df 93       	push	r29
    5190:	cf 93       	push	r28
    5192:	00 d0       	rcall	.+0      	; 0x5194 <xCoRoutineRemoveFromEventList+0x6>
    5194:	00 d0       	rcall	.+0      	; 0x5196 <xCoRoutineRemoveFromEventList+0x8>
    5196:	0f 92       	push	r0
    5198:	cd b7       	in	r28, 0x3d	; 61
    519a:	de b7       	in	r29, 0x3e	; 62
    519c:	9d 83       	std	Y+5, r25	; 0x05
    519e:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    51a0:	ec 81       	ldd	r30, Y+4	; 0x04
    51a2:	fd 81       	ldd	r31, Y+5	; 0x05
    51a4:	05 80       	ldd	r0, Z+5	; 0x05
    51a6:	f6 81       	ldd	r31, Z+6	; 0x06
    51a8:	e0 2d       	mov	r30, r0
    51aa:	86 81       	ldd	r24, Z+6	; 0x06
    51ac:	97 81       	ldd	r25, Z+7	; 0x07
    51ae:	9b 83       	std	Y+3, r25	; 0x03
    51b0:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    51b2:	8a 81       	ldd	r24, Y+2	; 0x02
    51b4:	9b 81       	ldd	r25, Y+3	; 0x03
    51b6:	0c 96       	adiw	r24, 0x0c	; 12
    51b8:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    51bc:	8a 81       	ldd	r24, Y+2	; 0x02
    51be:	9b 81       	ldd	r25, Y+3	; 0x03
    51c0:	9c 01       	movw	r18, r24
    51c2:	24 5f       	subi	r18, 0xF4	; 244
    51c4:	3f 4f       	sbci	r19, 0xFF	; 255
    51c6:	8b ef       	ldi	r24, 0xFB	; 251
    51c8:	91 e0       	ldi	r25, 0x01	; 1
    51ca:	b9 01       	movw	r22, r18
    51cc:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    51d0:	ea 81       	ldd	r30, Y+2	; 0x02
    51d2:	fb 81       	ldd	r31, Y+3	; 0x03
    51d4:	96 89       	ldd	r25, Z+22	; 0x16
    51d6:	e0 91 ca 01 	lds	r30, 0x01CA
    51da:	f0 91 cb 01 	lds	r31, 0x01CB
    51de:	86 89       	ldd	r24, Z+22	; 0x16
    51e0:	98 17       	cp	r25, r24
    51e2:	18 f0       	brcs	.+6      	; 0x51ea <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    51e4:	81 e0       	ldi	r24, 0x01	; 1
    51e6:	89 83       	std	Y+1, r24	; 0x01
    51e8:	01 c0       	rjmp	.+2      	; 0x51ec <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    51ea:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    51ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    51ee:	0f 90       	pop	r0
    51f0:	0f 90       	pop	r0
    51f2:	0f 90       	pop	r0
    51f4:	0f 90       	pop	r0
    51f6:	0f 90       	pop	r0
    51f8:	cf 91       	pop	r28
    51fa:	df 91       	pop	r29
    51fc:	08 95       	ret

000051fe <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    51fe:	df 93       	push	r29
    5200:	cf 93       	push	r28
    5202:	00 d0       	rcall	.+0      	; 0x5204 <pvPortMalloc+0x6>
    5204:	00 d0       	rcall	.+0      	; 0x5206 <pvPortMalloc+0x8>
    5206:	cd b7       	in	r28, 0x3d	; 61
    5208:	de b7       	in	r29, 0x3e	; 62
    520a:	9c 83       	std	Y+4, r25	; 0x04
    520c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    520e:	1a 82       	std	Y+2, r1	; 0x02
    5210:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    5212:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    5216:	80 91 04 02 	lds	r24, 0x0204
    521a:	90 91 05 02 	lds	r25, 0x0205
    521e:	2b 81       	ldd	r18, Y+3	; 0x03
    5220:	3c 81       	ldd	r19, Y+4	; 0x04
    5222:	82 0f       	add	r24, r18
    5224:	93 1f       	adc	r25, r19
    5226:	25 e0       	ldi	r18, 0x05	; 5
    5228:	8c 3d       	cpi	r24, 0xDC	; 220
    522a:	92 07       	cpc	r25, r18
    522c:	18 f5       	brcc	.+70     	; 0x5274 <pvPortMalloc+0x76>
    522e:	20 91 04 02 	lds	r18, 0x0204
    5232:	30 91 05 02 	lds	r19, 0x0205
    5236:	8b 81       	ldd	r24, Y+3	; 0x03
    5238:	9c 81       	ldd	r25, Y+4	; 0x04
    523a:	28 0f       	add	r18, r24
    523c:	39 1f       	adc	r19, r25
    523e:	80 91 04 02 	lds	r24, 0x0204
    5242:	90 91 05 02 	lds	r25, 0x0205
    5246:	82 17       	cp	r24, r18
    5248:	93 07       	cpc	r25, r19
    524a:	a0 f4       	brcc	.+40     	; 0x5274 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    524c:	80 91 04 02 	lds	r24, 0x0204
    5250:	90 91 05 02 	lds	r25, 0x0205
    5254:	8a 5f       	subi	r24, 0xFA	; 250
    5256:	9d 4f       	sbci	r25, 0xFD	; 253
    5258:	9a 83       	std	Y+2, r25	; 0x02
    525a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    525c:	20 91 04 02 	lds	r18, 0x0204
    5260:	30 91 05 02 	lds	r19, 0x0205
    5264:	8b 81       	ldd	r24, Y+3	; 0x03
    5266:	9c 81       	ldd	r25, Y+4	; 0x04
    5268:	82 0f       	add	r24, r18
    526a:	93 1f       	adc	r25, r19
    526c:	90 93 05 02 	sts	0x0205, r25
    5270:	80 93 04 02 	sts	0x0204, r24
		}	
	}
	xTaskResumeAll();
    5274:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    5278:	89 81       	ldd	r24, Y+1	; 0x01
    527a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    527c:	0f 90       	pop	r0
    527e:	0f 90       	pop	r0
    5280:	0f 90       	pop	r0
    5282:	0f 90       	pop	r0
    5284:	cf 91       	pop	r28
    5286:	df 91       	pop	r29
    5288:	08 95       	ret

0000528a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    528a:	df 93       	push	r29
    528c:	cf 93       	push	r28
    528e:	00 d0       	rcall	.+0      	; 0x5290 <vPortFree+0x6>
    5290:	cd b7       	in	r28, 0x3d	; 61
    5292:	de b7       	in	r29, 0x3e	; 62
    5294:	9a 83       	std	Y+2, r25	; 0x02
    5296:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    5298:	0f 90       	pop	r0
    529a:	0f 90       	pop	r0
    529c:	cf 91       	pop	r28
    529e:	df 91       	pop	r29
    52a0:	08 95       	ret

000052a2 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    52a2:	df 93       	push	r29
    52a4:	cf 93       	push	r28
    52a6:	cd b7       	in	r28, 0x3d	; 61
    52a8:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    52aa:	10 92 05 02 	sts	0x0205, r1
    52ae:	10 92 04 02 	sts	0x0204, r1
}
    52b2:	cf 91       	pop	r28
    52b4:	df 91       	pop	r29
    52b6:	08 95       	ret

000052b8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    52b8:	df 93       	push	r29
    52ba:	cf 93       	push	r28
    52bc:	cd b7       	in	r28, 0x3d	; 61
    52be:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    52c0:	20 91 04 02 	lds	r18, 0x0204
    52c4:	30 91 05 02 	lds	r19, 0x0205
    52c8:	8c ed       	ldi	r24, 0xDC	; 220
    52ca:	95 e0       	ldi	r25, 0x05	; 5
    52cc:	82 1b       	sub	r24, r18
    52ce:	93 0b       	sbc	r25, r19
}
    52d0:	cf 91       	pop	r28
    52d2:	df 91       	pop	r29
    52d4:	08 95       	ret

000052d6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    52d6:	df 93       	push	r29
    52d8:	cf 93       	push	r28
    52da:	00 d0       	rcall	.+0      	; 0x52dc <vListInitialise+0x6>
    52dc:	cd b7       	in	r28, 0x3d	; 61
    52de:	de b7       	in	r29, 0x3e	; 62
    52e0:	9a 83       	std	Y+2, r25	; 0x02
    52e2:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    52e4:	89 81       	ldd	r24, Y+1	; 0x01
    52e6:	9a 81       	ldd	r25, Y+2	; 0x02
    52e8:	03 96       	adiw	r24, 0x03	; 3
    52ea:	e9 81       	ldd	r30, Y+1	; 0x01
    52ec:	fa 81       	ldd	r31, Y+2	; 0x02
    52ee:	92 83       	std	Z+2, r25	; 0x02
    52f0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    52f2:	e9 81       	ldd	r30, Y+1	; 0x01
    52f4:	fa 81       	ldd	r31, Y+2	; 0x02
    52f6:	8f ef       	ldi	r24, 0xFF	; 255
    52f8:	9f ef       	ldi	r25, 0xFF	; 255
    52fa:	94 83       	std	Z+4, r25	; 0x04
    52fc:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    52fe:	89 81       	ldd	r24, Y+1	; 0x01
    5300:	9a 81       	ldd	r25, Y+2	; 0x02
    5302:	03 96       	adiw	r24, 0x03	; 3
    5304:	e9 81       	ldd	r30, Y+1	; 0x01
    5306:	fa 81       	ldd	r31, Y+2	; 0x02
    5308:	96 83       	std	Z+6, r25	; 0x06
    530a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    530c:	89 81       	ldd	r24, Y+1	; 0x01
    530e:	9a 81       	ldd	r25, Y+2	; 0x02
    5310:	03 96       	adiw	r24, 0x03	; 3
    5312:	e9 81       	ldd	r30, Y+1	; 0x01
    5314:	fa 81       	ldd	r31, Y+2	; 0x02
    5316:	90 87       	std	Z+8, r25	; 0x08
    5318:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    531a:	e9 81       	ldd	r30, Y+1	; 0x01
    531c:	fa 81       	ldd	r31, Y+2	; 0x02
    531e:	10 82       	st	Z, r1
}
    5320:	0f 90       	pop	r0
    5322:	0f 90       	pop	r0
    5324:	cf 91       	pop	r28
    5326:	df 91       	pop	r29
    5328:	08 95       	ret

0000532a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    532a:	df 93       	push	r29
    532c:	cf 93       	push	r28
    532e:	00 d0       	rcall	.+0      	; 0x5330 <vListInitialiseItem+0x6>
    5330:	cd b7       	in	r28, 0x3d	; 61
    5332:	de b7       	in	r29, 0x3e	; 62
    5334:	9a 83       	std	Y+2, r25	; 0x02
    5336:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    5338:	e9 81       	ldd	r30, Y+1	; 0x01
    533a:	fa 81       	ldd	r31, Y+2	; 0x02
    533c:	11 86       	std	Z+9, r1	; 0x09
    533e:	10 86       	std	Z+8, r1	; 0x08
}
    5340:	0f 90       	pop	r0
    5342:	0f 90       	pop	r0
    5344:	cf 91       	pop	r28
    5346:	df 91       	pop	r29
    5348:	08 95       	ret

0000534a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    534a:	df 93       	push	r29
    534c:	cf 93       	push	r28
    534e:	00 d0       	rcall	.+0      	; 0x5350 <vListInsertEnd+0x6>
    5350:	00 d0       	rcall	.+0      	; 0x5352 <vListInsertEnd+0x8>
    5352:	00 d0       	rcall	.+0      	; 0x5354 <vListInsertEnd+0xa>
    5354:	cd b7       	in	r28, 0x3d	; 61
    5356:	de b7       	in	r29, 0x3e	; 62
    5358:	9c 83       	std	Y+4, r25	; 0x04
    535a:	8b 83       	std	Y+3, r24	; 0x03
    535c:	7e 83       	std	Y+6, r23	; 0x06
    535e:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    5360:	eb 81       	ldd	r30, Y+3	; 0x03
    5362:	fc 81       	ldd	r31, Y+4	; 0x04
    5364:	81 81       	ldd	r24, Z+1	; 0x01
    5366:	92 81       	ldd	r25, Z+2	; 0x02
    5368:	9a 83       	std	Y+2, r25	; 0x02
    536a:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    536c:	e9 81       	ldd	r30, Y+1	; 0x01
    536e:	fa 81       	ldd	r31, Y+2	; 0x02
    5370:	82 81       	ldd	r24, Z+2	; 0x02
    5372:	93 81       	ldd	r25, Z+3	; 0x03
    5374:	ed 81       	ldd	r30, Y+5	; 0x05
    5376:	fe 81       	ldd	r31, Y+6	; 0x06
    5378:	93 83       	std	Z+3, r25	; 0x03
    537a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    537c:	eb 81       	ldd	r30, Y+3	; 0x03
    537e:	fc 81       	ldd	r31, Y+4	; 0x04
    5380:	81 81       	ldd	r24, Z+1	; 0x01
    5382:	92 81       	ldd	r25, Z+2	; 0x02
    5384:	ed 81       	ldd	r30, Y+5	; 0x05
    5386:	fe 81       	ldd	r31, Y+6	; 0x06
    5388:	95 83       	std	Z+5, r25	; 0x05
    538a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    538c:	e9 81       	ldd	r30, Y+1	; 0x01
    538e:	fa 81       	ldd	r31, Y+2	; 0x02
    5390:	02 80       	ldd	r0, Z+2	; 0x02
    5392:	f3 81       	ldd	r31, Z+3	; 0x03
    5394:	e0 2d       	mov	r30, r0
    5396:	8d 81       	ldd	r24, Y+5	; 0x05
    5398:	9e 81       	ldd	r25, Y+6	; 0x06
    539a:	95 83       	std	Z+5, r25	; 0x05
    539c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    539e:	8d 81       	ldd	r24, Y+5	; 0x05
    53a0:	9e 81       	ldd	r25, Y+6	; 0x06
    53a2:	e9 81       	ldd	r30, Y+1	; 0x01
    53a4:	fa 81       	ldd	r31, Y+2	; 0x02
    53a6:	93 83       	std	Z+3, r25	; 0x03
    53a8:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    53aa:	8d 81       	ldd	r24, Y+5	; 0x05
    53ac:	9e 81       	ldd	r25, Y+6	; 0x06
    53ae:	eb 81       	ldd	r30, Y+3	; 0x03
    53b0:	fc 81       	ldd	r31, Y+4	; 0x04
    53b2:	92 83       	std	Z+2, r25	; 0x02
    53b4:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    53b6:	ed 81       	ldd	r30, Y+5	; 0x05
    53b8:	fe 81       	ldd	r31, Y+6	; 0x06
    53ba:	8b 81       	ldd	r24, Y+3	; 0x03
    53bc:	9c 81       	ldd	r25, Y+4	; 0x04
    53be:	91 87       	std	Z+9, r25	; 0x09
    53c0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    53c2:	eb 81       	ldd	r30, Y+3	; 0x03
    53c4:	fc 81       	ldd	r31, Y+4	; 0x04
    53c6:	80 81       	ld	r24, Z
    53c8:	8f 5f       	subi	r24, 0xFF	; 255
    53ca:	eb 81       	ldd	r30, Y+3	; 0x03
    53cc:	fc 81       	ldd	r31, Y+4	; 0x04
    53ce:	80 83       	st	Z, r24
}
    53d0:	26 96       	adiw	r28, 0x06	; 6
    53d2:	0f b6       	in	r0, 0x3f	; 63
    53d4:	f8 94       	cli
    53d6:	de bf       	out	0x3e, r29	; 62
    53d8:	0f be       	out	0x3f, r0	; 63
    53da:	cd bf       	out	0x3d, r28	; 61
    53dc:	cf 91       	pop	r28
    53de:	df 91       	pop	r29
    53e0:	08 95       	ret

000053e2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    53e2:	df 93       	push	r29
    53e4:	cf 93       	push	r28
    53e6:	cd b7       	in	r28, 0x3d	; 61
    53e8:	de b7       	in	r29, 0x3e	; 62
    53ea:	28 97       	sbiw	r28, 0x08	; 8
    53ec:	0f b6       	in	r0, 0x3f	; 63
    53ee:	f8 94       	cli
    53f0:	de bf       	out	0x3e, r29	; 62
    53f2:	0f be       	out	0x3f, r0	; 63
    53f4:	cd bf       	out	0x3d, r28	; 61
    53f6:	9e 83       	std	Y+6, r25	; 0x06
    53f8:	8d 83       	std	Y+5, r24	; 0x05
    53fa:	78 87       	std	Y+8, r23	; 0x08
    53fc:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    53fe:	ef 81       	ldd	r30, Y+7	; 0x07
    5400:	f8 85       	ldd	r31, Y+8	; 0x08
    5402:	80 81       	ld	r24, Z
    5404:	91 81       	ldd	r25, Z+1	; 0x01
    5406:	9a 83       	std	Y+2, r25	; 0x02
    5408:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    540a:	89 81       	ldd	r24, Y+1	; 0x01
    540c:	9a 81       	ldd	r25, Y+2	; 0x02
    540e:	2f ef       	ldi	r18, 0xFF	; 255
    5410:	8f 3f       	cpi	r24, 0xFF	; 255
    5412:	92 07       	cpc	r25, r18
    5414:	39 f4       	brne	.+14     	; 0x5424 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    5416:	ed 81       	ldd	r30, Y+5	; 0x05
    5418:	fe 81       	ldd	r31, Y+6	; 0x06
    541a:	87 81       	ldd	r24, Z+7	; 0x07
    541c:	90 85       	ldd	r25, Z+8	; 0x08
    541e:	9c 83       	std	Y+4, r25	; 0x04
    5420:	8b 83       	std	Y+3, r24	; 0x03
    5422:	18 c0       	rjmp	.+48     	; 0x5454 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    5424:	8d 81       	ldd	r24, Y+5	; 0x05
    5426:	9e 81       	ldd	r25, Y+6	; 0x06
    5428:	03 96       	adiw	r24, 0x03	; 3
    542a:	9c 83       	std	Y+4, r25	; 0x04
    542c:	8b 83       	std	Y+3, r24	; 0x03
    542e:	06 c0       	rjmp	.+12     	; 0x543c <vListInsert+0x5a>
    5430:	eb 81       	ldd	r30, Y+3	; 0x03
    5432:	fc 81       	ldd	r31, Y+4	; 0x04
    5434:	82 81       	ldd	r24, Z+2	; 0x02
    5436:	93 81       	ldd	r25, Z+3	; 0x03
    5438:	9c 83       	std	Y+4, r25	; 0x04
    543a:	8b 83       	std	Y+3, r24	; 0x03
    543c:	eb 81       	ldd	r30, Y+3	; 0x03
    543e:	fc 81       	ldd	r31, Y+4	; 0x04
    5440:	02 80       	ldd	r0, Z+2	; 0x02
    5442:	f3 81       	ldd	r31, Z+3	; 0x03
    5444:	e0 2d       	mov	r30, r0
    5446:	20 81       	ld	r18, Z
    5448:	31 81       	ldd	r19, Z+1	; 0x01
    544a:	89 81       	ldd	r24, Y+1	; 0x01
    544c:	9a 81       	ldd	r25, Y+2	; 0x02
    544e:	82 17       	cp	r24, r18
    5450:	93 07       	cpc	r25, r19
    5452:	70 f7       	brcc	.-36     	; 0x5430 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    5454:	eb 81       	ldd	r30, Y+3	; 0x03
    5456:	fc 81       	ldd	r31, Y+4	; 0x04
    5458:	82 81       	ldd	r24, Z+2	; 0x02
    545a:	93 81       	ldd	r25, Z+3	; 0x03
    545c:	ef 81       	ldd	r30, Y+7	; 0x07
    545e:	f8 85       	ldd	r31, Y+8	; 0x08
    5460:	93 83       	std	Z+3, r25	; 0x03
    5462:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    5464:	ef 81       	ldd	r30, Y+7	; 0x07
    5466:	f8 85       	ldd	r31, Y+8	; 0x08
    5468:	02 80       	ldd	r0, Z+2	; 0x02
    546a:	f3 81       	ldd	r31, Z+3	; 0x03
    546c:	e0 2d       	mov	r30, r0
    546e:	8f 81       	ldd	r24, Y+7	; 0x07
    5470:	98 85       	ldd	r25, Y+8	; 0x08
    5472:	95 83       	std	Z+5, r25	; 0x05
    5474:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    5476:	ef 81       	ldd	r30, Y+7	; 0x07
    5478:	f8 85       	ldd	r31, Y+8	; 0x08
    547a:	8b 81       	ldd	r24, Y+3	; 0x03
    547c:	9c 81       	ldd	r25, Y+4	; 0x04
    547e:	95 83       	std	Z+5, r25	; 0x05
    5480:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    5482:	8f 81       	ldd	r24, Y+7	; 0x07
    5484:	98 85       	ldd	r25, Y+8	; 0x08
    5486:	eb 81       	ldd	r30, Y+3	; 0x03
    5488:	fc 81       	ldd	r31, Y+4	; 0x04
    548a:	93 83       	std	Z+3, r25	; 0x03
    548c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    548e:	ef 81       	ldd	r30, Y+7	; 0x07
    5490:	f8 85       	ldd	r31, Y+8	; 0x08
    5492:	8d 81       	ldd	r24, Y+5	; 0x05
    5494:	9e 81       	ldd	r25, Y+6	; 0x06
    5496:	91 87       	std	Z+9, r25	; 0x09
    5498:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    549a:	ed 81       	ldd	r30, Y+5	; 0x05
    549c:	fe 81       	ldd	r31, Y+6	; 0x06
    549e:	80 81       	ld	r24, Z
    54a0:	8f 5f       	subi	r24, 0xFF	; 255
    54a2:	ed 81       	ldd	r30, Y+5	; 0x05
    54a4:	fe 81       	ldd	r31, Y+6	; 0x06
    54a6:	80 83       	st	Z, r24
}
    54a8:	28 96       	adiw	r28, 0x08	; 8
    54aa:	0f b6       	in	r0, 0x3f	; 63
    54ac:	f8 94       	cli
    54ae:	de bf       	out	0x3e, r29	; 62
    54b0:	0f be       	out	0x3f, r0	; 63
    54b2:	cd bf       	out	0x3d, r28	; 61
    54b4:	cf 91       	pop	r28
    54b6:	df 91       	pop	r29
    54b8:	08 95       	ret

000054ba <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    54ba:	df 93       	push	r29
    54bc:	cf 93       	push	r28
    54be:	00 d0       	rcall	.+0      	; 0x54c0 <vListRemove+0x6>
    54c0:	00 d0       	rcall	.+0      	; 0x54c2 <vListRemove+0x8>
    54c2:	cd b7       	in	r28, 0x3d	; 61
    54c4:	de b7       	in	r29, 0x3e	; 62
    54c6:	9c 83       	std	Y+4, r25	; 0x04
    54c8:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    54ca:	eb 81       	ldd	r30, Y+3	; 0x03
    54cc:	fc 81       	ldd	r31, Y+4	; 0x04
    54ce:	a2 81       	ldd	r26, Z+2	; 0x02
    54d0:	b3 81       	ldd	r27, Z+3	; 0x03
    54d2:	eb 81       	ldd	r30, Y+3	; 0x03
    54d4:	fc 81       	ldd	r31, Y+4	; 0x04
    54d6:	84 81       	ldd	r24, Z+4	; 0x04
    54d8:	95 81       	ldd	r25, Z+5	; 0x05
    54da:	15 96       	adiw	r26, 0x05	; 5
    54dc:	9c 93       	st	X, r25
    54de:	8e 93       	st	-X, r24
    54e0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    54e2:	eb 81       	ldd	r30, Y+3	; 0x03
    54e4:	fc 81       	ldd	r31, Y+4	; 0x04
    54e6:	a4 81       	ldd	r26, Z+4	; 0x04
    54e8:	b5 81       	ldd	r27, Z+5	; 0x05
    54ea:	eb 81       	ldd	r30, Y+3	; 0x03
    54ec:	fc 81       	ldd	r31, Y+4	; 0x04
    54ee:	82 81       	ldd	r24, Z+2	; 0x02
    54f0:	93 81       	ldd	r25, Z+3	; 0x03
    54f2:	13 96       	adiw	r26, 0x03	; 3
    54f4:	9c 93       	st	X, r25
    54f6:	8e 93       	st	-X, r24
    54f8:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    54fa:	eb 81       	ldd	r30, Y+3	; 0x03
    54fc:	fc 81       	ldd	r31, Y+4	; 0x04
    54fe:	80 85       	ldd	r24, Z+8	; 0x08
    5500:	91 85       	ldd	r25, Z+9	; 0x09
    5502:	9a 83       	std	Y+2, r25	; 0x02
    5504:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    5506:	e9 81       	ldd	r30, Y+1	; 0x01
    5508:	fa 81       	ldd	r31, Y+2	; 0x02
    550a:	21 81       	ldd	r18, Z+1	; 0x01
    550c:	32 81       	ldd	r19, Z+2	; 0x02
    550e:	8b 81       	ldd	r24, Y+3	; 0x03
    5510:	9c 81       	ldd	r25, Y+4	; 0x04
    5512:	28 17       	cp	r18, r24
    5514:	39 07       	cpc	r19, r25
    5516:	41 f4       	brne	.+16     	; 0x5528 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    5518:	eb 81       	ldd	r30, Y+3	; 0x03
    551a:	fc 81       	ldd	r31, Y+4	; 0x04
    551c:	84 81       	ldd	r24, Z+4	; 0x04
    551e:	95 81       	ldd	r25, Z+5	; 0x05
    5520:	e9 81       	ldd	r30, Y+1	; 0x01
    5522:	fa 81       	ldd	r31, Y+2	; 0x02
    5524:	92 83       	std	Z+2, r25	; 0x02
    5526:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    5528:	eb 81       	ldd	r30, Y+3	; 0x03
    552a:	fc 81       	ldd	r31, Y+4	; 0x04
    552c:	11 86       	std	Z+9, r1	; 0x09
    552e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    5530:	e9 81       	ldd	r30, Y+1	; 0x01
    5532:	fa 81       	ldd	r31, Y+2	; 0x02
    5534:	80 81       	ld	r24, Z
    5536:	81 50       	subi	r24, 0x01	; 1
    5538:	e9 81       	ldd	r30, Y+1	; 0x01
    553a:	fa 81       	ldd	r31, Y+2	; 0x02
    553c:	80 83       	st	Z, r24
}
    553e:	0f 90       	pop	r0
    5540:	0f 90       	pop	r0
    5542:	0f 90       	pop	r0
    5544:	0f 90       	pop	r0
    5546:	cf 91       	pop	r28
    5548:	df 91       	pop	r29
    554a:	08 95       	ret

0000554c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    554c:	df 93       	push	r29
    554e:	cf 93       	push	r28
    5550:	cd b7       	in	r28, 0x3d	; 61
    5552:	de b7       	in	r29, 0x3e	; 62
    5554:	28 97       	sbiw	r28, 0x08	; 8
    5556:	0f b6       	in	r0, 0x3f	; 63
    5558:	f8 94       	cli
    555a:	de bf       	out	0x3e, r29	; 62
    555c:	0f be       	out	0x3f, r0	; 63
    555e:	cd bf       	out	0x3d, r28	; 61
    5560:	9c 83       	std	Y+4, r25	; 0x04
    5562:	8b 83       	std	Y+3, r24	; 0x03
    5564:	7e 83       	std	Y+6, r23	; 0x06
    5566:	6d 83       	std	Y+5, r22	; 0x05
    5568:	58 87       	std	Y+8, r21	; 0x08
    556a:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    556c:	eb 81       	ldd	r30, Y+3	; 0x03
    556e:	fc 81       	ldd	r31, Y+4	; 0x04
    5570:	81 e1       	ldi	r24, 0x11	; 17
    5572:	80 83       	st	Z, r24
	pxTopOfStack--;
    5574:	8b 81       	ldd	r24, Y+3	; 0x03
    5576:	9c 81       	ldd	r25, Y+4	; 0x04
    5578:	01 97       	sbiw	r24, 0x01	; 1
    557a:	9c 83       	std	Y+4, r25	; 0x04
    557c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    557e:	eb 81       	ldd	r30, Y+3	; 0x03
    5580:	fc 81       	ldd	r31, Y+4	; 0x04
    5582:	82 e2       	ldi	r24, 0x22	; 34
    5584:	80 83       	st	Z, r24
	pxTopOfStack--;
    5586:	8b 81       	ldd	r24, Y+3	; 0x03
    5588:	9c 81       	ldd	r25, Y+4	; 0x04
    558a:	01 97       	sbiw	r24, 0x01	; 1
    558c:	9c 83       	std	Y+4, r25	; 0x04
    558e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    5590:	eb 81       	ldd	r30, Y+3	; 0x03
    5592:	fc 81       	ldd	r31, Y+4	; 0x04
    5594:	83 e3       	ldi	r24, 0x33	; 51
    5596:	80 83       	st	Z, r24
	pxTopOfStack--;
    5598:	8b 81       	ldd	r24, Y+3	; 0x03
    559a:	9c 81       	ldd	r25, Y+4	; 0x04
    559c:	01 97       	sbiw	r24, 0x01	; 1
    559e:	9c 83       	std	Y+4, r25	; 0x04
    55a0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    55a2:	8d 81       	ldd	r24, Y+5	; 0x05
    55a4:	9e 81       	ldd	r25, Y+6	; 0x06
    55a6:	9a 83       	std	Y+2, r25	; 0x02
    55a8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    55aa:	89 81       	ldd	r24, Y+1	; 0x01
    55ac:	eb 81       	ldd	r30, Y+3	; 0x03
    55ae:	fc 81       	ldd	r31, Y+4	; 0x04
    55b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    55b2:	8b 81       	ldd	r24, Y+3	; 0x03
    55b4:	9c 81       	ldd	r25, Y+4	; 0x04
    55b6:	01 97       	sbiw	r24, 0x01	; 1
    55b8:	9c 83       	std	Y+4, r25	; 0x04
    55ba:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    55bc:	89 81       	ldd	r24, Y+1	; 0x01
    55be:	9a 81       	ldd	r25, Y+2	; 0x02
    55c0:	89 2f       	mov	r24, r25
    55c2:	99 27       	eor	r25, r25
    55c4:	9a 83       	std	Y+2, r25	; 0x02
    55c6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    55c8:	89 81       	ldd	r24, Y+1	; 0x01
    55ca:	eb 81       	ldd	r30, Y+3	; 0x03
    55cc:	fc 81       	ldd	r31, Y+4	; 0x04
    55ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    55d0:	8b 81       	ldd	r24, Y+3	; 0x03
    55d2:	9c 81       	ldd	r25, Y+4	; 0x04
    55d4:	01 97       	sbiw	r24, 0x01	; 1
    55d6:	9c 83       	std	Y+4, r25	; 0x04
    55d8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    55da:	eb 81       	ldd	r30, Y+3	; 0x03
    55dc:	fc 81       	ldd	r31, Y+4	; 0x04
    55de:	10 82       	st	Z, r1
	pxTopOfStack--;
    55e0:	8b 81       	ldd	r24, Y+3	; 0x03
    55e2:	9c 81       	ldd	r25, Y+4	; 0x04
    55e4:	01 97       	sbiw	r24, 0x01	; 1
    55e6:	9c 83       	std	Y+4, r25	; 0x04
    55e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    55ea:	eb 81       	ldd	r30, Y+3	; 0x03
    55ec:	fc 81       	ldd	r31, Y+4	; 0x04
    55ee:	80 e8       	ldi	r24, 0x80	; 128
    55f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    55f2:	8b 81       	ldd	r24, Y+3	; 0x03
    55f4:	9c 81       	ldd	r25, Y+4	; 0x04
    55f6:	01 97       	sbiw	r24, 0x01	; 1
    55f8:	9c 83       	std	Y+4, r25	; 0x04
    55fa:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    55fc:	eb 81       	ldd	r30, Y+3	; 0x03
    55fe:	fc 81       	ldd	r31, Y+4	; 0x04
    5600:	10 82       	st	Z, r1
	pxTopOfStack--;
    5602:	8b 81       	ldd	r24, Y+3	; 0x03
    5604:	9c 81       	ldd	r25, Y+4	; 0x04
    5606:	01 97       	sbiw	r24, 0x01	; 1
    5608:	9c 83       	std	Y+4, r25	; 0x04
    560a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    560c:	eb 81       	ldd	r30, Y+3	; 0x03
    560e:	fc 81       	ldd	r31, Y+4	; 0x04
    5610:	82 e0       	ldi	r24, 0x02	; 2
    5612:	80 83       	st	Z, r24
	pxTopOfStack--;
    5614:	8b 81       	ldd	r24, Y+3	; 0x03
    5616:	9c 81       	ldd	r25, Y+4	; 0x04
    5618:	01 97       	sbiw	r24, 0x01	; 1
    561a:	9c 83       	std	Y+4, r25	; 0x04
    561c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    561e:	eb 81       	ldd	r30, Y+3	; 0x03
    5620:	fc 81       	ldd	r31, Y+4	; 0x04
    5622:	83 e0       	ldi	r24, 0x03	; 3
    5624:	80 83       	st	Z, r24
	pxTopOfStack--;
    5626:	8b 81       	ldd	r24, Y+3	; 0x03
    5628:	9c 81       	ldd	r25, Y+4	; 0x04
    562a:	01 97       	sbiw	r24, 0x01	; 1
    562c:	9c 83       	std	Y+4, r25	; 0x04
    562e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    5630:	eb 81       	ldd	r30, Y+3	; 0x03
    5632:	fc 81       	ldd	r31, Y+4	; 0x04
    5634:	84 e0       	ldi	r24, 0x04	; 4
    5636:	80 83       	st	Z, r24
	pxTopOfStack--;
    5638:	8b 81       	ldd	r24, Y+3	; 0x03
    563a:	9c 81       	ldd	r25, Y+4	; 0x04
    563c:	01 97       	sbiw	r24, 0x01	; 1
    563e:	9c 83       	std	Y+4, r25	; 0x04
    5640:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    5642:	eb 81       	ldd	r30, Y+3	; 0x03
    5644:	fc 81       	ldd	r31, Y+4	; 0x04
    5646:	85 e0       	ldi	r24, 0x05	; 5
    5648:	80 83       	st	Z, r24
	pxTopOfStack--;
    564a:	8b 81       	ldd	r24, Y+3	; 0x03
    564c:	9c 81       	ldd	r25, Y+4	; 0x04
    564e:	01 97       	sbiw	r24, 0x01	; 1
    5650:	9c 83       	std	Y+4, r25	; 0x04
    5652:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    5654:	eb 81       	ldd	r30, Y+3	; 0x03
    5656:	fc 81       	ldd	r31, Y+4	; 0x04
    5658:	86 e0       	ldi	r24, 0x06	; 6
    565a:	80 83       	st	Z, r24
	pxTopOfStack--;
    565c:	8b 81       	ldd	r24, Y+3	; 0x03
    565e:	9c 81       	ldd	r25, Y+4	; 0x04
    5660:	01 97       	sbiw	r24, 0x01	; 1
    5662:	9c 83       	std	Y+4, r25	; 0x04
    5664:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    5666:	eb 81       	ldd	r30, Y+3	; 0x03
    5668:	fc 81       	ldd	r31, Y+4	; 0x04
    566a:	87 e0       	ldi	r24, 0x07	; 7
    566c:	80 83       	st	Z, r24
	pxTopOfStack--;
    566e:	8b 81       	ldd	r24, Y+3	; 0x03
    5670:	9c 81       	ldd	r25, Y+4	; 0x04
    5672:	01 97       	sbiw	r24, 0x01	; 1
    5674:	9c 83       	std	Y+4, r25	; 0x04
    5676:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    5678:	eb 81       	ldd	r30, Y+3	; 0x03
    567a:	fc 81       	ldd	r31, Y+4	; 0x04
    567c:	88 e0       	ldi	r24, 0x08	; 8
    567e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5680:	8b 81       	ldd	r24, Y+3	; 0x03
    5682:	9c 81       	ldd	r25, Y+4	; 0x04
    5684:	01 97       	sbiw	r24, 0x01	; 1
    5686:	9c 83       	std	Y+4, r25	; 0x04
    5688:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    568a:	eb 81       	ldd	r30, Y+3	; 0x03
    568c:	fc 81       	ldd	r31, Y+4	; 0x04
    568e:	89 e0       	ldi	r24, 0x09	; 9
    5690:	80 83       	st	Z, r24
	pxTopOfStack--;
    5692:	8b 81       	ldd	r24, Y+3	; 0x03
    5694:	9c 81       	ldd	r25, Y+4	; 0x04
    5696:	01 97       	sbiw	r24, 0x01	; 1
    5698:	9c 83       	std	Y+4, r25	; 0x04
    569a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    569c:	eb 81       	ldd	r30, Y+3	; 0x03
    569e:	fc 81       	ldd	r31, Y+4	; 0x04
    56a0:	80 e1       	ldi	r24, 0x10	; 16
    56a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    56a4:	8b 81       	ldd	r24, Y+3	; 0x03
    56a6:	9c 81       	ldd	r25, Y+4	; 0x04
    56a8:	01 97       	sbiw	r24, 0x01	; 1
    56aa:	9c 83       	std	Y+4, r25	; 0x04
    56ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    56ae:	eb 81       	ldd	r30, Y+3	; 0x03
    56b0:	fc 81       	ldd	r31, Y+4	; 0x04
    56b2:	81 e1       	ldi	r24, 0x11	; 17
    56b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    56b6:	8b 81       	ldd	r24, Y+3	; 0x03
    56b8:	9c 81       	ldd	r25, Y+4	; 0x04
    56ba:	01 97       	sbiw	r24, 0x01	; 1
    56bc:	9c 83       	std	Y+4, r25	; 0x04
    56be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    56c0:	eb 81       	ldd	r30, Y+3	; 0x03
    56c2:	fc 81       	ldd	r31, Y+4	; 0x04
    56c4:	82 e1       	ldi	r24, 0x12	; 18
    56c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    56c8:	8b 81       	ldd	r24, Y+3	; 0x03
    56ca:	9c 81       	ldd	r25, Y+4	; 0x04
    56cc:	01 97       	sbiw	r24, 0x01	; 1
    56ce:	9c 83       	std	Y+4, r25	; 0x04
    56d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    56d2:	eb 81       	ldd	r30, Y+3	; 0x03
    56d4:	fc 81       	ldd	r31, Y+4	; 0x04
    56d6:	83 e1       	ldi	r24, 0x13	; 19
    56d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    56da:	8b 81       	ldd	r24, Y+3	; 0x03
    56dc:	9c 81       	ldd	r25, Y+4	; 0x04
    56de:	01 97       	sbiw	r24, 0x01	; 1
    56e0:	9c 83       	std	Y+4, r25	; 0x04
    56e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    56e4:	eb 81       	ldd	r30, Y+3	; 0x03
    56e6:	fc 81       	ldd	r31, Y+4	; 0x04
    56e8:	84 e1       	ldi	r24, 0x14	; 20
    56ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    56ec:	8b 81       	ldd	r24, Y+3	; 0x03
    56ee:	9c 81       	ldd	r25, Y+4	; 0x04
    56f0:	01 97       	sbiw	r24, 0x01	; 1
    56f2:	9c 83       	std	Y+4, r25	; 0x04
    56f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    56f6:	eb 81       	ldd	r30, Y+3	; 0x03
    56f8:	fc 81       	ldd	r31, Y+4	; 0x04
    56fa:	85 e1       	ldi	r24, 0x15	; 21
    56fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    56fe:	8b 81       	ldd	r24, Y+3	; 0x03
    5700:	9c 81       	ldd	r25, Y+4	; 0x04
    5702:	01 97       	sbiw	r24, 0x01	; 1
    5704:	9c 83       	std	Y+4, r25	; 0x04
    5706:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    5708:	eb 81       	ldd	r30, Y+3	; 0x03
    570a:	fc 81       	ldd	r31, Y+4	; 0x04
    570c:	86 e1       	ldi	r24, 0x16	; 22
    570e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5710:	8b 81       	ldd	r24, Y+3	; 0x03
    5712:	9c 81       	ldd	r25, Y+4	; 0x04
    5714:	01 97       	sbiw	r24, 0x01	; 1
    5716:	9c 83       	std	Y+4, r25	; 0x04
    5718:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    571a:	eb 81       	ldd	r30, Y+3	; 0x03
    571c:	fc 81       	ldd	r31, Y+4	; 0x04
    571e:	87 e1       	ldi	r24, 0x17	; 23
    5720:	80 83       	st	Z, r24
	pxTopOfStack--;
    5722:	8b 81       	ldd	r24, Y+3	; 0x03
    5724:	9c 81       	ldd	r25, Y+4	; 0x04
    5726:	01 97       	sbiw	r24, 0x01	; 1
    5728:	9c 83       	std	Y+4, r25	; 0x04
    572a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    572c:	eb 81       	ldd	r30, Y+3	; 0x03
    572e:	fc 81       	ldd	r31, Y+4	; 0x04
    5730:	88 e1       	ldi	r24, 0x18	; 24
    5732:	80 83       	st	Z, r24
	pxTopOfStack--;
    5734:	8b 81       	ldd	r24, Y+3	; 0x03
    5736:	9c 81       	ldd	r25, Y+4	; 0x04
    5738:	01 97       	sbiw	r24, 0x01	; 1
    573a:	9c 83       	std	Y+4, r25	; 0x04
    573c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    573e:	eb 81       	ldd	r30, Y+3	; 0x03
    5740:	fc 81       	ldd	r31, Y+4	; 0x04
    5742:	89 e1       	ldi	r24, 0x19	; 25
    5744:	80 83       	st	Z, r24
	pxTopOfStack--;
    5746:	8b 81       	ldd	r24, Y+3	; 0x03
    5748:	9c 81       	ldd	r25, Y+4	; 0x04
    574a:	01 97       	sbiw	r24, 0x01	; 1
    574c:	9c 83       	std	Y+4, r25	; 0x04
    574e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    5750:	eb 81       	ldd	r30, Y+3	; 0x03
    5752:	fc 81       	ldd	r31, Y+4	; 0x04
    5754:	80 e2       	ldi	r24, 0x20	; 32
    5756:	80 83       	st	Z, r24
	pxTopOfStack--;
    5758:	8b 81       	ldd	r24, Y+3	; 0x03
    575a:	9c 81       	ldd	r25, Y+4	; 0x04
    575c:	01 97       	sbiw	r24, 0x01	; 1
    575e:	9c 83       	std	Y+4, r25	; 0x04
    5760:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    5762:	eb 81       	ldd	r30, Y+3	; 0x03
    5764:	fc 81       	ldd	r31, Y+4	; 0x04
    5766:	81 e2       	ldi	r24, 0x21	; 33
    5768:	80 83       	st	Z, r24
	pxTopOfStack--;
    576a:	8b 81       	ldd	r24, Y+3	; 0x03
    576c:	9c 81       	ldd	r25, Y+4	; 0x04
    576e:	01 97       	sbiw	r24, 0x01	; 1
    5770:	9c 83       	std	Y+4, r25	; 0x04
    5772:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    5774:	eb 81       	ldd	r30, Y+3	; 0x03
    5776:	fc 81       	ldd	r31, Y+4	; 0x04
    5778:	82 e2       	ldi	r24, 0x22	; 34
    577a:	80 83       	st	Z, r24
	pxTopOfStack--;
    577c:	8b 81       	ldd	r24, Y+3	; 0x03
    577e:	9c 81       	ldd	r25, Y+4	; 0x04
    5780:	01 97       	sbiw	r24, 0x01	; 1
    5782:	9c 83       	std	Y+4, r25	; 0x04
    5784:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    5786:	eb 81       	ldd	r30, Y+3	; 0x03
    5788:	fc 81       	ldd	r31, Y+4	; 0x04
    578a:	83 e2       	ldi	r24, 0x23	; 35
    578c:	80 83       	st	Z, r24
	pxTopOfStack--;
    578e:	8b 81       	ldd	r24, Y+3	; 0x03
    5790:	9c 81       	ldd	r25, Y+4	; 0x04
    5792:	01 97       	sbiw	r24, 0x01	; 1
    5794:	9c 83       	std	Y+4, r25	; 0x04
    5796:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    5798:	8f 81       	ldd	r24, Y+7	; 0x07
    579a:	98 85       	ldd	r25, Y+8	; 0x08
    579c:	9a 83       	std	Y+2, r25	; 0x02
    579e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    57a0:	89 81       	ldd	r24, Y+1	; 0x01
    57a2:	eb 81       	ldd	r30, Y+3	; 0x03
    57a4:	fc 81       	ldd	r31, Y+4	; 0x04
    57a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    57a8:	8b 81       	ldd	r24, Y+3	; 0x03
    57aa:	9c 81       	ldd	r25, Y+4	; 0x04
    57ac:	01 97       	sbiw	r24, 0x01	; 1
    57ae:	9c 83       	std	Y+4, r25	; 0x04
    57b0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    57b2:	89 81       	ldd	r24, Y+1	; 0x01
    57b4:	9a 81       	ldd	r25, Y+2	; 0x02
    57b6:	89 2f       	mov	r24, r25
    57b8:	99 27       	eor	r25, r25
    57ba:	9a 83       	std	Y+2, r25	; 0x02
    57bc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    57be:	89 81       	ldd	r24, Y+1	; 0x01
    57c0:	eb 81       	ldd	r30, Y+3	; 0x03
    57c2:	fc 81       	ldd	r31, Y+4	; 0x04
    57c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    57c6:	8b 81       	ldd	r24, Y+3	; 0x03
    57c8:	9c 81       	ldd	r25, Y+4	; 0x04
    57ca:	01 97       	sbiw	r24, 0x01	; 1
    57cc:	9c 83       	std	Y+4, r25	; 0x04
    57ce:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    57d0:	eb 81       	ldd	r30, Y+3	; 0x03
    57d2:	fc 81       	ldd	r31, Y+4	; 0x04
    57d4:	86 e2       	ldi	r24, 0x26	; 38
    57d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    57d8:	8b 81       	ldd	r24, Y+3	; 0x03
    57da:	9c 81       	ldd	r25, Y+4	; 0x04
    57dc:	01 97       	sbiw	r24, 0x01	; 1
    57de:	9c 83       	std	Y+4, r25	; 0x04
    57e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    57e2:	eb 81       	ldd	r30, Y+3	; 0x03
    57e4:	fc 81       	ldd	r31, Y+4	; 0x04
    57e6:	87 e2       	ldi	r24, 0x27	; 39
    57e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    57ea:	8b 81       	ldd	r24, Y+3	; 0x03
    57ec:	9c 81       	ldd	r25, Y+4	; 0x04
    57ee:	01 97       	sbiw	r24, 0x01	; 1
    57f0:	9c 83       	std	Y+4, r25	; 0x04
    57f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    57f4:	eb 81       	ldd	r30, Y+3	; 0x03
    57f6:	fc 81       	ldd	r31, Y+4	; 0x04
    57f8:	88 e2       	ldi	r24, 0x28	; 40
    57fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    57fc:	8b 81       	ldd	r24, Y+3	; 0x03
    57fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5800:	01 97       	sbiw	r24, 0x01	; 1
    5802:	9c 83       	std	Y+4, r25	; 0x04
    5804:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    5806:	eb 81       	ldd	r30, Y+3	; 0x03
    5808:	fc 81       	ldd	r31, Y+4	; 0x04
    580a:	89 e2       	ldi	r24, 0x29	; 41
    580c:	80 83       	st	Z, r24
	pxTopOfStack--;
    580e:	8b 81       	ldd	r24, Y+3	; 0x03
    5810:	9c 81       	ldd	r25, Y+4	; 0x04
    5812:	01 97       	sbiw	r24, 0x01	; 1
    5814:	9c 83       	std	Y+4, r25	; 0x04
    5816:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    5818:	eb 81       	ldd	r30, Y+3	; 0x03
    581a:	fc 81       	ldd	r31, Y+4	; 0x04
    581c:	80 e3       	ldi	r24, 0x30	; 48
    581e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5820:	8b 81       	ldd	r24, Y+3	; 0x03
    5822:	9c 81       	ldd	r25, Y+4	; 0x04
    5824:	01 97       	sbiw	r24, 0x01	; 1
    5826:	9c 83       	std	Y+4, r25	; 0x04
    5828:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    582a:	eb 81       	ldd	r30, Y+3	; 0x03
    582c:	fc 81       	ldd	r31, Y+4	; 0x04
    582e:	81 e3       	ldi	r24, 0x31	; 49
    5830:	80 83       	st	Z, r24
	pxTopOfStack--;
    5832:	8b 81       	ldd	r24, Y+3	; 0x03
    5834:	9c 81       	ldd	r25, Y+4	; 0x04
    5836:	01 97       	sbiw	r24, 0x01	; 1
    5838:	9c 83       	std	Y+4, r25	; 0x04
    583a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    583c:	8b 81       	ldd	r24, Y+3	; 0x03
    583e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    5840:	28 96       	adiw	r28, 0x08	; 8
    5842:	0f b6       	in	r0, 0x3f	; 63
    5844:	f8 94       	cli
    5846:	de bf       	out	0x3e, r29	; 62
    5848:	0f be       	out	0x3f, r0	; 63
    584a:	cd bf       	out	0x3d, r28	; 61
    584c:	cf 91       	pop	r28
    584e:	df 91       	pop	r29
    5850:	08 95       	ret

00005852 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    5852:	df 93       	push	r29
    5854:	cf 93       	push	r28
    5856:	cd b7       	in	r28, 0x3d	; 61
    5858:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    585a:	0e 94 19 2d 	call	0x5a32	; 0x5a32 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    585e:	a0 91 e2 07 	lds	r26, 0x07E2
    5862:	b0 91 e3 07 	lds	r27, 0x07E3
    5866:	cd 91       	ld	r28, X+
    5868:	cd bf       	out	0x3d, r28	; 61
    586a:	dd 91       	ld	r29, X+
    586c:	de bf       	out	0x3e, r29	; 62
    586e:	ff 91       	pop	r31
    5870:	ef 91       	pop	r30
    5872:	df 91       	pop	r29
    5874:	cf 91       	pop	r28
    5876:	bf 91       	pop	r27
    5878:	af 91       	pop	r26
    587a:	9f 91       	pop	r25
    587c:	8f 91       	pop	r24
    587e:	7f 91       	pop	r23
    5880:	6f 91       	pop	r22
    5882:	5f 91       	pop	r21
    5884:	4f 91       	pop	r20
    5886:	3f 91       	pop	r19
    5888:	2f 91       	pop	r18
    588a:	1f 91       	pop	r17
    588c:	0f 91       	pop	r16
    588e:	ff 90       	pop	r15
    5890:	ef 90       	pop	r14
    5892:	df 90       	pop	r13
    5894:	cf 90       	pop	r12
    5896:	bf 90       	pop	r11
    5898:	af 90       	pop	r10
    589a:	9f 90       	pop	r9
    589c:	8f 90       	pop	r8
    589e:	7f 90       	pop	r7
    58a0:	6f 90       	pop	r6
    58a2:	5f 90       	pop	r5
    58a4:	4f 90       	pop	r4
    58a6:	3f 90       	pop	r3
    58a8:	2f 90       	pop	r2
    58aa:	1f 90       	pop	r1
    58ac:	0f 90       	pop	r0
    58ae:	0f be       	out	0x3f, r0	; 63
    58b0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    58b2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    58b4:	81 e0       	ldi	r24, 0x01	; 1
}
    58b6:	cf 91       	pop	r28
    58b8:	df 91       	pop	r29
    58ba:	08 95       	ret

000058bc <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    58bc:	df 93       	push	r29
    58be:	cf 93       	push	r28
    58c0:	cd b7       	in	r28, 0x3d	; 61
    58c2:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    58c4:	cf 91       	pop	r28
    58c6:	df 91       	pop	r29
    58c8:	08 95       	ret

000058ca <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    58ca:	0f 92       	push	r0
    58cc:	0f b6       	in	r0, 0x3f	; 63
    58ce:	f8 94       	cli
    58d0:	0f 92       	push	r0
    58d2:	1f 92       	push	r1
    58d4:	11 24       	eor	r1, r1
    58d6:	2f 92       	push	r2
    58d8:	3f 92       	push	r3
    58da:	4f 92       	push	r4
    58dc:	5f 92       	push	r5
    58de:	6f 92       	push	r6
    58e0:	7f 92       	push	r7
    58e2:	8f 92       	push	r8
    58e4:	9f 92       	push	r9
    58e6:	af 92       	push	r10
    58e8:	bf 92       	push	r11
    58ea:	cf 92       	push	r12
    58ec:	df 92       	push	r13
    58ee:	ef 92       	push	r14
    58f0:	ff 92       	push	r15
    58f2:	0f 93       	push	r16
    58f4:	1f 93       	push	r17
    58f6:	2f 93       	push	r18
    58f8:	3f 93       	push	r19
    58fa:	4f 93       	push	r20
    58fc:	5f 93       	push	r21
    58fe:	6f 93       	push	r22
    5900:	7f 93       	push	r23
    5902:	8f 93       	push	r24
    5904:	9f 93       	push	r25
    5906:	af 93       	push	r26
    5908:	bf 93       	push	r27
    590a:	cf 93       	push	r28
    590c:	df 93       	push	r29
    590e:	ef 93       	push	r30
    5910:	ff 93       	push	r31
    5912:	a0 91 e2 07 	lds	r26, 0x07E2
    5916:	b0 91 e3 07 	lds	r27, 0x07E3
    591a:	0d b6       	in	r0, 0x3d	; 61
    591c:	0d 92       	st	X+, r0
    591e:	0e b6       	in	r0, 0x3e	; 62
    5920:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    5922:	0e 94 53 37 	call	0x6ea6	; 0x6ea6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    5926:	a0 91 e2 07 	lds	r26, 0x07E2
    592a:	b0 91 e3 07 	lds	r27, 0x07E3
    592e:	cd 91       	ld	r28, X+
    5930:	cd bf       	out	0x3d, r28	; 61
    5932:	dd 91       	ld	r29, X+
    5934:	de bf       	out	0x3e, r29	; 62
    5936:	ff 91       	pop	r31
    5938:	ef 91       	pop	r30
    593a:	df 91       	pop	r29
    593c:	cf 91       	pop	r28
    593e:	bf 91       	pop	r27
    5940:	af 91       	pop	r26
    5942:	9f 91       	pop	r25
    5944:	8f 91       	pop	r24
    5946:	7f 91       	pop	r23
    5948:	6f 91       	pop	r22
    594a:	5f 91       	pop	r21
    594c:	4f 91       	pop	r20
    594e:	3f 91       	pop	r19
    5950:	2f 91       	pop	r18
    5952:	1f 91       	pop	r17
    5954:	0f 91       	pop	r16
    5956:	ff 90       	pop	r15
    5958:	ef 90       	pop	r14
    595a:	df 90       	pop	r13
    595c:	cf 90       	pop	r12
    595e:	bf 90       	pop	r11
    5960:	af 90       	pop	r10
    5962:	9f 90       	pop	r9
    5964:	8f 90       	pop	r8
    5966:	7f 90       	pop	r7
    5968:	6f 90       	pop	r6
    596a:	5f 90       	pop	r5
    596c:	4f 90       	pop	r4
    596e:	3f 90       	pop	r3
    5970:	2f 90       	pop	r2
    5972:	1f 90       	pop	r1
    5974:	0f 90       	pop	r0
    5976:	0f be       	out	0x3f, r0	; 63
    5978:	0f 90       	pop	r0

	asm volatile ( "ret" );
    597a:	08 95       	ret

0000597c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    597c:	0f 92       	push	r0
    597e:	0f b6       	in	r0, 0x3f	; 63
    5980:	f8 94       	cli
    5982:	0f 92       	push	r0
    5984:	1f 92       	push	r1
    5986:	11 24       	eor	r1, r1
    5988:	2f 92       	push	r2
    598a:	3f 92       	push	r3
    598c:	4f 92       	push	r4
    598e:	5f 92       	push	r5
    5990:	6f 92       	push	r6
    5992:	7f 92       	push	r7
    5994:	8f 92       	push	r8
    5996:	9f 92       	push	r9
    5998:	af 92       	push	r10
    599a:	bf 92       	push	r11
    599c:	cf 92       	push	r12
    599e:	df 92       	push	r13
    59a0:	ef 92       	push	r14
    59a2:	ff 92       	push	r15
    59a4:	0f 93       	push	r16
    59a6:	1f 93       	push	r17
    59a8:	2f 93       	push	r18
    59aa:	3f 93       	push	r19
    59ac:	4f 93       	push	r20
    59ae:	5f 93       	push	r21
    59b0:	6f 93       	push	r22
    59b2:	7f 93       	push	r23
    59b4:	8f 93       	push	r24
    59b6:	9f 93       	push	r25
    59b8:	af 93       	push	r26
    59ba:	bf 93       	push	r27
    59bc:	cf 93       	push	r28
    59be:	df 93       	push	r29
    59c0:	ef 93       	push	r30
    59c2:	ff 93       	push	r31
    59c4:	a0 91 e2 07 	lds	r26, 0x07E2
    59c8:	b0 91 e3 07 	lds	r27, 0x07E3
    59cc:	0d b6       	in	r0, 0x3d	; 61
    59ce:	0d 92       	st	X+, r0
    59d0:	0e b6       	in	r0, 0x3e	; 62
    59d2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    59d4:	0e 94 7e 36 	call	0x6cfc	; 0x6cfc <vTaskIncrementTick>
	vTaskSwitchContext();
    59d8:	0e 94 53 37 	call	0x6ea6	; 0x6ea6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    59dc:	a0 91 e2 07 	lds	r26, 0x07E2
    59e0:	b0 91 e3 07 	lds	r27, 0x07E3
    59e4:	cd 91       	ld	r28, X+
    59e6:	cd bf       	out	0x3d, r28	; 61
    59e8:	dd 91       	ld	r29, X+
    59ea:	de bf       	out	0x3e, r29	; 62
    59ec:	ff 91       	pop	r31
    59ee:	ef 91       	pop	r30
    59f0:	df 91       	pop	r29
    59f2:	cf 91       	pop	r28
    59f4:	bf 91       	pop	r27
    59f6:	af 91       	pop	r26
    59f8:	9f 91       	pop	r25
    59fa:	8f 91       	pop	r24
    59fc:	7f 91       	pop	r23
    59fe:	6f 91       	pop	r22
    5a00:	5f 91       	pop	r21
    5a02:	4f 91       	pop	r20
    5a04:	3f 91       	pop	r19
    5a06:	2f 91       	pop	r18
    5a08:	1f 91       	pop	r17
    5a0a:	0f 91       	pop	r16
    5a0c:	ff 90       	pop	r15
    5a0e:	ef 90       	pop	r14
    5a10:	df 90       	pop	r13
    5a12:	cf 90       	pop	r12
    5a14:	bf 90       	pop	r11
    5a16:	af 90       	pop	r10
    5a18:	9f 90       	pop	r9
    5a1a:	8f 90       	pop	r8
    5a1c:	7f 90       	pop	r7
    5a1e:	6f 90       	pop	r6
    5a20:	5f 90       	pop	r5
    5a22:	4f 90       	pop	r4
    5a24:	3f 90       	pop	r3
    5a26:	2f 90       	pop	r2
    5a28:	1f 90       	pop	r1
    5a2a:	0f 90       	pop	r0
    5a2c:	0f be       	out	0x3f, r0	; 63
    5a2e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5a30:	08 95       	ret

00005a32 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    5a32:	df 93       	push	r29
    5a34:	cf 93       	push	r28
    5a36:	00 d0       	rcall	.+0      	; 0x5a38 <prvSetupTimerInterrupt+0x6>
    5a38:	00 d0       	rcall	.+0      	; 0x5a3a <prvSetupTimerInterrupt+0x8>
    5a3a:	00 d0       	rcall	.+0      	; 0x5a3c <prvSetupTimerInterrupt+0xa>
    5a3c:	cd b7       	in	r28, 0x3d	; 61
    5a3e:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    5a40:	80 e0       	ldi	r24, 0x00	; 0
    5a42:	94 e2       	ldi	r25, 0x24	; 36
    5a44:	a4 ef       	ldi	r26, 0xF4	; 244
    5a46:	b0 e0       	ldi	r27, 0x00	; 0
    5a48:	8b 83       	std	Y+3, r24	; 0x03
    5a4a:	9c 83       	std	Y+4, r25	; 0x04
    5a4c:	ad 83       	std	Y+5, r26	; 0x05
    5a4e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    5a50:	8b 81       	ldd	r24, Y+3	; 0x03
    5a52:	9c 81       	ldd	r25, Y+4	; 0x04
    5a54:	ad 81       	ldd	r26, Y+5	; 0x05
    5a56:	be 81       	ldd	r27, Y+6	; 0x06
    5a58:	68 94       	set
    5a5a:	15 f8       	bld	r1, 5
    5a5c:	b6 95       	lsr	r27
    5a5e:	a7 95       	ror	r26
    5a60:	97 95       	ror	r25
    5a62:	87 95       	ror	r24
    5a64:	16 94       	lsr	r1
    5a66:	d1 f7       	brne	.-12     	; 0x5a5c <prvSetupTimerInterrupt+0x2a>
    5a68:	8b 83       	std	Y+3, r24	; 0x03
    5a6a:	9c 83       	std	Y+4, r25	; 0x04
    5a6c:	ad 83       	std	Y+5, r26	; 0x05
    5a6e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    5a70:	8b 81       	ldd	r24, Y+3	; 0x03
    5a72:	9c 81       	ldd	r25, Y+4	; 0x04
    5a74:	ad 81       	ldd	r26, Y+5	; 0x05
    5a76:	be 81       	ldd	r27, Y+6	; 0x06
    5a78:	01 97       	sbiw	r24, 0x01	; 1
    5a7a:	a1 09       	sbc	r26, r1
    5a7c:	b1 09       	sbc	r27, r1
    5a7e:	8b 83       	std	Y+3, r24	; 0x03
    5a80:	9c 83       	std	Y+4, r25	; 0x04
    5a82:	ad 83       	std	Y+5, r26	; 0x05
    5a84:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    5a86:	8b 81       	ldd	r24, Y+3	; 0x03
    5a88:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    5a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    5a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    5a8e:	ad 81       	ldd	r26, Y+5	; 0x05
    5a90:	be 81       	ldd	r27, Y+6	; 0x06
    5a92:	89 2f       	mov	r24, r25
    5a94:	9a 2f       	mov	r25, r26
    5a96:	ab 2f       	mov	r26, r27
    5a98:	bb 27       	eor	r27, r27
    5a9a:	8b 83       	std	Y+3, r24	; 0x03
    5a9c:	9c 83       	std	Y+4, r25	; 0x04
    5a9e:	ad 83       	std	Y+5, r26	; 0x05
    5aa0:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    5aa2:	8b 81       	ldd	r24, Y+3	; 0x03
    5aa4:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    5aa6:	eb e4       	ldi	r30, 0x4B	; 75
    5aa8:	f0 e0       	ldi	r31, 0x00	; 0
    5aaa:	8a 81       	ldd	r24, Y+2	; 0x02
    5aac:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    5aae:	ea e4       	ldi	r30, 0x4A	; 74
    5ab0:	f0 e0       	ldi	r31, 0x00	; 0
    5ab2:	89 81       	ldd	r24, Y+1	; 0x01
    5ab4:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    5ab6:	8b e0       	ldi	r24, 0x0B	; 11
    5ab8:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    5aba:	ee e4       	ldi	r30, 0x4E	; 78
    5abc:	f0 e0       	ldi	r31, 0x00	; 0
    5abe:	89 81       	ldd	r24, Y+1	; 0x01
    5ac0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    5ac2:	e9 e5       	ldi	r30, 0x59	; 89
    5ac4:	f0 e0       	ldi	r31, 0x00	; 0
    5ac6:	80 81       	ld	r24, Z
    5ac8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    5aca:	89 81       	ldd	r24, Y+1	; 0x01
    5acc:	80 61       	ori	r24, 0x10	; 16
    5ace:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    5ad0:	e9 e5       	ldi	r30, 0x59	; 89
    5ad2:	f0 e0       	ldi	r31, 0x00	; 0
    5ad4:	89 81       	ldd	r24, Y+1	; 0x01
    5ad6:	80 83       	st	Z, r24
}
    5ad8:	26 96       	adiw	r28, 0x06	; 6
    5ada:	0f b6       	in	r0, 0x3f	; 63
    5adc:	f8 94       	cli
    5ade:	de bf       	out	0x3e, r29	; 62
    5ae0:	0f be       	out	0x3f, r0	; 63
    5ae2:	cd bf       	out	0x3d, r28	; 61
    5ae4:	cf 91       	pop	r28
    5ae6:	df 91       	pop	r29
    5ae8:	08 95       	ret

00005aea <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    5aea:	0e 94 be 2c 	call	0x597c	; 0x597c <vPortYieldFromTick>
		asm volatile ( "reti" );
    5aee:	18 95       	reti

00005af0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    5af0:	df 93       	push	r29
    5af2:	cf 93       	push	r28
    5af4:	cd b7       	in	r28, 0x3d	; 61
    5af6:	de b7       	in	r29, 0x3e	; 62
    5af8:	28 97       	sbiw	r28, 0x08	; 8
    5afa:	0f b6       	in	r0, 0x3f	; 63
    5afc:	f8 94       	cli
    5afe:	de bf       	out	0x3e, r29	; 62
    5b00:	0f be       	out	0x3f, r0	; 63
    5b02:	cd bf       	out	0x3d, r28	; 61
    5b04:	8f 83       	std	Y+7, r24	; 0x07
    5b06:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    5b08:	1a 82       	std	Y+2, r1	; 0x02
    5b0a:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    5b0c:	8f 81       	ldd	r24, Y+7	; 0x07
    5b0e:	88 23       	and	r24, r24
    5b10:	09 f4       	brne	.+2      	; 0x5b14 <xQueueCreate+0x24>
    5b12:	8c c0       	rjmp	.+280    	; 0x5c2c <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    5b14:	8f e1       	ldi	r24, 0x1F	; 31
    5b16:	90 e0       	ldi	r25, 0x00	; 0
    5b18:	0e 94 ff 28 	call	0x51fe	; 0x51fe <pvPortMalloc>
    5b1c:	9e 83       	std	Y+6, r25	; 0x06
    5b1e:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    5b20:	8d 81       	ldd	r24, Y+5	; 0x05
    5b22:	9e 81       	ldd	r25, Y+6	; 0x06
    5b24:	00 97       	sbiw	r24, 0x00	; 0
    5b26:	09 f4       	brne	.+2      	; 0x5b2a <xQueueCreate+0x3a>
    5b28:	81 c0       	rjmp	.+258    	; 0x5c2c <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    5b2a:	8f 81       	ldd	r24, Y+7	; 0x07
    5b2c:	28 2f       	mov	r18, r24
    5b2e:	30 e0       	ldi	r19, 0x00	; 0
    5b30:	88 85       	ldd	r24, Y+8	; 0x08
    5b32:	88 2f       	mov	r24, r24
    5b34:	90 e0       	ldi	r25, 0x00	; 0
    5b36:	ac 01       	movw	r20, r24
    5b38:	24 9f       	mul	r18, r20
    5b3a:	c0 01       	movw	r24, r0
    5b3c:	25 9f       	mul	r18, r21
    5b3e:	90 0d       	add	r25, r0
    5b40:	34 9f       	mul	r19, r20
    5b42:	90 0d       	add	r25, r0
    5b44:	11 24       	eor	r1, r1
    5b46:	01 96       	adiw	r24, 0x01	; 1
    5b48:	9c 83       	std	Y+4, r25	; 0x04
    5b4a:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    5b4c:	8b 81       	ldd	r24, Y+3	; 0x03
    5b4e:	9c 81       	ldd	r25, Y+4	; 0x04
    5b50:	0e 94 ff 28 	call	0x51fe	; 0x51fe <pvPortMalloc>
    5b54:	ed 81       	ldd	r30, Y+5	; 0x05
    5b56:	fe 81       	ldd	r31, Y+6	; 0x06
    5b58:	91 83       	std	Z+1, r25	; 0x01
    5b5a:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    5b5c:	ed 81       	ldd	r30, Y+5	; 0x05
    5b5e:	fe 81       	ldd	r31, Y+6	; 0x06
    5b60:	80 81       	ld	r24, Z
    5b62:	91 81       	ldd	r25, Z+1	; 0x01
    5b64:	00 97       	sbiw	r24, 0x00	; 0
    5b66:	09 f4       	brne	.+2      	; 0x5b6a <xQueueCreate+0x7a>
    5b68:	5d c0       	rjmp	.+186    	; 0x5c24 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    5b6a:	ed 81       	ldd	r30, Y+5	; 0x05
    5b6c:	fe 81       	ldd	r31, Y+6	; 0x06
    5b6e:	40 81       	ld	r20, Z
    5b70:	51 81       	ldd	r21, Z+1	; 0x01
    5b72:	8f 81       	ldd	r24, Y+7	; 0x07
    5b74:	28 2f       	mov	r18, r24
    5b76:	30 e0       	ldi	r19, 0x00	; 0
    5b78:	88 85       	ldd	r24, Y+8	; 0x08
    5b7a:	88 2f       	mov	r24, r24
    5b7c:	90 e0       	ldi	r25, 0x00	; 0
    5b7e:	bc 01       	movw	r22, r24
    5b80:	26 9f       	mul	r18, r22
    5b82:	c0 01       	movw	r24, r0
    5b84:	27 9f       	mul	r18, r23
    5b86:	90 0d       	add	r25, r0
    5b88:	36 9f       	mul	r19, r22
    5b8a:	90 0d       	add	r25, r0
    5b8c:	11 24       	eor	r1, r1
    5b8e:	84 0f       	add	r24, r20
    5b90:	95 1f       	adc	r25, r21
    5b92:	ed 81       	ldd	r30, Y+5	; 0x05
    5b94:	fe 81       	ldd	r31, Y+6	; 0x06
    5b96:	93 83       	std	Z+3, r25	; 0x03
    5b98:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    5b9a:	ed 81       	ldd	r30, Y+5	; 0x05
    5b9c:	fe 81       	ldd	r31, Y+6	; 0x06
    5b9e:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    5ba0:	ed 81       	ldd	r30, Y+5	; 0x05
    5ba2:	fe 81       	ldd	r31, Y+6	; 0x06
    5ba4:	80 81       	ld	r24, Z
    5ba6:	91 81       	ldd	r25, Z+1	; 0x01
    5ba8:	ed 81       	ldd	r30, Y+5	; 0x05
    5baa:	fe 81       	ldd	r31, Y+6	; 0x06
    5bac:	95 83       	std	Z+5, r25	; 0x05
    5bae:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    5bb0:	ed 81       	ldd	r30, Y+5	; 0x05
    5bb2:	fe 81       	ldd	r31, Y+6	; 0x06
    5bb4:	40 81       	ld	r20, Z
    5bb6:	51 81       	ldd	r21, Z+1	; 0x01
    5bb8:	8f 81       	ldd	r24, Y+7	; 0x07
    5bba:	88 2f       	mov	r24, r24
    5bbc:	90 e0       	ldi	r25, 0x00	; 0
    5bbe:	9c 01       	movw	r18, r24
    5bc0:	21 50       	subi	r18, 0x01	; 1
    5bc2:	30 40       	sbci	r19, 0x00	; 0
    5bc4:	88 85       	ldd	r24, Y+8	; 0x08
    5bc6:	88 2f       	mov	r24, r24
    5bc8:	90 e0       	ldi	r25, 0x00	; 0
    5bca:	bc 01       	movw	r22, r24
    5bcc:	26 9f       	mul	r18, r22
    5bce:	c0 01       	movw	r24, r0
    5bd0:	27 9f       	mul	r18, r23
    5bd2:	90 0d       	add	r25, r0
    5bd4:	36 9f       	mul	r19, r22
    5bd6:	90 0d       	add	r25, r0
    5bd8:	11 24       	eor	r1, r1
    5bda:	84 0f       	add	r24, r20
    5bdc:	95 1f       	adc	r25, r21
    5bde:	ed 81       	ldd	r30, Y+5	; 0x05
    5be0:	fe 81       	ldd	r31, Y+6	; 0x06
    5be2:	97 83       	std	Z+7, r25	; 0x07
    5be4:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    5be6:	ed 81       	ldd	r30, Y+5	; 0x05
    5be8:	fe 81       	ldd	r31, Y+6	; 0x06
    5bea:	8f 81       	ldd	r24, Y+7	; 0x07
    5bec:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    5bee:	ed 81       	ldd	r30, Y+5	; 0x05
    5bf0:	fe 81       	ldd	r31, Y+6	; 0x06
    5bf2:	88 85       	ldd	r24, Y+8	; 0x08
    5bf4:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    5bf6:	ed 81       	ldd	r30, Y+5	; 0x05
    5bf8:	fe 81       	ldd	r31, Y+6	; 0x06
    5bfa:	8f ef       	ldi	r24, 0xFF	; 255
    5bfc:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    5bfe:	ed 81       	ldd	r30, Y+5	; 0x05
    5c00:	fe 81       	ldd	r31, Y+6	; 0x06
    5c02:	8f ef       	ldi	r24, 0xFF	; 255
    5c04:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    5c06:	8d 81       	ldd	r24, Y+5	; 0x05
    5c08:	9e 81       	ldd	r25, Y+6	; 0x06
    5c0a:	08 96       	adiw	r24, 0x08	; 8
    5c0c:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    5c10:	8d 81       	ldd	r24, Y+5	; 0x05
    5c12:	9e 81       	ldd	r25, Y+6	; 0x06
    5c14:	41 96       	adiw	r24, 0x11	; 17
    5c16:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    5c1a:	8d 81       	ldd	r24, Y+5	; 0x05
    5c1c:	9e 81       	ldd	r25, Y+6	; 0x06
    5c1e:	9a 83       	std	Y+2, r25	; 0x02
    5c20:	89 83       	std	Y+1, r24	; 0x01
    5c22:	04 c0       	rjmp	.+8      	; 0x5c2c <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    5c24:	8d 81       	ldd	r24, Y+5	; 0x05
    5c26:	9e 81       	ldd	r25, Y+6	; 0x06
    5c28:	0e 94 45 29 	call	0x528a	; 0x528a <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    5c2c:	89 81       	ldd	r24, Y+1	; 0x01
    5c2e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5c30:	28 96       	adiw	r28, 0x08	; 8
    5c32:	0f b6       	in	r0, 0x3f	; 63
    5c34:	f8 94       	cli
    5c36:	de bf       	out	0x3e, r29	; 62
    5c38:	0f be       	out	0x3f, r0	; 63
    5c3a:	cd bf       	out	0x3d, r28	; 61
    5c3c:	cf 91       	pop	r28
    5c3e:	df 91       	pop	r29
    5c40:	08 95       	ret

00005c42 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    5c42:	df 93       	push	r29
    5c44:	cf 93       	push	r28
    5c46:	00 d0       	rcall	.+0      	; 0x5c48 <xQueueCreateCountingSemaphore+0x6>
    5c48:	00 d0       	rcall	.+0      	; 0x5c4a <xQueueCreateCountingSemaphore+0x8>
    5c4a:	cd b7       	in	r28, 0x3d	; 61
    5c4c:	de b7       	in	r29, 0x3e	; 62
    5c4e:	8b 83       	std	Y+3, r24	; 0x03
    5c50:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    5c52:	8b 81       	ldd	r24, Y+3	; 0x03
    5c54:	60 e0       	ldi	r22, 0x00	; 0
    5c56:	0e 94 78 2d 	call	0x5af0	; 0x5af0 <xQueueCreate>
    5c5a:	9a 83       	std	Y+2, r25	; 0x02
    5c5c:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    5c5e:	89 81       	ldd	r24, Y+1	; 0x01
    5c60:	9a 81       	ldd	r25, Y+2	; 0x02
    5c62:	00 97       	sbiw	r24, 0x00	; 0
    5c64:	21 f0       	breq	.+8      	; 0x5c6e <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    5c66:	e9 81       	ldd	r30, Y+1	; 0x01
    5c68:	fa 81       	ldd	r31, Y+2	; 0x02
    5c6a:	8c 81       	ldd	r24, Y+4	; 0x04
    5c6c:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    5c6e:	89 81       	ldd	r24, Y+1	; 0x01
    5c70:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    5c72:	0f 90       	pop	r0
    5c74:	0f 90       	pop	r0
    5c76:	0f 90       	pop	r0
    5c78:	0f 90       	pop	r0
    5c7a:	cf 91       	pop	r28
    5c7c:	df 91       	pop	r29
    5c7e:	08 95       	ret

00005c80 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    5c80:	df 93       	push	r29
    5c82:	cf 93       	push	r28
    5c84:	cd b7       	in	r28, 0x3d	; 61
    5c86:	de b7       	in	r29, 0x3e	; 62
    5c88:	2c 97       	sbiw	r28, 0x0c	; 12
    5c8a:	0f b6       	in	r0, 0x3f	; 63
    5c8c:	f8 94       	cli
    5c8e:	de bf       	out	0x3e, r29	; 62
    5c90:	0f be       	out	0x3f, r0	; 63
    5c92:	cd bf       	out	0x3d, r28	; 61
    5c94:	9e 83       	std	Y+6, r25	; 0x06
    5c96:	8d 83       	std	Y+5, r24	; 0x05
    5c98:	78 87       	std	Y+8, r23	; 0x08
    5c9a:	6f 83       	std	Y+7, r22	; 0x07
    5c9c:	5a 87       	std	Y+10, r21	; 0x0a
    5c9e:	49 87       	std	Y+9, r20	; 0x09
    5ca0:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    5ca2:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5ca4:	0f b6       	in	r0, 0x3f	; 63
    5ca6:	f8 94       	cli
    5ca8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    5caa:	ed 81       	ldd	r30, Y+5	; 0x05
    5cac:	fe 81       	ldd	r31, Y+6	; 0x06
    5cae:	92 8d       	ldd	r25, Z+26	; 0x1a
    5cb0:	ed 81       	ldd	r30, Y+5	; 0x05
    5cb2:	fe 81       	ldd	r31, Y+6	; 0x06
    5cb4:	83 8d       	ldd	r24, Z+27	; 0x1b
    5cb6:	98 17       	cp	r25, r24
    5cb8:	d8 f4       	brcc	.+54     	; 0x5cf0 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    5cba:	8d 81       	ldd	r24, Y+5	; 0x05
    5cbc:	9e 81       	ldd	r25, Y+6	; 0x06
    5cbe:	2f 81       	ldd	r18, Y+7	; 0x07
    5cc0:	38 85       	ldd	r19, Y+8	; 0x08
    5cc2:	b9 01       	movw	r22, r18
    5cc4:	4b 85       	ldd	r20, Y+11	; 0x0b
    5cc6:	0e 94 7b 30 	call	0x60f6	; 0x60f6 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5cca:	ed 81       	ldd	r30, Y+5	; 0x05
    5ccc:	fe 81       	ldd	r31, Y+6	; 0x06
    5cce:	81 89       	ldd	r24, Z+17	; 0x11
    5cd0:	88 23       	and	r24, r24
    5cd2:	49 f0       	breq	.+18     	; 0x5ce6 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    5cd4:	8d 81       	ldd	r24, Y+5	; 0x05
    5cd6:	9e 81       	ldd	r25, Y+6	; 0x06
    5cd8:	41 96       	adiw	r24, 0x11	; 17
    5cda:	0e 94 02 38 	call	0x7004	; 0x7004 <xTaskRemoveFromEventList>
    5cde:	81 30       	cpi	r24, 0x01	; 1
    5ce0:	11 f4       	brne	.+4      	; 0x5ce6 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    5ce2:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    5ce6:	0f 90       	pop	r0
    5ce8:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    5cea:	81 e0       	ldi	r24, 0x01	; 1
    5cec:	8c 87       	std	Y+12, r24	; 0x0c
    5cee:	5c c0       	rjmp	.+184    	; 0x5da8 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    5cf0:	89 85       	ldd	r24, Y+9	; 0x09
    5cf2:	9a 85       	ldd	r25, Y+10	; 0x0a
    5cf4:	00 97       	sbiw	r24, 0x00	; 0
    5cf6:	21 f4       	brne	.+8      	; 0x5d00 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5cf8:	0f 90       	pop	r0
    5cfa:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    5cfc:	1c 86       	std	Y+12, r1	; 0x0c
    5cfe:	54 c0       	rjmp	.+168    	; 0x5da8 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    5d00:	89 81       	ldd	r24, Y+1	; 0x01
    5d02:	88 23       	and	r24, r24
    5d04:	31 f4       	brne	.+12     	; 0x5d12 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    5d06:	ce 01       	movw	r24, r28
    5d08:	02 96       	adiw	r24, 0x02	; 2
    5d0a:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5d0e:	81 e0       	ldi	r24, 0x01	; 1
    5d10:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    5d12:	0f 90       	pop	r0
    5d14:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5d16:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5d1a:	0f b6       	in	r0, 0x3f	; 63
    5d1c:	f8 94       	cli
    5d1e:	0f 92       	push	r0
    5d20:	ed 81       	ldd	r30, Y+5	; 0x05
    5d22:	fe 81       	ldd	r31, Y+6	; 0x06
    5d24:	85 8d       	ldd	r24, Z+29	; 0x1d
    5d26:	8f 3f       	cpi	r24, 0xFF	; 255
    5d28:	19 f4       	brne	.+6      	; 0x5d30 <xQueueGenericSend+0xb0>
    5d2a:	ed 81       	ldd	r30, Y+5	; 0x05
    5d2c:	fe 81       	ldd	r31, Y+6	; 0x06
    5d2e:	15 8e       	std	Z+29, r1	; 0x1d
    5d30:	ed 81       	ldd	r30, Y+5	; 0x05
    5d32:	fe 81       	ldd	r31, Y+6	; 0x06
    5d34:	86 8d       	ldd	r24, Z+30	; 0x1e
    5d36:	8f 3f       	cpi	r24, 0xFF	; 255
    5d38:	19 f4       	brne	.+6      	; 0x5d40 <xQueueGenericSend+0xc0>
    5d3a:	ed 81       	ldd	r30, Y+5	; 0x05
    5d3c:	fe 81       	ldd	r31, Y+6	; 0x06
    5d3e:	16 8e       	std	Z+30, r1	; 0x1e
    5d40:	0f 90       	pop	r0
    5d42:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5d44:	ce 01       	movw	r24, r28
    5d46:	02 96       	adiw	r24, 0x02	; 2
    5d48:	9e 01       	movw	r18, r28
    5d4a:	27 5f       	subi	r18, 0xF7	; 247
    5d4c:	3f 4f       	sbci	r19, 0xFF	; 255
    5d4e:	b9 01       	movw	r22, r18
    5d50:	0e 94 83 38 	call	0x7106	; 0x7106 <xTaskCheckForTimeOut>
    5d54:	88 23       	and	r24, r24
    5d56:	09 f5       	brne	.+66     	; 0x5d9a <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5d58:	8d 81       	ldd	r24, Y+5	; 0x05
    5d5a:	9e 81       	ldd	r25, Y+6	; 0x06
    5d5c:	0e 94 df 31 	call	0x63be	; 0x63be <prvIsQueueFull>
    5d60:	88 23       	and	r24, r24
    5d62:	a1 f0       	breq	.+40     	; 0x5d8c <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5d64:	8d 81       	ldd	r24, Y+5	; 0x05
    5d66:	9e 81       	ldd	r25, Y+6	; 0x06
    5d68:	08 96       	adiw	r24, 0x08	; 8
    5d6a:	29 85       	ldd	r18, Y+9	; 0x09
    5d6c:	3a 85       	ldd	r19, Y+10	; 0x0a
    5d6e:	b9 01       	movw	r22, r18
    5d70:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    5d74:	8d 81       	ldd	r24, Y+5	; 0x05
    5d76:	9e 81       	ldd	r25, Y+6	; 0x06
    5d78:	0e 94 58 31 	call	0x62b0	; 0x62b0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    5d7c:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>
    5d80:	88 23       	and	r24, r24
    5d82:	09 f0       	breq	.+2      	; 0x5d86 <xQueueGenericSend+0x106>
    5d84:	8f cf       	rjmp	.-226    	; 0x5ca4 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    5d86:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
    5d8a:	8c cf       	rjmp	.-232    	; 0x5ca4 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5d8c:	8d 81       	ldd	r24, Y+5	; 0x05
    5d8e:	9e 81       	ldd	r25, Y+6	; 0x06
    5d90:	0e 94 58 31 	call	0x62b0	; 0x62b0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5d94:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>
    5d98:	85 cf       	rjmp	.-246    	; 0x5ca4 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    5d9a:	8d 81       	ldd	r24, Y+5	; 0x05
    5d9c:	9e 81       	ldd	r25, Y+6	; 0x06
    5d9e:	0e 94 58 31 	call	0x62b0	; 0x62b0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5da2:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    5da6:	1c 86       	std	Y+12, r1	; 0x0c
    5da8:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    5daa:	2c 96       	adiw	r28, 0x0c	; 12
    5dac:	0f b6       	in	r0, 0x3f	; 63
    5dae:	f8 94       	cli
    5db0:	de bf       	out	0x3e, r29	; 62
    5db2:	0f be       	out	0x3f, r0	; 63
    5db4:	cd bf       	out	0x3d, r28	; 61
    5db6:	cf 91       	pop	r28
    5db8:	df 91       	pop	r29
    5dba:	08 95       	ret

00005dbc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    5dbc:	df 93       	push	r29
    5dbe:	cf 93       	push	r28
    5dc0:	cd b7       	in	r28, 0x3d	; 61
    5dc2:	de b7       	in	r29, 0x3e	; 62
    5dc4:	29 97       	sbiw	r28, 0x09	; 9
    5dc6:	0f b6       	in	r0, 0x3f	; 63
    5dc8:	f8 94       	cli
    5dca:	de bf       	out	0x3e, r29	; 62
    5dcc:	0f be       	out	0x3f, r0	; 63
    5dce:	cd bf       	out	0x3d, r28	; 61
    5dd0:	9c 83       	std	Y+4, r25	; 0x04
    5dd2:	8b 83       	std	Y+3, r24	; 0x03
    5dd4:	7e 83       	std	Y+6, r23	; 0x06
    5dd6:	6d 83       	std	Y+5, r22	; 0x05
    5dd8:	58 87       	std	Y+8, r21	; 0x08
    5dda:	4f 83       	std	Y+7, r20	; 0x07
    5ddc:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5dde:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    5de0:	eb 81       	ldd	r30, Y+3	; 0x03
    5de2:	fc 81       	ldd	r31, Y+4	; 0x04
    5de4:	92 8d       	ldd	r25, Z+26	; 0x1a
    5de6:	eb 81       	ldd	r30, Y+3	; 0x03
    5de8:	fc 81       	ldd	r31, Y+4	; 0x04
    5dea:	83 8d       	ldd	r24, Z+27	; 0x1b
    5dec:	98 17       	cp	r25, r24
    5dee:	40 f5       	brcc	.+80     	; 0x5e40 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    5df0:	8b 81       	ldd	r24, Y+3	; 0x03
    5df2:	9c 81       	ldd	r25, Y+4	; 0x04
    5df4:	2d 81       	ldd	r18, Y+5	; 0x05
    5df6:	3e 81       	ldd	r19, Y+6	; 0x06
    5df8:	b9 01       	movw	r22, r18
    5dfa:	49 85       	ldd	r20, Y+9	; 0x09
    5dfc:	0e 94 7b 30 	call	0x60f6	; 0x60f6 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    5e00:	eb 81       	ldd	r30, Y+3	; 0x03
    5e02:	fc 81       	ldd	r31, Y+4	; 0x04
    5e04:	86 8d       	ldd	r24, Z+30	; 0x1e
    5e06:	8f 3f       	cpi	r24, 0xFF	; 255
    5e08:	89 f4       	brne	.+34     	; 0x5e2c <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5e0a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e0c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e0e:	81 89       	ldd	r24, Z+17	; 0x11
    5e10:	88 23       	and	r24, r24
    5e12:	99 f0       	breq	.+38     	; 0x5e3a <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5e14:	8b 81       	ldd	r24, Y+3	; 0x03
    5e16:	9c 81       	ldd	r25, Y+4	; 0x04
    5e18:	41 96       	adiw	r24, 0x11	; 17
    5e1a:	0e 94 02 38 	call	0x7004	; 0x7004 <xTaskRemoveFromEventList>
    5e1e:	88 23       	and	r24, r24
    5e20:	61 f0       	breq	.+24     	; 0x5e3a <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    5e22:	ef 81       	ldd	r30, Y+7	; 0x07
    5e24:	f8 85       	ldd	r31, Y+8	; 0x08
    5e26:	81 e0       	ldi	r24, 0x01	; 1
    5e28:	80 83       	st	Z, r24
    5e2a:	07 c0       	rjmp	.+14     	; 0x5e3a <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    5e2c:	eb 81       	ldd	r30, Y+3	; 0x03
    5e2e:	fc 81       	ldd	r31, Y+4	; 0x04
    5e30:	86 8d       	ldd	r24, Z+30	; 0x1e
    5e32:	8f 5f       	subi	r24, 0xFF	; 255
    5e34:	eb 81       	ldd	r30, Y+3	; 0x03
    5e36:	fc 81       	ldd	r31, Y+4	; 0x04
    5e38:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    5e3a:	81 e0       	ldi	r24, 0x01	; 1
    5e3c:	8a 83       	std	Y+2, r24	; 0x02
    5e3e:	01 c0       	rjmp	.+2      	; 0x5e42 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    5e40:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5e42:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5e44:	29 96       	adiw	r28, 0x09	; 9
    5e46:	0f b6       	in	r0, 0x3f	; 63
    5e48:	f8 94       	cli
    5e4a:	de bf       	out	0x3e, r29	; 62
    5e4c:	0f be       	out	0x3f, r0	; 63
    5e4e:	cd bf       	out	0x3d, r28	; 61
    5e50:	cf 91       	pop	r28
    5e52:	df 91       	pop	r29
    5e54:	08 95       	ret

00005e56 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    5e56:	df 93       	push	r29
    5e58:	cf 93       	push	r28
    5e5a:	cd b7       	in	r28, 0x3d	; 61
    5e5c:	de b7       	in	r29, 0x3e	; 62
    5e5e:	2e 97       	sbiw	r28, 0x0e	; 14
    5e60:	0f b6       	in	r0, 0x3f	; 63
    5e62:	f8 94       	cli
    5e64:	de bf       	out	0x3e, r29	; 62
    5e66:	0f be       	out	0x3f, r0	; 63
    5e68:	cd bf       	out	0x3d, r28	; 61
    5e6a:	98 87       	std	Y+8, r25	; 0x08
    5e6c:	8f 83       	std	Y+7, r24	; 0x07
    5e6e:	7a 87       	std	Y+10, r23	; 0x0a
    5e70:	69 87       	std	Y+9, r22	; 0x09
    5e72:	5c 87       	std	Y+12, r21	; 0x0c
    5e74:	4b 87       	std	Y+11, r20	; 0x0b
    5e76:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    5e78:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    5e7a:	0f b6       	in	r0, 0x3f	; 63
    5e7c:	f8 94       	cli
    5e7e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    5e80:	ef 81       	ldd	r30, Y+7	; 0x07
    5e82:	f8 85       	ldd	r31, Y+8	; 0x08
    5e84:	82 8d       	ldd	r24, Z+26	; 0x1a
    5e86:	88 23       	and	r24, r24
    5e88:	09 f4       	brne	.+2      	; 0x5e8c <xQueueGenericReceive+0x36>
    5e8a:	3f c0       	rjmp	.+126    	; 0x5f0a <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    5e8c:	ef 81       	ldd	r30, Y+7	; 0x07
    5e8e:	f8 85       	ldd	r31, Y+8	; 0x08
    5e90:	86 81       	ldd	r24, Z+6	; 0x06
    5e92:	97 81       	ldd	r25, Z+7	; 0x07
    5e94:	9a 83       	std	Y+2, r25	; 0x02
    5e96:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    5e98:	8f 81       	ldd	r24, Y+7	; 0x07
    5e9a:	98 85       	ldd	r25, Y+8	; 0x08
    5e9c:	29 85       	ldd	r18, Y+9	; 0x09
    5e9e:	3a 85       	ldd	r19, Y+10	; 0x0a
    5ea0:	b9 01       	movw	r22, r18
    5ea2:	0e 94 10 31 	call	0x6220	; 0x6220 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    5ea6:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ea8:	88 23       	and	r24, r24
    5eaa:	b1 f4       	brne	.+44     	; 0x5ed8 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    5eac:	ef 81       	ldd	r30, Y+7	; 0x07
    5eae:	f8 85       	ldd	r31, Y+8	; 0x08
    5eb0:	82 8d       	ldd	r24, Z+26	; 0x1a
    5eb2:	81 50       	subi	r24, 0x01	; 1
    5eb4:	ef 81       	ldd	r30, Y+7	; 0x07
    5eb6:	f8 85       	ldd	r31, Y+8	; 0x08
    5eb8:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5eba:	ef 81       	ldd	r30, Y+7	; 0x07
    5ebc:	f8 85       	ldd	r31, Y+8	; 0x08
    5ebe:	80 85       	ldd	r24, Z+8	; 0x08
    5ec0:	88 23       	and	r24, r24
    5ec2:	f1 f0       	breq	.+60     	; 0x5f00 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    5ec4:	8f 81       	ldd	r24, Y+7	; 0x07
    5ec6:	98 85       	ldd	r25, Y+8	; 0x08
    5ec8:	08 96       	adiw	r24, 0x08	; 8
    5eca:	0e 94 02 38 	call	0x7004	; 0x7004 <xTaskRemoveFromEventList>
    5ece:	81 30       	cpi	r24, 0x01	; 1
    5ed0:	b9 f4       	brne	.+46     	; 0x5f00 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    5ed2:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
    5ed6:	14 c0       	rjmp	.+40     	; 0x5f00 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    5ed8:	ef 81       	ldd	r30, Y+7	; 0x07
    5eda:	f8 85       	ldd	r31, Y+8	; 0x08
    5edc:	89 81       	ldd	r24, Y+1	; 0x01
    5ede:	9a 81       	ldd	r25, Y+2	; 0x02
    5ee0:	97 83       	std	Z+7, r25	; 0x07
    5ee2:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5ee4:	ef 81       	ldd	r30, Y+7	; 0x07
    5ee6:	f8 85       	ldd	r31, Y+8	; 0x08
    5ee8:	81 89       	ldd	r24, Z+17	; 0x11
    5eea:	88 23       	and	r24, r24
    5eec:	49 f0       	breq	.+18     	; 0x5f00 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5eee:	8f 81       	ldd	r24, Y+7	; 0x07
    5ef0:	98 85       	ldd	r25, Y+8	; 0x08
    5ef2:	41 96       	adiw	r24, 0x11	; 17
    5ef4:	0e 94 02 38 	call	0x7004	; 0x7004 <xTaskRemoveFromEventList>
    5ef8:	88 23       	and	r24, r24
    5efa:	11 f0       	breq	.+4      	; 0x5f00 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    5efc:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    5f00:	0f 90       	pop	r0
    5f02:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    5f04:	81 e0       	ldi	r24, 0x01	; 1
    5f06:	8e 87       	std	Y+14, r24	; 0x0e
    5f08:	5c c0       	rjmp	.+184    	; 0x5fc2 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    5f0a:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f0c:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f0e:	00 97       	sbiw	r24, 0x00	; 0
    5f10:	21 f4       	brne	.+8      	; 0x5f1a <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5f12:	0f 90       	pop	r0
    5f14:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    5f16:	1e 86       	std	Y+14, r1	; 0x0e
    5f18:	54 c0       	rjmp	.+168    	; 0x5fc2 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    5f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    5f1c:	88 23       	and	r24, r24
    5f1e:	31 f4       	brne	.+12     	; 0x5f2c <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    5f20:	ce 01       	movw	r24, r28
    5f22:	04 96       	adiw	r24, 0x04	; 4
    5f24:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5f28:	81 e0       	ldi	r24, 0x01	; 1
    5f2a:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    5f2c:	0f 90       	pop	r0
    5f2e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5f30:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5f34:	0f b6       	in	r0, 0x3f	; 63
    5f36:	f8 94       	cli
    5f38:	0f 92       	push	r0
    5f3a:	ef 81       	ldd	r30, Y+7	; 0x07
    5f3c:	f8 85       	ldd	r31, Y+8	; 0x08
    5f3e:	85 8d       	ldd	r24, Z+29	; 0x1d
    5f40:	8f 3f       	cpi	r24, 0xFF	; 255
    5f42:	19 f4       	brne	.+6      	; 0x5f4a <xQueueGenericReceive+0xf4>
    5f44:	ef 81       	ldd	r30, Y+7	; 0x07
    5f46:	f8 85       	ldd	r31, Y+8	; 0x08
    5f48:	15 8e       	std	Z+29, r1	; 0x1d
    5f4a:	ef 81       	ldd	r30, Y+7	; 0x07
    5f4c:	f8 85       	ldd	r31, Y+8	; 0x08
    5f4e:	86 8d       	ldd	r24, Z+30	; 0x1e
    5f50:	8f 3f       	cpi	r24, 0xFF	; 255
    5f52:	19 f4       	brne	.+6      	; 0x5f5a <xQueueGenericReceive+0x104>
    5f54:	ef 81       	ldd	r30, Y+7	; 0x07
    5f56:	f8 85       	ldd	r31, Y+8	; 0x08
    5f58:	16 8e       	std	Z+30, r1	; 0x1e
    5f5a:	0f 90       	pop	r0
    5f5c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5f5e:	ce 01       	movw	r24, r28
    5f60:	04 96       	adiw	r24, 0x04	; 4
    5f62:	9e 01       	movw	r18, r28
    5f64:	25 5f       	subi	r18, 0xF5	; 245
    5f66:	3f 4f       	sbci	r19, 0xFF	; 255
    5f68:	b9 01       	movw	r22, r18
    5f6a:	0e 94 83 38 	call	0x7106	; 0x7106 <xTaskCheckForTimeOut>
    5f6e:	88 23       	and	r24, r24
    5f70:	09 f5       	brne	.+66     	; 0x5fb4 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5f72:	8f 81       	ldd	r24, Y+7	; 0x07
    5f74:	98 85       	ldd	r25, Y+8	; 0x08
    5f76:	0e 94 ac 31 	call	0x6358	; 0x6358 <prvIsQueueEmpty>
    5f7a:	88 23       	and	r24, r24
    5f7c:	a1 f0       	breq	.+40     	; 0x5fa6 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5f7e:	8f 81       	ldd	r24, Y+7	; 0x07
    5f80:	98 85       	ldd	r25, Y+8	; 0x08
    5f82:	41 96       	adiw	r24, 0x11	; 17
    5f84:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f86:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f88:	b9 01       	movw	r22, r18
    5f8a:	0e 94 b9 37 	call	0x6f72	; 0x6f72 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    5f8e:	8f 81       	ldd	r24, Y+7	; 0x07
    5f90:	98 85       	ldd	r25, Y+8	; 0x08
    5f92:	0e 94 58 31 	call	0x62b0	; 0x62b0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5f96:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>
    5f9a:	88 23       	and	r24, r24
    5f9c:	09 f0       	breq	.+2      	; 0x5fa0 <xQueueGenericReceive+0x14a>
    5f9e:	6d cf       	rjmp	.-294    	; 0x5e7a <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    5fa0:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
    5fa4:	6a cf       	rjmp	.-300    	; 0x5e7a <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5fa6:	8f 81       	ldd	r24, Y+7	; 0x07
    5fa8:	98 85       	ldd	r25, Y+8	; 0x08
    5faa:	0e 94 58 31 	call	0x62b0	; 0x62b0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5fae:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>
    5fb2:	63 cf       	rjmp	.-314    	; 0x5e7a <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    5fb4:	8f 81       	ldd	r24, Y+7	; 0x07
    5fb6:	98 85       	ldd	r25, Y+8	; 0x08
    5fb8:	0e 94 58 31 	call	0x62b0	; 0x62b0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5fbc:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    5fc0:	1e 86       	std	Y+14, r1	; 0x0e
    5fc2:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    5fc4:	2e 96       	adiw	r28, 0x0e	; 14
    5fc6:	0f b6       	in	r0, 0x3f	; 63
    5fc8:	f8 94       	cli
    5fca:	de bf       	out	0x3e, r29	; 62
    5fcc:	0f be       	out	0x3f, r0	; 63
    5fce:	cd bf       	out	0x3d, r28	; 61
    5fd0:	cf 91       	pop	r28
    5fd2:	df 91       	pop	r29
    5fd4:	08 95       	ret

00005fd6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    5fd6:	df 93       	push	r29
    5fd8:	cf 93       	push	r28
    5fda:	cd b7       	in	r28, 0x3d	; 61
    5fdc:	de b7       	in	r29, 0x3e	; 62
    5fde:	28 97       	sbiw	r28, 0x08	; 8
    5fe0:	0f b6       	in	r0, 0x3f	; 63
    5fe2:	f8 94       	cli
    5fe4:	de bf       	out	0x3e, r29	; 62
    5fe6:	0f be       	out	0x3f, r0	; 63
    5fe8:	cd bf       	out	0x3d, r28	; 61
    5fea:	9c 83       	std	Y+4, r25	; 0x04
    5fec:	8b 83       	std	Y+3, r24	; 0x03
    5fee:	7e 83       	std	Y+6, r23	; 0x06
    5ff0:	6d 83       	std	Y+5, r22	; 0x05
    5ff2:	58 87       	std	Y+8, r21	; 0x08
    5ff4:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5ff6:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    5ff8:	eb 81       	ldd	r30, Y+3	; 0x03
    5ffa:	fc 81       	ldd	r31, Y+4	; 0x04
    5ffc:	82 8d       	ldd	r24, Z+26	; 0x1a
    5ffe:	88 23       	and	r24, r24
    6000:	71 f1       	breq	.+92     	; 0x605e <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    6002:	8b 81       	ldd	r24, Y+3	; 0x03
    6004:	9c 81       	ldd	r25, Y+4	; 0x04
    6006:	2d 81       	ldd	r18, Y+5	; 0x05
    6008:	3e 81       	ldd	r19, Y+6	; 0x06
    600a:	b9 01       	movw	r22, r18
    600c:	0e 94 10 31 	call	0x6220	; 0x6220 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    6010:	eb 81       	ldd	r30, Y+3	; 0x03
    6012:	fc 81       	ldd	r31, Y+4	; 0x04
    6014:	82 8d       	ldd	r24, Z+26	; 0x1a
    6016:	81 50       	subi	r24, 0x01	; 1
    6018:	eb 81       	ldd	r30, Y+3	; 0x03
    601a:	fc 81       	ldd	r31, Y+4	; 0x04
    601c:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    601e:	eb 81       	ldd	r30, Y+3	; 0x03
    6020:	fc 81       	ldd	r31, Y+4	; 0x04
    6022:	85 8d       	ldd	r24, Z+29	; 0x1d
    6024:	8f 3f       	cpi	r24, 0xFF	; 255
    6026:	89 f4       	brne	.+34     	; 0x604a <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    6028:	eb 81       	ldd	r30, Y+3	; 0x03
    602a:	fc 81       	ldd	r31, Y+4	; 0x04
    602c:	80 85       	ldd	r24, Z+8	; 0x08
    602e:	88 23       	and	r24, r24
    6030:	99 f0       	breq	.+38     	; 0x6058 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    6032:	8b 81       	ldd	r24, Y+3	; 0x03
    6034:	9c 81       	ldd	r25, Y+4	; 0x04
    6036:	08 96       	adiw	r24, 0x08	; 8
    6038:	0e 94 02 38 	call	0x7004	; 0x7004 <xTaskRemoveFromEventList>
    603c:	88 23       	and	r24, r24
    603e:	61 f0       	breq	.+24     	; 0x6058 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    6040:	ef 81       	ldd	r30, Y+7	; 0x07
    6042:	f8 85       	ldd	r31, Y+8	; 0x08
    6044:	81 e0       	ldi	r24, 0x01	; 1
    6046:	80 83       	st	Z, r24
    6048:	07 c0       	rjmp	.+14     	; 0x6058 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    604a:	eb 81       	ldd	r30, Y+3	; 0x03
    604c:	fc 81       	ldd	r31, Y+4	; 0x04
    604e:	85 8d       	ldd	r24, Z+29	; 0x1d
    6050:	8f 5f       	subi	r24, 0xFF	; 255
    6052:	eb 81       	ldd	r30, Y+3	; 0x03
    6054:	fc 81       	ldd	r31, Y+4	; 0x04
    6056:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    6058:	81 e0       	ldi	r24, 0x01	; 1
    605a:	8a 83       	std	Y+2, r24	; 0x02
    605c:	01 c0       	rjmp	.+2      	; 0x6060 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    605e:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6060:	8a 81       	ldd	r24, Y+2	; 0x02
}
    6062:	28 96       	adiw	r28, 0x08	; 8
    6064:	0f b6       	in	r0, 0x3f	; 63
    6066:	f8 94       	cli
    6068:	de bf       	out	0x3e, r29	; 62
    606a:	0f be       	out	0x3f, r0	; 63
    606c:	cd bf       	out	0x3d, r28	; 61
    606e:	cf 91       	pop	r28
    6070:	df 91       	pop	r29
    6072:	08 95       	ret

00006074 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    6074:	df 93       	push	r29
    6076:	cf 93       	push	r28
    6078:	00 d0       	rcall	.+0      	; 0x607a <uxQueueMessagesWaiting+0x6>
    607a:	0f 92       	push	r0
    607c:	cd b7       	in	r28, 0x3d	; 61
    607e:	de b7       	in	r29, 0x3e	; 62
    6080:	9b 83       	std	Y+3, r25	; 0x03
    6082:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    6084:	0f b6       	in	r0, 0x3f	; 63
    6086:	f8 94       	cli
    6088:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    608a:	ea 81       	ldd	r30, Y+2	; 0x02
    608c:	fb 81       	ldd	r31, Y+3	; 0x03
    608e:	82 8d       	ldd	r24, Z+26	; 0x1a
    6090:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    6092:	0f 90       	pop	r0
    6094:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    6096:	89 81       	ldd	r24, Y+1	; 0x01
}
    6098:	0f 90       	pop	r0
    609a:	0f 90       	pop	r0
    609c:	0f 90       	pop	r0
    609e:	cf 91       	pop	r28
    60a0:	df 91       	pop	r29
    60a2:	08 95       	ret

000060a4 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    60a4:	df 93       	push	r29
    60a6:	cf 93       	push	r28
    60a8:	00 d0       	rcall	.+0      	; 0x60aa <uxQueueMessagesWaitingFromISR+0x6>
    60aa:	0f 92       	push	r0
    60ac:	cd b7       	in	r28, 0x3d	; 61
    60ae:	de b7       	in	r29, 0x3e	; 62
    60b0:	9b 83       	std	Y+3, r25	; 0x03
    60b2:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    60b4:	ea 81       	ldd	r30, Y+2	; 0x02
    60b6:	fb 81       	ldd	r31, Y+3	; 0x03
    60b8:	82 8d       	ldd	r24, Z+26	; 0x1a
    60ba:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    60bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    60be:	0f 90       	pop	r0
    60c0:	0f 90       	pop	r0
    60c2:	0f 90       	pop	r0
    60c4:	cf 91       	pop	r28
    60c6:	df 91       	pop	r29
    60c8:	08 95       	ret

000060ca <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    60ca:	df 93       	push	r29
    60cc:	cf 93       	push	r28
    60ce:	00 d0       	rcall	.+0      	; 0x60d0 <vQueueDelete+0x6>
    60d0:	cd b7       	in	r28, 0x3d	; 61
    60d2:	de b7       	in	r29, 0x3e	; 62
    60d4:	9a 83       	std	Y+2, r25	; 0x02
    60d6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    60d8:	e9 81       	ldd	r30, Y+1	; 0x01
    60da:	fa 81       	ldd	r31, Y+2	; 0x02
    60dc:	80 81       	ld	r24, Z
    60de:	91 81       	ldd	r25, Z+1	; 0x01
    60e0:	0e 94 45 29 	call	0x528a	; 0x528a <vPortFree>
	vPortFree( pxQueue );
    60e4:	89 81       	ldd	r24, Y+1	; 0x01
    60e6:	9a 81       	ldd	r25, Y+2	; 0x02
    60e8:	0e 94 45 29 	call	0x528a	; 0x528a <vPortFree>
}
    60ec:	0f 90       	pop	r0
    60ee:	0f 90       	pop	r0
    60f0:	cf 91       	pop	r28
    60f2:	df 91       	pop	r29
    60f4:	08 95       	ret

000060f6 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    60f6:	df 93       	push	r29
    60f8:	cf 93       	push	r28
    60fa:	00 d0       	rcall	.+0      	; 0x60fc <prvCopyDataToQueue+0x6>
    60fc:	00 d0       	rcall	.+0      	; 0x60fe <prvCopyDataToQueue+0x8>
    60fe:	0f 92       	push	r0
    6100:	cd b7       	in	r28, 0x3d	; 61
    6102:	de b7       	in	r29, 0x3e	; 62
    6104:	9a 83       	std	Y+2, r25	; 0x02
    6106:	89 83       	std	Y+1, r24	; 0x01
    6108:	7c 83       	std	Y+4, r23	; 0x04
    610a:	6b 83       	std	Y+3, r22	; 0x03
    610c:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    610e:	e9 81       	ldd	r30, Y+1	; 0x01
    6110:	fa 81       	ldd	r31, Y+2	; 0x02
    6112:	84 8d       	ldd	r24, Z+28	; 0x1c
    6114:	88 23       	and	r24, r24
    6116:	09 f4       	brne	.+2      	; 0x611a <prvCopyDataToQueue+0x24>
    6118:	74 c0       	rjmp	.+232    	; 0x6202 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    611a:	8d 81       	ldd	r24, Y+5	; 0x05
    611c:	88 23       	and	r24, r24
    611e:	99 f5       	brne	.+102    	; 0x6186 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    6120:	e9 81       	ldd	r30, Y+1	; 0x01
    6122:	fa 81       	ldd	r31, Y+2	; 0x02
    6124:	64 81       	ldd	r22, Z+4	; 0x04
    6126:	75 81       	ldd	r23, Z+5	; 0x05
    6128:	e9 81       	ldd	r30, Y+1	; 0x01
    612a:	fa 81       	ldd	r31, Y+2	; 0x02
    612c:	84 8d       	ldd	r24, Z+28	; 0x1c
    612e:	48 2f       	mov	r20, r24
    6130:	50 e0       	ldi	r21, 0x00	; 0
    6132:	2b 81       	ldd	r18, Y+3	; 0x03
    6134:	3c 81       	ldd	r19, Y+4	; 0x04
    6136:	cb 01       	movw	r24, r22
    6138:	b9 01       	movw	r22, r18
    613a:	0e 94 18 3b 	call	0x7630	; 0x7630 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    613e:	e9 81       	ldd	r30, Y+1	; 0x01
    6140:	fa 81       	ldd	r31, Y+2	; 0x02
    6142:	24 81       	ldd	r18, Z+4	; 0x04
    6144:	35 81       	ldd	r19, Z+5	; 0x05
    6146:	e9 81       	ldd	r30, Y+1	; 0x01
    6148:	fa 81       	ldd	r31, Y+2	; 0x02
    614a:	84 8d       	ldd	r24, Z+28	; 0x1c
    614c:	88 2f       	mov	r24, r24
    614e:	90 e0       	ldi	r25, 0x00	; 0
    6150:	82 0f       	add	r24, r18
    6152:	93 1f       	adc	r25, r19
    6154:	e9 81       	ldd	r30, Y+1	; 0x01
    6156:	fa 81       	ldd	r31, Y+2	; 0x02
    6158:	95 83       	std	Z+5, r25	; 0x05
    615a:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    615c:	e9 81       	ldd	r30, Y+1	; 0x01
    615e:	fa 81       	ldd	r31, Y+2	; 0x02
    6160:	24 81       	ldd	r18, Z+4	; 0x04
    6162:	35 81       	ldd	r19, Z+5	; 0x05
    6164:	e9 81       	ldd	r30, Y+1	; 0x01
    6166:	fa 81       	ldd	r31, Y+2	; 0x02
    6168:	82 81       	ldd	r24, Z+2	; 0x02
    616a:	93 81       	ldd	r25, Z+3	; 0x03
    616c:	28 17       	cp	r18, r24
    616e:	39 07       	cpc	r19, r25
    6170:	08 f4       	brcc	.+2      	; 0x6174 <prvCopyDataToQueue+0x7e>
    6172:	47 c0       	rjmp	.+142    	; 0x6202 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    6174:	e9 81       	ldd	r30, Y+1	; 0x01
    6176:	fa 81       	ldd	r31, Y+2	; 0x02
    6178:	80 81       	ld	r24, Z
    617a:	91 81       	ldd	r25, Z+1	; 0x01
    617c:	e9 81       	ldd	r30, Y+1	; 0x01
    617e:	fa 81       	ldd	r31, Y+2	; 0x02
    6180:	95 83       	std	Z+5, r25	; 0x05
    6182:	84 83       	std	Z+4, r24	; 0x04
    6184:	3e c0       	rjmp	.+124    	; 0x6202 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    6186:	e9 81       	ldd	r30, Y+1	; 0x01
    6188:	fa 81       	ldd	r31, Y+2	; 0x02
    618a:	66 81       	ldd	r22, Z+6	; 0x06
    618c:	77 81       	ldd	r23, Z+7	; 0x07
    618e:	e9 81       	ldd	r30, Y+1	; 0x01
    6190:	fa 81       	ldd	r31, Y+2	; 0x02
    6192:	84 8d       	ldd	r24, Z+28	; 0x1c
    6194:	48 2f       	mov	r20, r24
    6196:	50 e0       	ldi	r21, 0x00	; 0
    6198:	2b 81       	ldd	r18, Y+3	; 0x03
    619a:	3c 81       	ldd	r19, Y+4	; 0x04
    619c:	cb 01       	movw	r24, r22
    619e:	b9 01       	movw	r22, r18
    61a0:	0e 94 18 3b 	call	0x7630	; 0x7630 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    61a4:	e9 81       	ldd	r30, Y+1	; 0x01
    61a6:	fa 81       	ldd	r31, Y+2	; 0x02
    61a8:	26 81       	ldd	r18, Z+6	; 0x06
    61aa:	37 81       	ldd	r19, Z+7	; 0x07
    61ac:	e9 81       	ldd	r30, Y+1	; 0x01
    61ae:	fa 81       	ldd	r31, Y+2	; 0x02
    61b0:	84 8d       	ldd	r24, Z+28	; 0x1c
    61b2:	88 2f       	mov	r24, r24
    61b4:	90 e0       	ldi	r25, 0x00	; 0
    61b6:	90 95       	com	r25
    61b8:	81 95       	neg	r24
    61ba:	9f 4f       	sbci	r25, 0xFF	; 255
    61bc:	82 0f       	add	r24, r18
    61be:	93 1f       	adc	r25, r19
    61c0:	e9 81       	ldd	r30, Y+1	; 0x01
    61c2:	fa 81       	ldd	r31, Y+2	; 0x02
    61c4:	97 83       	std	Z+7, r25	; 0x07
    61c6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    61c8:	e9 81       	ldd	r30, Y+1	; 0x01
    61ca:	fa 81       	ldd	r31, Y+2	; 0x02
    61cc:	26 81       	ldd	r18, Z+6	; 0x06
    61ce:	37 81       	ldd	r19, Z+7	; 0x07
    61d0:	e9 81       	ldd	r30, Y+1	; 0x01
    61d2:	fa 81       	ldd	r31, Y+2	; 0x02
    61d4:	80 81       	ld	r24, Z
    61d6:	91 81       	ldd	r25, Z+1	; 0x01
    61d8:	28 17       	cp	r18, r24
    61da:	39 07       	cpc	r19, r25
    61dc:	90 f4       	brcc	.+36     	; 0x6202 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    61de:	e9 81       	ldd	r30, Y+1	; 0x01
    61e0:	fa 81       	ldd	r31, Y+2	; 0x02
    61e2:	22 81       	ldd	r18, Z+2	; 0x02
    61e4:	33 81       	ldd	r19, Z+3	; 0x03
    61e6:	e9 81       	ldd	r30, Y+1	; 0x01
    61e8:	fa 81       	ldd	r31, Y+2	; 0x02
    61ea:	84 8d       	ldd	r24, Z+28	; 0x1c
    61ec:	88 2f       	mov	r24, r24
    61ee:	90 e0       	ldi	r25, 0x00	; 0
    61f0:	90 95       	com	r25
    61f2:	81 95       	neg	r24
    61f4:	9f 4f       	sbci	r25, 0xFF	; 255
    61f6:	82 0f       	add	r24, r18
    61f8:	93 1f       	adc	r25, r19
    61fa:	e9 81       	ldd	r30, Y+1	; 0x01
    61fc:	fa 81       	ldd	r31, Y+2	; 0x02
    61fe:	97 83       	std	Z+7, r25	; 0x07
    6200:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    6202:	e9 81       	ldd	r30, Y+1	; 0x01
    6204:	fa 81       	ldd	r31, Y+2	; 0x02
    6206:	82 8d       	ldd	r24, Z+26	; 0x1a
    6208:	8f 5f       	subi	r24, 0xFF	; 255
    620a:	e9 81       	ldd	r30, Y+1	; 0x01
    620c:	fa 81       	ldd	r31, Y+2	; 0x02
    620e:	82 8f       	std	Z+26, r24	; 0x1a
}
    6210:	0f 90       	pop	r0
    6212:	0f 90       	pop	r0
    6214:	0f 90       	pop	r0
    6216:	0f 90       	pop	r0
    6218:	0f 90       	pop	r0
    621a:	cf 91       	pop	r28
    621c:	df 91       	pop	r29
    621e:	08 95       	ret

00006220 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    6220:	df 93       	push	r29
    6222:	cf 93       	push	r28
    6224:	00 d0       	rcall	.+0      	; 0x6226 <prvCopyDataFromQueue+0x6>
    6226:	00 d0       	rcall	.+0      	; 0x6228 <prvCopyDataFromQueue+0x8>
    6228:	cd b7       	in	r28, 0x3d	; 61
    622a:	de b7       	in	r29, 0x3e	; 62
    622c:	9a 83       	std	Y+2, r25	; 0x02
    622e:	89 83       	std	Y+1, r24	; 0x01
    6230:	7c 83       	std	Y+4, r23	; 0x04
    6232:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    6234:	e9 81       	ldd	r30, Y+1	; 0x01
    6236:	fa 81       	ldd	r31, Y+2	; 0x02
    6238:	80 81       	ld	r24, Z
    623a:	91 81       	ldd	r25, Z+1	; 0x01
    623c:	00 97       	sbiw	r24, 0x00	; 0
    623e:	89 f1       	breq	.+98     	; 0x62a2 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    6240:	e9 81       	ldd	r30, Y+1	; 0x01
    6242:	fa 81       	ldd	r31, Y+2	; 0x02
    6244:	26 81       	ldd	r18, Z+6	; 0x06
    6246:	37 81       	ldd	r19, Z+7	; 0x07
    6248:	e9 81       	ldd	r30, Y+1	; 0x01
    624a:	fa 81       	ldd	r31, Y+2	; 0x02
    624c:	84 8d       	ldd	r24, Z+28	; 0x1c
    624e:	88 2f       	mov	r24, r24
    6250:	90 e0       	ldi	r25, 0x00	; 0
    6252:	82 0f       	add	r24, r18
    6254:	93 1f       	adc	r25, r19
    6256:	e9 81       	ldd	r30, Y+1	; 0x01
    6258:	fa 81       	ldd	r31, Y+2	; 0x02
    625a:	97 83       	std	Z+7, r25	; 0x07
    625c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    625e:	e9 81       	ldd	r30, Y+1	; 0x01
    6260:	fa 81       	ldd	r31, Y+2	; 0x02
    6262:	26 81       	ldd	r18, Z+6	; 0x06
    6264:	37 81       	ldd	r19, Z+7	; 0x07
    6266:	e9 81       	ldd	r30, Y+1	; 0x01
    6268:	fa 81       	ldd	r31, Y+2	; 0x02
    626a:	82 81       	ldd	r24, Z+2	; 0x02
    626c:	93 81       	ldd	r25, Z+3	; 0x03
    626e:	28 17       	cp	r18, r24
    6270:	39 07       	cpc	r19, r25
    6272:	40 f0       	brcs	.+16     	; 0x6284 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    6274:	e9 81       	ldd	r30, Y+1	; 0x01
    6276:	fa 81       	ldd	r31, Y+2	; 0x02
    6278:	80 81       	ld	r24, Z
    627a:	91 81       	ldd	r25, Z+1	; 0x01
    627c:	e9 81       	ldd	r30, Y+1	; 0x01
    627e:	fa 81       	ldd	r31, Y+2	; 0x02
    6280:	97 83       	std	Z+7, r25	; 0x07
    6282:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    6284:	e9 81       	ldd	r30, Y+1	; 0x01
    6286:	fa 81       	ldd	r31, Y+2	; 0x02
    6288:	46 81       	ldd	r20, Z+6	; 0x06
    628a:	57 81       	ldd	r21, Z+7	; 0x07
    628c:	e9 81       	ldd	r30, Y+1	; 0x01
    628e:	fa 81       	ldd	r31, Y+2	; 0x02
    6290:	84 8d       	ldd	r24, Z+28	; 0x1c
    6292:	28 2f       	mov	r18, r24
    6294:	30 e0       	ldi	r19, 0x00	; 0
    6296:	8b 81       	ldd	r24, Y+3	; 0x03
    6298:	9c 81       	ldd	r25, Y+4	; 0x04
    629a:	ba 01       	movw	r22, r20
    629c:	a9 01       	movw	r20, r18
    629e:	0e 94 18 3b 	call	0x7630	; 0x7630 <memcpy>
	}
}
    62a2:	0f 90       	pop	r0
    62a4:	0f 90       	pop	r0
    62a6:	0f 90       	pop	r0
    62a8:	0f 90       	pop	r0
    62aa:	cf 91       	pop	r28
    62ac:	df 91       	pop	r29
    62ae:	08 95       	ret

000062b0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    62b0:	df 93       	push	r29
    62b2:	cf 93       	push	r28
    62b4:	00 d0       	rcall	.+0      	; 0x62b6 <prvUnlockQueue+0x6>
    62b6:	cd b7       	in	r28, 0x3d	; 61
    62b8:	de b7       	in	r29, 0x3e	; 62
    62ba:	9a 83       	std	Y+2, r25	; 0x02
    62bc:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    62be:	0f b6       	in	r0, 0x3f	; 63
    62c0:	f8 94       	cli
    62c2:	0f 92       	push	r0
    62c4:	15 c0       	rjmp	.+42     	; 0x62f0 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    62c6:	e9 81       	ldd	r30, Y+1	; 0x01
    62c8:	fa 81       	ldd	r31, Y+2	; 0x02
    62ca:	81 89       	ldd	r24, Z+17	; 0x11
    62cc:	88 23       	and	r24, r24
    62ce:	a9 f0       	breq	.+42     	; 0x62fa <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    62d0:	89 81       	ldd	r24, Y+1	; 0x01
    62d2:	9a 81       	ldd	r25, Y+2	; 0x02
    62d4:	41 96       	adiw	r24, 0x11	; 17
    62d6:	0e 94 02 38 	call	0x7004	; 0x7004 <xTaskRemoveFromEventList>
    62da:	88 23       	and	r24, r24
    62dc:	11 f0       	breq	.+4      	; 0x62e2 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    62de:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    62e2:	e9 81       	ldd	r30, Y+1	; 0x01
    62e4:	fa 81       	ldd	r31, Y+2	; 0x02
    62e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    62e8:	81 50       	subi	r24, 0x01	; 1
    62ea:	e9 81       	ldd	r30, Y+1	; 0x01
    62ec:	fa 81       	ldd	r31, Y+2	; 0x02
    62ee:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    62f0:	e9 81       	ldd	r30, Y+1	; 0x01
    62f2:	fa 81       	ldd	r31, Y+2	; 0x02
    62f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    62f6:	18 16       	cp	r1, r24
    62f8:	34 f3       	brlt	.-52     	; 0x62c6 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    62fa:	e9 81       	ldd	r30, Y+1	; 0x01
    62fc:	fa 81       	ldd	r31, Y+2	; 0x02
    62fe:	8f ef       	ldi	r24, 0xFF	; 255
    6300:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    6302:	0f 90       	pop	r0
    6304:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    6306:	0f b6       	in	r0, 0x3f	; 63
    6308:	f8 94       	cli
    630a:	0f 92       	push	r0
    630c:	15 c0       	rjmp	.+42     	; 0x6338 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    630e:	e9 81       	ldd	r30, Y+1	; 0x01
    6310:	fa 81       	ldd	r31, Y+2	; 0x02
    6312:	80 85       	ldd	r24, Z+8	; 0x08
    6314:	88 23       	and	r24, r24
    6316:	a9 f0       	breq	.+42     	; 0x6342 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    6318:	89 81       	ldd	r24, Y+1	; 0x01
    631a:	9a 81       	ldd	r25, Y+2	; 0x02
    631c:	08 96       	adiw	r24, 0x08	; 8
    631e:	0e 94 02 38 	call	0x7004	; 0x7004 <xTaskRemoveFromEventList>
    6322:	88 23       	and	r24, r24
    6324:	11 f0       	breq	.+4      	; 0x632a <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    6326:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    632a:	e9 81       	ldd	r30, Y+1	; 0x01
    632c:	fa 81       	ldd	r31, Y+2	; 0x02
    632e:	85 8d       	ldd	r24, Z+29	; 0x1d
    6330:	81 50       	subi	r24, 0x01	; 1
    6332:	e9 81       	ldd	r30, Y+1	; 0x01
    6334:	fa 81       	ldd	r31, Y+2	; 0x02
    6336:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    6338:	e9 81       	ldd	r30, Y+1	; 0x01
    633a:	fa 81       	ldd	r31, Y+2	; 0x02
    633c:	85 8d       	ldd	r24, Z+29	; 0x1d
    633e:	18 16       	cp	r1, r24
    6340:	34 f3       	brlt	.-52     	; 0x630e <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    6342:	e9 81       	ldd	r30, Y+1	; 0x01
    6344:	fa 81       	ldd	r31, Y+2	; 0x02
    6346:	8f ef       	ldi	r24, 0xFF	; 255
    6348:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    634a:	0f 90       	pop	r0
    634c:	0f be       	out	0x3f, r0	; 63
}
    634e:	0f 90       	pop	r0
    6350:	0f 90       	pop	r0
    6352:	cf 91       	pop	r28
    6354:	df 91       	pop	r29
    6356:	08 95       	ret

00006358 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    6358:	df 93       	push	r29
    635a:	cf 93       	push	r28
    635c:	00 d0       	rcall	.+0      	; 0x635e <prvIsQueueEmpty+0x6>
    635e:	0f 92       	push	r0
    6360:	cd b7       	in	r28, 0x3d	; 61
    6362:	de b7       	in	r29, 0x3e	; 62
    6364:	9b 83       	std	Y+3, r25	; 0x03
    6366:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    6368:	0f b6       	in	r0, 0x3f	; 63
    636a:	f8 94       	cli
    636c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    636e:	ea 81       	ldd	r30, Y+2	; 0x02
    6370:	fb 81       	ldd	r31, Y+3	; 0x03
    6372:	82 8d       	ldd	r24, Z+26	; 0x1a
    6374:	19 82       	std	Y+1, r1	; 0x01
    6376:	88 23       	and	r24, r24
    6378:	11 f4       	brne	.+4      	; 0x637e <prvIsQueueEmpty+0x26>
    637a:	81 e0       	ldi	r24, 0x01	; 1
    637c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    637e:	0f 90       	pop	r0
    6380:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    6382:	89 81       	ldd	r24, Y+1	; 0x01
}
    6384:	0f 90       	pop	r0
    6386:	0f 90       	pop	r0
    6388:	0f 90       	pop	r0
    638a:	cf 91       	pop	r28
    638c:	df 91       	pop	r29
    638e:	08 95       	ret

00006390 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    6390:	df 93       	push	r29
    6392:	cf 93       	push	r28
    6394:	00 d0       	rcall	.+0      	; 0x6396 <xQueueIsQueueEmptyFromISR+0x6>
    6396:	0f 92       	push	r0
    6398:	cd b7       	in	r28, 0x3d	; 61
    639a:	de b7       	in	r29, 0x3e	; 62
    639c:	9b 83       	std	Y+3, r25	; 0x03
    639e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    63a0:	ea 81       	ldd	r30, Y+2	; 0x02
    63a2:	fb 81       	ldd	r31, Y+3	; 0x03
    63a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    63a6:	19 82       	std	Y+1, r1	; 0x01
    63a8:	88 23       	and	r24, r24
    63aa:	11 f4       	brne	.+4      	; 0x63b0 <xQueueIsQueueEmptyFromISR+0x20>
    63ac:	81 e0       	ldi	r24, 0x01	; 1
    63ae:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    63b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    63b2:	0f 90       	pop	r0
    63b4:	0f 90       	pop	r0
    63b6:	0f 90       	pop	r0
    63b8:	cf 91       	pop	r28
    63ba:	df 91       	pop	r29
    63bc:	08 95       	ret

000063be <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    63be:	df 93       	push	r29
    63c0:	cf 93       	push	r28
    63c2:	00 d0       	rcall	.+0      	; 0x63c4 <prvIsQueueFull+0x6>
    63c4:	0f 92       	push	r0
    63c6:	cd b7       	in	r28, 0x3d	; 61
    63c8:	de b7       	in	r29, 0x3e	; 62
    63ca:	9b 83       	std	Y+3, r25	; 0x03
    63cc:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    63ce:	0f b6       	in	r0, 0x3f	; 63
    63d0:	f8 94       	cli
    63d2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    63d4:	ea 81       	ldd	r30, Y+2	; 0x02
    63d6:	fb 81       	ldd	r31, Y+3	; 0x03
    63d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    63da:	ea 81       	ldd	r30, Y+2	; 0x02
    63dc:	fb 81       	ldd	r31, Y+3	; 0x03
    63de:	83 8d       	ldd	r24, Z+27	; 0x1b
    63e0:	19 82       	std	Y+1, r1	; 0x01
    63e2:	98 17       	cp	r25, r24
    63e4:	11 f4       	brne	.+4      	; 0x63ea <prvIsQueueFull+0x2c>
    63e6:	81 e0       	ldi	r24, 0x01	; 1
    63e8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    63ea:	0f 90       	pop	r0
    63ec:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    63ee:	89 81       	ldd	r24, Y+1	; 0x01
}
    63f0:	0f 90       	pop	r0
    63f2:	0f 90       	pop	r0
    63f4:	0f 90       	pop	r0
    63f6:	cf 91       	pop	r28
    63f8:	df 91       	pop	r29
    63fa:	08 95       	ret

000063fc <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    63fc:	df 93       	push	r29
    63fe:	cf 93       	push	r28
    6400:	00 d0       	rcall	.+0      	; 0x6402 <xQueueIsQueueFullFromISR+0x6>
    6402:	0f 92       	push	r0
    6404:	cd b7       	in	r28, 0x3d	; 61
    6406:	de b7       	in	r29, 0x3e	; 62
    6408:	9b 83       	std	Y+3, r25	; 0x03
    640a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    640c:	ea 81       	ldd	r30, Y+2	; 0x02
    640e:	fb 81       	ldd	r31, Y+3	; 0x03
    6410:	92 8d       	ldd	r25, Z+26	; 0x1a
    6412:	ea 81       	ldd	r30, Y+2	; 0x02
    6414:	fb 81       	ldd	r31, Y+3	; 0x03
    6416:	83 8d       	ldd	r24, Z+27	; 0x1b
    6418:	19 82       	std	Y+1, r1	; 0x01
    641a:	98 17       	cp	r25, r24
    641c:	11 f4       	brne	.+4      	; 0x6422 <xQueueIsQueueFullFromISR+0x26>
    641e:	81 e0       	ldi	r24, 0x01	; 1
    6420:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    6422:	89 81       	ldd	r24, Y+1	; 0x01
}
    6424:	0f 90       	pop	r0
    6426:	0f 90       	pop	r0
    6428:	0f 90       	pop	r0
    642a:	cf 91       	pop	r28
    642c:	df 91       	pop	r29
    642e:	08 95       	ret

00006430 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    6430:	af 92       	push	r10
    6432:	bf 92       	push	r11
    6434:	cf 92       	push	r12
    6436:	df 92       	push	r13
    6438:	ef 92       	push	r14
    643a:	ff 92       	push	r15
    643c:	0f 93       	push	r16
    643e:	1f 93       	push	r17
    6440:	df 93       	push	r29
    6442:	cf 93       	push	r28
    6444:	cd b7       	in	r28, 0x3d	; 61
    6446:	de b7       	in	r29, 0x3e	; 62
    6448:	64 97       	sbiw	r28, 0x14	; 20
    644a:	0f b6       	in	r0, 0x3f	; 63
    644c:	f8 94       	cli
    644e:	de bf       	out	0x3e, r29	; 62
    6450:	0f be       	out	0x3f, r0	; 63
    6452:	cd bf       	out	0x3d, r28	; 61
    6454:	9f 83       	std	Y+7, r25	; 0x07
    6456:	8e 83       	std	Y+6, r24	; 0x06
    6458:	79 87       	std	Y+9, r23	; 0x09
    645a:	68 87       	std	Y+8, r22	; 0x08
    645c:	5b 87       	std	Y+11, r21	; 0x0b
    645e:	4a 87       	std	Y+10, r20	; 0x0a
    6460:	3d 87       	std	Y+13, r19	; 0x0d
    6462:	2c 87       	std	Y+12, r18	; 0x0c
    6464:	0e 87       	std	Y+14, r16	; 0x0e
    6466:	f8 8a       	std	Y+16, r15	; 0x10
    6468:	ef 86       	std	Y+15, r14	; 0x0f
    646a:	da 8a       	std	Y+18, r13	; 0x12
    646c:	c9 8a       	std	Y+17, r12	; 0x11
    646e:	bc 8a       	std	Y+20, r11	; 0x14
    6470:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    6472:	8a 85       	ldd	r24, Y+10	; 0x0a
    6474:	9b 85       	ldd	r25, Y+11	; 0x0b
    6476:	29 89       	ldd	r18, Y+17	; 0x11
    6478:	3a 89       	ldd	r19, Y+18	; 0x12
    647a:	b9 01       	movw	r22, r18
    647c:	0e 94 1d 3a 	call	0x743a	; 0x743a <prvAllocateTCBAndStack>
    6480:	9c 83       	std	Y+4, r25	; 0x04
    6482:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    6484:	8b 81       	ldd	r24, Y+3	; 0x03
    6486:	9c 81       	ldd	r25, Y+4	; 0x04
    6488:	00 97       	sbiw	r24, 0x00	; 0
    648a:	09 f4       	brne	.+2      	; 0x648e <xTaskGenericCreate+0x5e>
    648c:	99 c0       	rjmp	.+306    	; 0x65c0 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    648e:	eb 81       	ldd	r30, Y+3	; 0x03
    6490:	fc 81       	ldd	r31, Y+4	; 0x04
    6492:	27 89       	ldd	r18, Z+23	; 0x17
    6494:	30 8d       	ldd	r19, Z+24	; 0x18
    6496:	8a 85       	ldd	r24, Y+10	; 0x0a
    6498:	9b 85       	ldd	r25, Y+11	; 0x0b
    649a:	01 97       	sbiw	r24, 0x01	; 1
    649c:	82 0f       	add	r24, r18
    649e:	93 1f       	adc	r25, r19
    64a0:	9a 83       	std	Y+2, r25	; 0x02
    64a2:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    64a4:	8b 81       	ldd	r24, Y+3	; 0x03
    64a6:	9c 81       	ldd	r25, Y+4	; 0x04
    64a8:	28 85       	ldd	r18, Y+8	; 0x08
    64aa:	39 85       	ldd	r19, Y+9	; 0x09
    64ac:	eb 89       	ldd	r30, Y+19	; 0x13
    64ae:	fc 89       	ldd	r31, Y+20	; 0x14
    64b0:	aa 85       	ldd	r26, Y+10	; 0x0a
    64b2:	bb 85       	ldd	r27, Y+11	; 0x0b
    64b4:	b9 01       	movw	r22, r18
    64b6:	4e 85       	ldd	r20, Y+14	; 0x0e
    64b8:	9f 01       	movw	r18, r30
    64ba:	8d 01       	movw	r16, r26
    64bc:	0e 94 fe 38 	call	0x71fc	; 0x71fc <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    64c0:	89 81       	ldd	r24, Y+1	; 0x01
    64c2:	9a 81       	ldd	r25, Y+2	; 0x02
    64c4:	2e 81       	ldd	r18, Y+6	; 0x06
    64c6:	3f 81       	ldd	r19, Y+7	; 0x07
    64c8:	4c 85       	ldd	r20, Y+12	; 0x0c
    64ca:	5d 85       	ldd	r21, Y+13	; 0x0d
    64cc:	b9 01       	movw	r22, r18
    64ce:	0e 94 a6 2a 	call	0x554c	; 0x554c <pxPortInitialiseStack>
    64d2:	eb 81       	ldd	r30, Y+3	; 0x03
    64d4:	fc 81       	ldd	r31, Y+4	; 0x04
    64d6:	91 83       	std	Z+1, r25	; 0x01
    64d8:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    64da:	8f 85       	ldd	r24, Y+15	; 0x0f
    64dc:	98 89       	ldd	r25, Y+16	; 0x10
    64de:	00 97       	sbiw	r24, 0x00	; 0
    64e0:	31 f0       	breq	.+12     	; 0x64ee <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    64e2:	ef 85       	ldd	r30, Y+15	; 0x0f
    64e4:	f8 89       	ldd	r31, Y+16	; 0x10
    64e6:	8b 81       	ldd	r24, Y+3	; 0x03
    64e8:	9c 81       	ldd	r25, Y+4	; 0x04
    64ea:	91 83       	std	Z+1, r25	; 0x01
    64ec:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    64ee:	0f b6       	in	r0, 0x3f	; 63
    64f0:	f8 94       	cli
    64f2:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    64f4:	80 91 e5 07 	lds	r24, 0x07E5
    64f8:	8f 5f       	subi	r24, 0xFF	; 255
    64fa:	80 93 e5 07 	sts	0x07E5, r24
			if( pxCurrentTCB == NULL )
    64fe:	80 91 e2 07 	lds	r24, 0x07E2
    6502:	90 91 e3 07 	lds	r25, 0x07E3
    6506:	00 97       	sbiw	r24, 0x00	; 0
    6508:	69 f4       	brne	.+26     	; 0x6524 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    650a:	8b 81       	ldd	r24, Y+3	; 0x03
    650c:	9c 81       	ldd	r25, Y+4	; 0x04
    650e:	90 93 e3 07 	sts	0x07E3, r25
    6512:	80 93 e2 07 	sts	0x07E2, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    6516:	80 91 e5 07 	lds	r24, 0x07E5
    651a:	81 30       	cpi	r24, 0x01	; 1
    651c:	a9 f4       	brne	.+42     	; 0x6548 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    651e:	0e 94 55 39 	call	0x72aa	; 0x72aa <prvInitialiseTaskLists>
    6522:	12 c0       	rjmp	.+36     	; 0x6548 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    6524:	80 91 ea 07 	lds	r24, 0x07EA
    6528:	88 23       	and	r24, r24
    652a:	71 f4       	brne	.+28     	; 0x6548 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    652c:	e0 91 e2 07 	lds	r30, 0x07E2
    6530:	f0 91 e3 07 	lds	r31, 0x07E3
    6534:	96 89       	ldd	r25, Z+22	; 0x16
    6536:	8e 85       	ldd	r24, Y+14	; 0x0e
    6538:	89 17       	cp	r24, r25
    653a:	30 f0       	brcs	.+12     	; 0x6548 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    653c:	8b 81       	ldd	r24, Y+3	; 0x03
    653e:	9c 81       	ldd	r25, Y+4	; 0x04
    6540:	90 93 e3 07 	sts	0x07E3, r25
    6544:	80 93 e2 07 	sts	0x07E2, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    6548:	eb 81       	ldd	r30, Y+3	; 0x03
    654a:	fc 81       	ldd	r31, Y+4	; 0x04
    654c:	96 89       	ldd	r25, Z+22	; 0x16
    654e:	80 91 e8 07 	lds	r24, 0x07E8
    6552:	89 17       	cp	r24, r25
    6554:	28 f4       	brcc	.+10     	; 0x6560 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    6556:	eb 81       	ldd	r30, Y+3	; 0x03
    6558:	fc 81       	ldd	r31, Y+4	; 0x04
    655a:	86 89       	ldd	r24, Z+22	; 0x16
    655c:	80 93 e8 07 	sts	0x07E8, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    6560:	80 91 ef 07 	lds	r24, 0x07EF
    6564:	8f 5f       	subi	r24, 0xFF	; 255
    6566:	80 93 ef 07 	sts	0x07EF, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    656a:	eb 81       	ldd	r30, Y+3	; 0x03
    656c:	fc 81       	ldd	r31, Y+4	; 0x04
    656e:	96 89       	ldd	r25, Z+22	; 0x16
    6570:	80 91 e9 07 	lds	r24, 0x07E9
    6574:	89 17       	cp	r24, r25
    6576:	28 f4       	brcc	.+10     	; 0x6582 <xTaskGenericCreate+0x152>
    6578:	eb 81       	ldd	r30, Y+3	; 0x03
    657a:	fc 81       	ldd	r31, Y+4	; 0x04
    657c:	86 89       	ldd	r24, Z+22	; 0x16
    657e:	80 93 e9 07 	sts	0x07E9, r24
    6582:	eb 81       	ldd	r30, Y+3	; 0x03
    6584:	fc 81       	ldd	r31, Y+4	; 0x04
    6586:	86 89       	ldd	r24, Z+22	; 0x16
    6588:	28 2f       	mov	r18, r24
    658a:	30 e0       	ldi	r19, 0x00	; 0
    658c:	c9 01       	movw	r24, r18
    658e:	88 0f       	add	r24, r24
    6590:	99 1f       	adc	r25, r25
    6592:	88 0f       	add	r24, r24
    6594:	99 1f       	adc	r25, r25
    6596:	88 0f       	add	r24, r24
    6598:	99 1f       	adc	r25, r25
    659a:	82 0f       	add	r24, r18
    659c:	93 1f       	adc	r25, r19
    659e:	ac 01       	movw	r20, r24
    65a0:	40 51       	subi	r20, 0x10	; 16
    65a2:	58 4f       	sbci	r21, 0xF8	; 248
    65a4:	8b 81       	ldd	r24, Y+3	; 0x03
    65a6:	9c 81       	ldd	r25, Y+4	; 0x04
    65a8:	9c 01       	movw	r18, r24
    65aa:	2e 5f       	subi	r18, 0xFE	; 254
    65ac:	3f 4f       	sbci	r19, 0xFF	; 255
    65ae:	ca 01       	movw	r24, r20
    65b0:	b9 01       	movw	r22, r18
    65b2:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>

			xReturn = pdPASS;
    65b6:	81 e0       	ldi	r24, 0x01	; 1
    65b8:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    65ba:	0f 90       	pop	r0
    65bc:	0f be       	out	0x3f, r0	; 63
    65be:	02 c0       	rjmp	.+4      	; 0x65c4 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    65c0:	8f ef       	ldi	r24, 0xFF	; 255
    65c2:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    65c4:	8d 81       	ldd	r24, Y+5	; 0x05
    65c6:	81 30       	cpi	r24, 0x01	; 1
    65c8:	71 f4       	brne	.+28     	; 0x65e6 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    65ca:	80 91 ea 07 	lds	r24, 0x07EA
    65ce:	88 23       	and	r24, r24
    65d0:	51 f0       	breq	.+20     	; 0x65e6 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    65d2:	e0 91 e2 07 	lds	r30, 0x07E2
    65d6:	f0 91 e3 07 	lds	r31, 0x07E3
    65da:	96 89       	ldd	r25, Z+22	; 0x16
    65dc:	8e 85       	ldd	r24, Y+14	; 0x0e
    65de:	98 17       	cp	r25, r24
    65e0:	10 f4       	brcc	.+4      	; 0x65e6 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    65e2:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
			}
		}
	}

	return xReturn;
    65e6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    65e8:	64 96       	adiw	r28, 0x14	; 20
    65ea:	0f b6       	in	r0, 0x3f	; 63
    65ec:	f8 94       	cli
    65ee:	de bf       	out	0x3e, r29	; 62
    65f0:	0f be       	out	0x3f, r0	; 63
    65f2:	cd bf       	out	0x3d, r28	; 61
    65f4:	cf 91       	pop	r28
    65f6:	df 91       	pop	r29
    65f8:	1f 91       	pop	r17
    65fa:	0f 91       	pop	r16
    65fc:	ff 90       	pop	r15
    65fe:	ef 90       	pop	r14
    6600:	df 90       	pop	r13
    6602:	cf 90       	pop	r12
    6604:	bf 90       	pop	r11
    6606:	af 90       	pop	r10
    6608:	08 95       	ret

0000660a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    660a:	df 93       	push	r29
    660c:	cf 93       	push	r28
    660e:	00 d0       	rcall	.+0      	; 0x6610 <vTaskDelete+0x6>
    6610:	00 d0       	rcall	.+0      	; 0x6612 <vTaskDelete+0x8>
    6612:	00 d0       	rcall	.+0      	; 0x6614 <vTaskDelete+0xa>
    6614:	cd b7       	in	r28, 0x3d	; 61
    6616:	de b7       	in	r29, 0x3e	; 62
    6618:	9c 83       	std	Y+4, r25	; 0x04
    661a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    661c:	0f b6       	in	r0, 0x3f	; 63
    661e:	f8 94       	cli
    6620:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    6622:	20 91 e2 07 	lds	r18, 0x07E2
    6626:	30 91 e3 07 	lds	r19, 0x07E3
    662a:	8b 81       	ldd	r24, Y+3	; 0x03
    662c:	9c 81       	ldd	r25, Y+4	; 0x04
    662e:	82 17       	cp	r24, r18
    6630:	93 07       	cpc	r25, r19
    6632:	11 f4       	brne	.+4      	; 0x6638 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    6634:	1c 82       	std	Y+4, r1	; 0x04
    6636:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    6638:	8b 81       	ldd	r24, Y+3	; 0x03
    663a:	9c 81       	ldd	r25, Y+4	; 0x04
    663c:	00 97       	sbiw	r24, 0x00	; 0
    663e:	39 f4       	brne	.+14     	; 0x664e <vTaskDelete+0x44>
    6640:	80 91 e2 07 	lds	r24, 0x07E2
    6644:	90 91 e3 07 	lds	r25, 0x07E3
    6648:	9e 83       	std	Y+6, r25	; 0x06
    664a:	8d 83       	std	Y+5, r24	; 0x05
    664c:	04 c0       	rjmp	.+8      	; 0x6656 <vTaskDelete+0x4c>
    664e:	8b 81       	ldd	r24, Y+3	; 0x03
    6650:	9c 81       	ldd	r25, Y+4	; 0x04
    6652:	9e 83       	std	Y+6, r25	; 0x06
    6654:	8d 83       	std	Y+5, r24	; 0x05
    6656:	8d 81       	ldd	r24, Y+5	; 0x05
    6658:	9e 81       	ldd	r25, Y+6	; 0x06
    665a:	9a 83       	std	Y+2, r25	; 0x02
    665c:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    665e:	89 81       	ldd	r24, Y+1	; 0x01
    6660:	9a 81       	ldd	r25, Y+2	; 0x02
    6662:	02 96       	adiw	r24, 0x02	; 2
    6664:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    6668:	e9 81       	ldd	r30, Y+1	; 0x01
    666a:	fa 81       	ldd	r31, Y+2	; 0x02
    666c:	84 89       	ldd	r24, Z+20	; 0x14
    666e:	95 89       	ldd	r25, Z+21	; 0x15
    6670:	00 97       	sbiw	r24, 0x00	; 0
    6672:	29 f0       	breq	.+10     	; 0x667e <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    6674:	89 81       	ldd	r24, Y+1	; 0x01
    6676:	9a 81       	ldd	r25, Y+2	; 0x02
    6678:	0c 96       	adiw	r24, 0x0c	; 12
    667a:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    667e:	89 81       	ldd	r24, Y+1	; 0x01
    6680:	9a 81       	ldd	r25, Y+2	; 0x02
    6682:	9c 01       	movw	r18, r24
    6684:	2e 5f       	subi	r18, 0xFE	; 254
    6686:	3f 4f       	sbci	r19, 0xFF	; 255
    6688:	85 e4       	ldi	r24, 0x45	; 69
    668a:	98 e0       	ldi	r25, 0x08	; 8
    668c:	b9 01       	movw	r22, r18
    668e:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    6692:	80 91 e4 07 	lds	r24, 0x07E4
    6696:	8f 5f       	subi	r24, 0xFF	; 255
    6698:	80 93 e4 07 	sts	0x07E4, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    669c:	80 91 ef 07 	lds	r24, 0x07EF
    66a0:	8f 5f       	subi	r24, 0xFF	; 255
    66a2:	80 93 ef 07 	sts	0x07EF, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    66a6:	0f 90       	pop	r0
    66a8:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    66aa:	80 91 ea 07 	lds	r24, 0x07EA
    66ae:	88 23       	and	r24, r24
    66b0:	31 f0       	breq	.+12     	; 0x66be <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    66b2:	8b 81       	ldd	r24, Y+3	; 0x03
    66b4:	9c 81       	ldd	r25, Y+4	; 0x04
    66b6:	00 97       	sbiw	r24, 0x00	; 0
    66b8:	11 f4       	brne	.+4      	; 0x66be <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    66ba:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
			}
		}
	}
    66be:	26 96       	adiw	r28, 0x06	; 6
    66c0:	0f b6       	in	r0, 0x3f	; 63
    66c2:	f8 94       	cli
    66c4:	de bf       	out	0x3e, r29	; 62
    66c6:	0f be       	out	0x3f, r0	; 63
    66c8:	cd bf       	out	0x3d, r28	; 61
    66ca:	cf 91       	pop	r28
    66cc:	df 91       	pop	r29
    66ce:	08 95       	ret

000066d0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    66d0:	df 93       	push	r29
    66d2:	cf 93       	push	r28
    66d4:	cd b7       	in	r28, 0x3d	; 61
    66d6:	de b7       	in	r29, 0x3e	; 62
    66d8:	28 97       	sbiw	r28, 0x08	; 8
    66da:	0f b6       	in	r0, 0x3f	; 63
    66dc:	f8 94       	cli
    66de:	de bf       	out	0x3e, r29	; 62
    66e0:	0f be       	out	0x3f, r0	; 63
    66e2:	cd bf       	out	0x3d, r28	; 61
    66e4:	9e 83       	std	Y+6, r25	; 0x06
    66e6:	8d 83       	std	Y+5, r24	; 0x05
    66e8:	78 87       	std	Y+8, r23	; 0x08
    66ea:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    66ec:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    66ee:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    66f2:	ed 81       	ldd	r30, Y+5	; 0x05
    66f4:	fe 81       	ldd	r31, Y+6	; 0x06
    66f6:	20 81       	ld	r18, Z
    66f8:	31 81       	ldd	r19, Z+1	; 0x01
    66fa:	8f 81       	ldd	r24, Y+7	; 0x07
    66fc:	98 85       	ldd	r25, Y+8	; 0x08
    66fe:	82 0f       	add	r24, r18
    6700:	93 1f       	adc	r25, r19
    6702:	9c 83       	std	Y+4, r25	; 0x04
    6704:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    6706:	ed 81       	ldd	r30, Y+5	; 0x05
    6708:	fe 81       	ldd	r31, Y+6	; 0x06
    670a:	20 81       	ld	r18, Z
    670c:	31 81       	ldd	r19, Z+1	; 0x01
    670e:	80 91 e6 07 	lds	r24, 0x07E6
    6712:	90 91 e7 07 	lds	r25, 0x07E7
    6716:	82 17       	cp	r24, r18
    6718:	93 07       	cpc	r25, r19
    671a:	a8 f4       	brcc	.+42     	; 0x6746 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    671c:	ed 81       	ldd	r30, Y+5	; 0x05
    671e:	fe 81       	ldd	r31, Y+6	; 0x06
    6720:	20 81       	ld	r18, Z
    6722:	31 81       	ldd	r19, Z+1	; 0x01
    6724:	8b 81       	ldd	r24, Y+3	; 0x03
    6726:	9c 81       	ldd	r25, Y+4	; 0x04
    6728:	82 17       	cp	r24, r18
    672a:	93 07       	cpc	r25, r19
    672c:	00 f5       	brcc	.+64     	; 0x676e <vTaskDelayUntil+0x9e>
    672e:	20 91 e6 07 	lds	r18, 0x07E6
    6732:	30 91 e7 07 	lds	r19, 0x07E7
    6736:	8b 81       	ldd	r24, Y+3	; 0x03
    6738:	9c 81       	ldd	r25, Y+4	; 0x04
    673a:	28 17       	cp	r18, r24
    673c:	39 07       	cpc	r19, r25
    673e:	b8 f4       	brcc	.+46     	; 0x676e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    6740:	81 e0       	ldi	r24, 0x01	; 1
    6742:	89 83       	std	Y+1, r24	; 0x01
    6744:	14 c0       	rjmp	.+40     	; 0x676e <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    6746:	ed 81       	ldd	r30, Y+5	; 0x05
    6748:	fe 81       	ldd	r31, Y+6	; 0x06
    674a:	20 81       	ld	r18, Z
    674c:	31 81       	ldd	r19, Z+1	; 0x01
    674e:	8b 81       	ldd	r24, Y+3	; 0x03
    6750:	9c 81       	ldd	r25, Y+4	; 0x04
    6752:	82 17       	cp	r24, r18
    6754:	93 07       	cpc	r25, r19
    6756:	48 f0       	brcs	.+18     	; 0x676a <vTaskDelayUntil+0x9a>
    6758:	20 91 e6 07 	lds	r18, 0x07E6
    675c:	30 91 e7 07 	lds	r19, 0x07E7
    6760:	8b 81       	ldd	r24, Y+3	; 0x03
    6762:	9c 81       	ldd	r25, Y+4	; 0x04
    6764:	28 17       	cp	r18, r24
    6766:	39 07       	cpc	r19, r25
    6768:	10 f4       	brcc	.+4      	; 0x676e <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    676a:	81 e0       	ldi	r24, 0x01	; 1
    676c:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    676e:	ed 81       	ldd	r30, Y+5	; 0x05
    6770:	fe 81       	ldd	r31, Y+6	; 0x06
    6772:	8b 81       	ldd	r24, Y+3	; 0x03
    6774:	9c 81       	ldd	r25, Y+4	; 0x04
    6776:	91 83       	std	Z+1, r25	; 0x01
    6778:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    677a:	89 81       	ldd	r24, Y+1	; 0x01
    677c:	88 23       	and	r24, r24
    677e:	59 f0       	breq	.+22     	; 0x6796 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    6780:	80 91 e2 07 	lds	r24, 0x07E2
    6784:	90 91 e3 07 	lds	r25, 0x07E3
    6788:	02 96       	adiw	r24, 0x02	; 2
    678a:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    678e:	8b 81       	ldd	r24, Y+3	; 0x03
    6790:	9c 81       	ldd	r25, Y+4	; 0x04
    6792:	0e 94 d4 39 	call	0x73a8	; 0x73a8 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    6796:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>
    679a:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    679c:	8a 81       	ldd	r24, Y+2	; 0x02
    679e:	88 23       	and	r24, r24
    67a0:	11 f4       	brne	.+4      	; 0x67a6 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    67a2:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
		}
	}
    67a6:	28 96       	adiw	r28, 0x08	; 8
    67a8:	0f b6       	in	r0, 0x3f	; 63
    67aa:	f8 94       	cli
    67ac:	de bf       	out	0x3e, r29	; 62
    67ae:	0f be       	out	0x3f, r0	; 63
    67b0:	cd bf       	out	0x3d, r28	; 61
    67b2:	cf 91       	pop	r28
    67b4:	df 91       	pop	r29
    67b6:	08 95       	ret

000067b8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    67b8:	df 93       	push	r29
    67ba:	cf 93       	push	r28
    67bc:	00 d0       	rcall	.+0      	; 0x67be <vTaskDelay+0x6>
    67be:	00 d0       	rcall	.+0      	; 0x67c0 <vTaskDelay+0x8>
    67c0:	0f 92       	push	r0
    67c2:	cd b7       	in	r28, 0x3d	; 61
    67c4:	de b7       	in	r29, 0x3e	; 62
    67c6:	9d 83       	std	Y+5, r25	; 0x05
    67c8:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    67ca:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    67cc:	8c 81       	ldd	r24, Y+4	; 0x04
    67ce:	9d 81       	ldd	r25, Y+5	; 0x05
    67d0:	00 97       	sbiw	r24, 0x00	; 0
    67d2:	d1 f0       	breq	.+52     	; 0x6808 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    67d4:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    67d8:	20 91 e6 07 	lds	r18, 0x07E6
    67dc:	30 91 e7 07 	lds	r19, 0x07E7
    67e0:	8c 81       	ldd	r24, Y+4	; 0x04
    67e2:	9d 81       	ldd	r25, Y+5	; 0x05
    67e4:	82 0f       	add	r24, r18
    67e6:	93 1f       	adc	r25, r19
    67e8:	9b 83       	std	Y+3, r25	; 0x03
    67ea:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    67ec:	80 91 e2 07 	lds	r24, 0x07E2
    67f0:	90 91 e3 07 	lds	r25, 0x07E3
    67f4:	02 96       	adiw	r24, 0x02	; 2
    67f6:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    67fa:	8a 81       	ldd	r24, Y+2	; 0x02
    67fc:	9b 81       	ldd	r25, Y+3	; 0x03
    67fe:	0e 94 d4 39 	call	0x73a8	; 0x73a8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    6802:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>
    6806:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    6808:	89 81       	ldd	r24, Y+1	; 0x01
    680a:	88 23       	and	r24, r24
    680c:	11 f4       	brne	.+4      	; 0x6812 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    680e:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
		}
	}
    6812:	0f 90       	pop	r0
    6814:	0f 90       	pop	r0
    6816:	0f 90       	pop	r0
    6818:	0f 90       	pop	r0
    681a:	0f 90       	pop	r0
    681c:	cf 91       	pop	r28
    681e:	df 91       	pop	r29
    6820:	08 95       	ret

00006822 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    6822:	df 93       	push	r29
    6824:	cf 93       	push	r28
    6826:	00 d0       	rcall	.+0      	; 0x6828 <vTaskSuspend+0x6>
    6828:	00 d0       	rcall	.+0      	; 0x682a <vTaskSuspend+0x8>
    682a:	00 d0       	rcall	.+0      	; 0x682c <vTaskSuspend+0xa>
    682c:	cd b7       	in	r28, 0x3d	; 61
    682e:	de b7       	in	r29, 0x3e	; 62
    6830:	9c 83       	std	Y+4, r25	; 0x04
    6832:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    6834:	0f b6       	in	r0, 0x3f	; 63
    6836:	f8 94       	cli
    6838:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    683a:	20 91 e2 07 	lds	r18, 0x07E2
    683e:	30 91 e3 07 	lds	r19, 0x07E3
    6842:	8b 81       	ldd	r24, Y+3	; 0x03
    6844:	9c 81       	ldd	r25, Y+4	; 0x04
    6846:	82 17       	cp	r24, r18
    6848:	93 07       	cpc	r25, r19
    684a:	11 f4       	brne	.+4      	; 0x6850 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
    684c:	1c 82       	std	Y+4, r1	; 0x04
    684e:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    6850:	8b 81       	ldd	r24, Y+3	; 0x03
    6852:	9c 81       	ldd	r25, Y+4	; 0x04
    6854:	00 97       	sbiw	r24, 0x00	; 0
    6856:	39 f4       	brne	.+14     	; 0x6866 <vTaskSuspend+0x44>
    6858:	80 91 e2 07 	lds	r24, 0x07E2
    685c:	90 91 e3 07 	lds	r25, 0x07E3
    6860:	9e 83       	std	Y+6, r25	; 0x06
    6862:	8d 83       	std	Y+5, r24	; 0x05
    6864:	04 c0       	rjmp	.+8      	; 0x686e <vTaskSuspend+0x4c>
    6866:	8b 81       	ldd	r24, Y+3	; 0x03
    6868:	9c 81       	ldd	r25, Y+4	; 0x04
    686a:	9e 83       	std	Y+6, r25	; 0x06
    686c:	8d 83       	std	Y+5, r24	; 0x05
    686e:	8d 81       	ldd	r24, Y+5	; 0x05
    6870:	9e 81       	ldd	r25, Y+6	; 0x06
    6872:	9a 83       	std	Y+2, r25	; 0x02
    6874:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    6876:	89 81       	ldd	r24, Y+1	; 0x01
    6878:	9a 81       	ldd	r25, Y+2	; 0x02
    687a:	02 96       	adiw	r24, 0x02	; 2
    687c:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    6880:	e9 81       	ldd	r30, Y+1	; 0x01
    6882:	fa 81       	ldd	r31, Y+2	; 0x02
    6884:	84 89       	ldd	r24, Z+20	; 0x14
    6886:	95 89       	ldd	r25, Z+21	; 0x15
    6888:	00 97       	sbiw	r24, 0x00	; 0
    688a:	29 f0       	breq	.+10     	; 0x6896 <vTaskSuspend+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    688c:	89 81       	ldd	r24, Y+1	; 0x01
    688e:	9a 81       	ldd	r25, Y+2	; 0x02
    6890:	0c 96       	adiw	r24, 0x0c	; 12
    6892:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    6896:	89 81       	ldd	r24, Y+1	; 0x01
    6898:	9a 81       	ldd	r25, Y+2	; 0x02
    689a:	9c 01       	movw	r18, r24
    689c:	2e 5f       	subi	r18, 0xFE	; 254
    689e:	3f 4f       	sbci	r19, 0xFF	; 255
    68a0:	8e e4       	ldi	r24, 0x4E	; 78
    68a2:	98 e0       	ldi	r25, 0x08	; 8
    68a4:	b9 01       	movw	r22, r18
    68a6:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    68aa:	0f 90       	pop	r0
    68ac:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    68ae:	8b 81       	ldd	r24, Y+3	; 0x03
    68b0:	9c 81       	ldd	r25, Y+4	; 0x04
    68b2:	00 97       	sbiw	r24, 0x00	; 0
    68b4:	a1 f4       	brne	.+40     	; 0x68de <vTaskSuspend+0xbc>
		{
			if( xSchedulerRunning != pdFALSE )
    68b6:	80 91 ea 07 	lds	r24, 0x07EA
    68ba:	88 23       	and	r24, r24
    68bc:	19 f0       	breq	.+6      	; 0x68c4 <vTaskSuspend+0xa2>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    68be:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
    68c2:	0d c0       	rjmp	.+26     	; 0x68de <vTaskSuspend+0xbc>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    68c4:	90 91 4e 08 	lds	r25, 0x084E
    68c8:	80 91 e5 07 	lds	r24, 0x07E5
    68cc:	98 17       	cp	r25, r24
    68ce:	29 f4       	brne	.+10     	; 0x68da <vTaskSuspend+0xb8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    68d0:	10 92 e3 07 	sts	0x07E3, r1
    68d4:	10 92 e2 07 	sts	0x07E2, r1
    68d8:	02 c0       	rjmp	.+4      	; 0x68de <vTaskSuspend+0xbc>
				}
				else
				{
					vTaskSwitchContext();
    68da:	0e 94 53 37 	call	0x6ea6	; 0x6ea6 <vTaskSwitchContext>
				}
			}
		}
	}
    68de:	26 96       	adiw	r28, 0x06	; 6
    68e0:	0f b6       	in	r0, 0x3f	; 63
    68e2:	f8 94       	cli
    68e4:	de bf       	out	0x3e, r29	; 62
    68e6:	0f be       	out	0x3f, r0	; 63
    68e8:	cd bf       	out	0x3d, r28	; 61
    68ea:	cf 91       	pop	r28
    68ec:	df 91       	pop	r29
    68ee:	08 95       	ret

000068f0 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    68f0:	df 93       	push	r29
    68f2:	cf 93       	push	r28
    68f4:	00 d0       	rcall	.+0      	; 0x68f6 <xTaskIsTaskSuspended+0x6>
    68f6:	00 d0       	rcall	.+0      	; 0x68f8 <xTaskIsTaskSuspended+0x8>
    68f8:	0f 92       	push	r0
    68fa:	cd b7       	in	r28, 0x3d	; 61
    68fc:	de b7       	in	r29, 0x3e	; 62
    68fe:	9d 83       	std	Y+5, r25	; 0x05
    6900:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
    6902:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    6904:	8c 81       	ldd	r24, Y+4	; 0x04
    6906:	9d 81       	ldd	r25, Y+5	; 0x05
    6908:	9a 83       	std	Y+2, r25	; 0x02
    690a:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    690c:	e9 81       	ldd	r30, Y+1	; 0x01
    690e:	fa 81       	ldd	r31, Y+2	; 0x02
    6910:	82 85       	ldd	r24, Z+10	; 0x0a
    6912:	93 85       	ldd	r25, Z+11	; 0x0b
    6914:	28 e0       	ldi	r18, 0x08	; 8
    6916:	8e 34       	cpi	r24, 0x4E	; 78
    6918:	92 07       	cpc	r25, r18
    691a:	81 f4       	brne	.+32     	; 0x693c <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    691c:	e9 81       	ldd	r30, Y+1	; 0x01
    691e:	fa 81       	ldd	r31, Y+2	; 0x02
    6920:	84 89       	ldd	r24, Z+20	; 0x14
    6922:	95 89       	ldd	r25, Z+21	; 0x15
    6924:	28 e0       	ldi	r18, 0x08	; 8
    6926:	8c 33       	cpi	r24, 0x3C	; 60
    6928:	92 07       	cpc	r25, r18
    692a:	41 f0       	breq	.+16     	; 0x693c <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    692c:	e9 81       	ldd	r30, Y+1	; 0x01
    692e:	fa 81       	ldd	r31, Y+2	; 0x02
    6930:	84 89       	ldd	r24, Z+20	; 0x14
    6932:	95 89       	ldd	r25, Z+21	; 0x15
    6934:	00 97       	sbiw	r24, 0x00	; 0
    6936:	11 f4       	brne	.+4      	; 0x693c <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    6938:	81 e0       	ldi	r24, 0x01	; 1
    693a:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
    693c:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    693e:	0f 90       	pop	r0
    6940:	0f 90       	pop	r0
    6942:	0f 90       	pop	r0
    6944:	0f 90       	pop	r0
    6946:	0f 90       	pop	r0
    6948:	cf 91       	pop	r28
    694a:	df 91       	pop	r29
    694c:	08 95       	ret

0000694e <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    694e:	df 93       	push	r29
    6950:	cf 93       	push	r28
    6952:	00 d0       	rcall	.+0      	; 0x6954 <vTaskResume+0x6>
    6954:	00 d0       	rcall	.+0      	; 0x6956 <vTaskResume+0x8>
    6956:	cd b7       	in	r28, 0x3d	; 61
    6958:	de b7       	in	r29, 0x3e	; 62
    695a:	9c 83       	std	Y+4, r25	; 0x04
    695c:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    695e:	8b 81       	ldd	r24, Y+3	; 0x03
    6960:	9c 81       	ldd	r25, Y+4	; 0x04
    6962:	9a 83       	std	Y+2, r25	; 0x02
    6964:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    6966:	89 81       	ldd	r24, Y+1	; 0x01
    6968:	9a 81       	ldd	r25, Y+2	; 0x02
    696a:	00 97       	sbiw	r24, 0x00	; 0
    696c:	09 f4       	brne	.+2      	; 0x6970 <vTaskResume+0x22>
    696e:	4c c0       	rjmp	.+152    	; 0x6a08 <vTaskResume+0xba>
    6970:	20 91 e2 07 	lds	r18, 0x07E2
    6974:	30 91 e3 07 	lds	r19, 0x07E3
    6978:	89 81       	ldd	r24, Y+1	; 0x01
    697a:	9a 81       	ldd	r25, Y+2	; 0x02
    697c:	82 17       	cp	r24, r18
    697e:	93 07       	cpc	r25, r19
    6980:	09 f4       	brne	.+2      	; 0x6984 <vTaskResume+0x36>
    6982:	42 c0       	rjmp	.+132    	; 0x6a08 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    6984:	0f b6       	in	r0, 0x3f	; 63
    6986:	f8 94       	cli
    6988:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    698a:	89 81       	ldd	r24, Y+1	; 0x01
    698c:	9a 81       	ldd	r25, Y+2	; 0x02
    698e:	0e 94 78 34 	call	0x68f0	; 0x68f0 <xTaskIsTaskSuspended>
    6992:	81 30       	cpi	r24, 0x01	; 1
    6994:	b9 f5       	brne	.+110    	; 0x6a04 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    6996:	89 81       	ldd	r24, Y+1	; 0x01
    6998:	9a 81       	ldd	r25, Y+2	; 0x02
    699a:	02 96       	adiw	r24, 0x02	; 2
    699c:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    69a0:	e9 81       	ldd	r30, Y+1	; 0x01
    69a2:	fa 81       	ldd	r31, Y+2	; 0x02
    69a4:	96 89       	ldd	r25, Z+22	; 0x16
    69a6:	80 91 e9 07 	lds	r24, 0x07E9
    69aa:	89 17       	cp	r24, r25
    69ac:	28 f4       	brcc	.+10     	; 0x69b8 <vTaskResume+0x6a>
    69ae:	e9 81       	ldd	r30, Y+1	; 0x01
    69b0:	fa 81       	ldd	r31, Y+2	; 0x02
    69b2:	86 89       	ldd	r24, Z+22	; 0x16
    69b4:	80 93 e9 07 	sts	0x07E9, r24
    69b8:	e9 81       	ldd	r30, Y+1	; 0x01
    69ba:	fa 81       	ldd	r31, Y+2	; 0x02
    69bc:	86 89       	ldd	r24, Z+22	; 0x16
    69be:	28 2f       	mov	r18, r24
    69c0:	30 e0       	ldi	r19, 0x00	; 0
    69c2:	c9 01       	movw	r24, r18
    69c4:	88 0f       	add	r24, r24
    69c6:	99 1f       	adc	r25, r25
    69c8:	88 0f       	add	r24, r24
    69ca:	99 1f       	adc	r25, r25
    69cc:	88 0f       	add	r24, r24
    69ce:	99 1f       	adc	r25, r25
    69d0:	82 0f       	add	r24, r18
    69d2:	93 1f       	adc	r25, r19
    69d4:	ac 01       	movw	r20, r24
    69d6:	40 51       	subi	r20, 0x10	; 16
    69d8:	58 4f       	sbci	r21, 0xF8	; 248
    69da:	89 81       	ldd	r24, Y+1	; 0x01
    69dc:	9a 81       	ldd	r25, Y+2	; 0x02
    69de:	9c 01       	movw	r18, r24
    69e0:	2e 5f       	subi	r18, 0xFE	; 254
    69e2:	3f 4f       	sbci	r19, 0xFF	; 255
    69e4:	ca 01       	movw	r24, r20
    69e6:	b9 01       	movw	r22, r18
    69e8:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    69ec:	e9 81       	ldd	r30, Y+1	; 0x01
    69ee:	fa 81       	ldd	r31, Y+2	; 0x02
    69f0:	96 89       	ldd	r25, Z+22	; 0x16
    69f2:	e0 91 e2 07 	lds	r30, 0x07E2
    69f6:	f0 91 e3 07 	lds	r31, 0x07E3
    69fa:	86 89       	ldd	r24, Z+22	; 0x16
    69fc:	98 17       	cp	r25, r24
    69fe:	10 f0       	brcs	.+4      	; 0x6a04 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    6a00:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    6a04:	0f 90       	pop	r0
    6a06:	0f be       	out	0x3f, r0	; 63
		}
	}
    6a08:	0f 90       	pop	r0
    6a0a:	0f 90       	pop	r0
    6a0c:	0f 90       	pop	r0
    6a0e:	0f 90       	pop	r0
    6a10:	cf 91       	pop	r28
    6a12:	df 91       	pop	r29
    6a14:	08 95       	ret

00006a16 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    6a16:	df 93       	push	r29
    6a18:	cf 93       	push	r28
    6a1a:	00 d0       	rcall	.+0      	; 0x6a1c <xTaskResumeFromISR+0x6>
    6a1c:	00 d0       	rcall	.+0      	; 0x6a1e <xTaskResumeFromISR+0x8>
    6a1e:	0f 92       	push	r0
    6a20:	cd b7       	in	r28, 0x3d	; 61
    6a22:	de b7       	in	r29, 0x3e	; 62
    6a24:	9d 83       	std	Y+5, r25	; 0x05
    6a26:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xYieldRequired = pdFALSE;
    6a28:	1b 82       	std	Y+3, r1	; 0x03
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    6a2a:	8c 81       	ldd	r24, Y+4	; 0x04
    6a2c:	9d 81       	ldd	r25, Y+5	; 0x05
    6a2e:	9a 83       	std	Y+2, r25	; 0x02
    6a30:	89 83       	std	Y+1, r24	; 0x01

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    6a32:	89 81       	ldd	r24, Y+1	; 0x01
    6a34:	9a 81       	ldd	r25, Y+2	; 0x02
    6a36:	0e 94 78 34 	call	0x68f0	; 0x68f0 <xTaskIsTaskSuspended>
    6a3a:	81 30       	cpi	r24, 0x01	; 1
    6a3c:	09 f0       	breq	.+2      	; 0x6a40 <xTaskResumeFromISR+0x2a>
    6a3e:	47 c0       	rjmp	.+142    	; 0x6ace <xTaskResumeFromISR+0xb8>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6a40:	80 91 eb 07 	lds	r24, 0x07EB
    6a44:	88 23       	and	r24, r24
    6a46:	c9 f5       	brne	.+114    	; 0x6aba <xTaskResumeFromISR+0xa4>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    6a48:	e9 81       	ldd	r30, Y+1	; 0x01
    6a4a:	fa 81       	ldd	r31, Y+2	; 0x02
    6a4c:	96 89       	ldd	r25, Z+22	; 0x16
    6a4e:	e0 91 e2 07 	lds	r30, 0x07E2
    6a52:	f0 91 e3 07 	lds	r31, 0x07E3
    6a56:	86 89       	ldd	r24, Z+22	; 0x16
    6a58:	1b 82       	std	Y+3, r1	; 0x03
    6a5a:	98 17       	cp	r25, r24
    6a5c:	10 f0       	brcs	.+4      	; 0x6a62 <xTaskResumeFromISR+0x4c>
    6a5e:	81 e0       	ldi	r24, 0x01	; 1
    6a60:	8b 83       	std	Y+3, r24	; 0x03
				vListRemove(  &( pxTCB->xGenericListItem ) );
    6a62:	89 81       	ldd	r24, Y+1	; 0x01
    6a64:	9a 81       	ldd	r25, Y+2	; 0x02
    6a66:	02 96       	adiw	r24, 0x02	; 2
    6a68:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    6a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    6a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    6a70:	96 89       	ldd	r25, Z+22	; 0x16
    6a72:	80 91 e9 07 	lds	r24, 0x07E9
    6a76:	89 17       	cp	r24, r25
    6a78:	28 f4       	brcc	.+10     	; 0x6a84 <xTaskResumeFromISR+0x6e>
    6a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    6a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    6a7e:	86 89       	ldd	r24, Z+22	; 0x16
    6a80:	80 93 e9 07 	sts	0x07E9, r24
    6a84:	e9 81       	ldd	r30, Y+1	; 0x01
    6a86:	fa 81       	ldd	r31, Y+2	; 0x02
    6a88:	86 89       	ldd	r24, Z+22	; 0x16
    6a8a:	28 2f       	mov	r18, r24
    6a8c:	30 e0       	ldi	r19, 0x00	; 0
    6a8e:	c9 01       	movw	r24, r18
    6a90:	88 0f       	add	r24, r24
    6a92:	99 1f       	adc	r25, r25
    6a94:	88 0f       	add	r24, r24
    6a96:	99 1f       	adc	r25, r25
    6a98:	88 0f       	add	r24, r24
    6a9a:	99 1f       	adc	r25, r25
    6a9c:	82 0f       	add	r24, r18
    6a9e:	93 1f       	adc	r25, r19
    6aa0:	ac 01       	movw	r20, r24
    6aa2:	40 51       	subi	r20, 0x10	; 16
    6aa4:	58 4f       	sbci	r21, 0xF8	; 248
    6aa6:	89 81       	ldd	r24, Y+1	; 0x01
    6aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    6aaa:	9c 01       	movw	r18, r24
    6aac:	2e 5f       	subi	r18, 0xFE	; 254
    6aae:	3f 4f       	sbci	r19, 0xFF	; 255
    6ab0:	ca 01       	movw	r24, r20
    6ab2:	b9 01       	movw	r22, r18
    6ab4:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>
    6ab8:	0a c0       	rjmp	.+20     	; 0x6ace <xTaskResumeFromISR+0xb8>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6aba:	89 81       	ldd	r24, Y+1	; 0x01
    6abc:	9a 81       	ldd	r25, Y+2	; 0x02
    6abe:	9c 01       	movw	r18, r24
    6ac0:	24 5f       	subi	r18, 0xF4	; 244
    6ac2:	3f 4f       	sbci	r19, 0xFF	; 255
    6ac4:	8c e3       	ldi	r24, 0x3C	; 60
    6ac6:	98 e0       	ldi	r25, 0x08	; 8
    6ac8:	b9 01       	movw	r22, r18
    6aca:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>
			}
		}

		return xYieldRequired;
    6ace:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    6ad0:	0f 90       	pop	r0
    6ad2:	0f 90       	pop	r0
    6ad4:	0f 90       	pop	r0
    6ad6:	0f 90       	pop	r0
    6ad8:	0f 90       	pop	r0
    6ada:	cf 91       	pop	r28
    6adc:	df 91       	pop	r29
    6ade:	08 95       	ret

00006ae0 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    6ae0:	af 92       	push	r10
    6ae2:	bf 92       	push	r11
    6ae4:	cf 92       	push	r12
    6ae6:	df 92       	push	r13
    6ae8:	ef 92       	push	r14
    6aea:	ff 92       	push	r15
    6aec:	0f 93       	push	r16
    6aee:	df 93       	push	r29
    6af0:	cf 93       	push	r28
    6af2:	0f 92       	push	r0
    6af4:	cd b7       	in	r28, 0x3d	; 61
    6af6:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    6af8:	20 e6       	ldi	r18, 0x60	; 96
    6afa:	30 e0       	ldi	r19, 0x00	; 0
    6afc:	84 ef       	ldi	r24, 0xF4	; 244
    6afe:	98 e3       	ldi	r25, 0x38	; 56
    6b00:	b9 01       	movw	r22, r18
    6b02:	44 e6       	ldi	r20, 0x64	; 100
    6b04:	50 e0       	ldi	r21, 0x00	; 0
    6b06:	20 e0       	ldi	r18, 0x00	; 0
    6b08:	30 e0       	ldi	r19, 0x00	; 0
    6b0a:	00 e0       	ldi	r16, 0x00	; 0
    6b0c:	ee 24       	eor	r14, r14
    6b0e:	ff 24       	eor	r15, r15
    6b10:	cc 24       	eor	r12, r12
    6b12:	dd 24       	eor	r13, r13
    6b14:	aa 24       	eor	r10, r10
    6b16:	bb 24       	eor	r11, r11
    6b18:	0e 94 18 32 	call	0x6430	; 0x6430 <xTaskGenericCreate>
    6b1c:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    6b1e:	89 81       	ldd	r24, Y+1	; 0x01
    6b20:	81 30       	cpi	r24, 0x01	; 1
    6b22:	51 f4       	brne	.+20     	; 0x6b38 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    6b24:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    6b26:	81 e0       	ldi	r24, 0x01	; 1
    6b28:	80 93 ea 07 	sts	0x07EA, r24
		xTickCount = ( portTickType ) 0U;
    6b2c:	10 92 e7 07 	sts	0x07E7, r1
    6b30:	10 92 e6 07 	sts	0x07E6, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    6b34:	0e 94 29 2c 	call	0x5852	; 0x5852 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    6b38:	0f 90       	pop	r0
    6b3a:	cf 91       	pop	r28
    6b3c:	df 91       	pop	r29
    6b3e:	0f 91       	pop	r16
    6b40:	ff 90       	pop	r15
    6b42:	ef 90       	pop	r14
    6b44:	df 90       	pop	r13
    6b46:	cf 90       	pop	r12
    6b48:	bf 90       	pop	r11
    6b4a:	af 90       	pop	r10
    6b4c:	08 95       	ret

00006b4e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    6b4e:	df 93       	push	r29
    6b50:	cf 93       	push	r28
    6b52:	cd b7       	in	r28, 0x3d	; 61
    6b54:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    6b56:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    6b58:	10 92 ea 07 	sts	0x07EA, r1
	vPortEndScheduler();
    6b5c:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <vPortEndScheduler>
}
    6b60:	cf 91       	pop	r28
    6b62:	df 91       	pop	r29
    6b64:	08 95       	ret

00006b66 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    6b66:	df 93       	push	r29
    6b68:	cf 93       	push	r28
    6b6a:	cd b7       	in	r28, 0x3d	; 61
    6b6c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    6b6e:	80 91 eb 07 	lds	r24, 0x07EB
    6b72:	8f 5f       	subi	r24, 0xFF	; 255
    6b74:	80 93 eb 07 	sts	0x07EB, r24
}
    6b78:	cf 91       	pop	r28
    6b7a:	df 91       	pop	r29
    6b7c:	08 95       	ret

00006b7e <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    6b7e:	df 93       	push	r29
    6b80:	cf 93       	push	r28
    6b82:	00 d0       	rcall	.+0      	; 0x6b84 <xTaskResumeAll+0x6>
    6b84:	00 d0       	rcall	.+0      	; 0x6b86 <xTaskResumeAll+0x8>
    6b86:	cd b7       	in	r28, 0x3d	; 61
    6b88:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    6b8a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    6b8c:	0f b6       	in	r0, 0x3f	; 63
    6b8e:	f8 94       	cli
    6b90:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    6b92:	80 91 eb 07 	lds	r24, 0x07EB
    6b96:	81 50       	subi	r24, 0x01	; 1
    6b98:	80 93 eb 07 	sts	0x07EB, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6b9c:	80 91 eb 07 	lds	r24, 0x07EB
    6ba0:	88 23       	and	r24, r24
    6ba2:	09 f0       	breq	.+2      	; 0x6ba6 <xTaskResumeAll+0x28>
    6ba4:	6c c0       	rjmp	.+216    	; 0x6c7e <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    6ba6:	80 91 e5 07 	lds	r24, 0x07E5
    6baa:	88 23       	and	r24, r24
    6bac:	09 f4       	brne	.+2      	; 0x6bb0 <xTaskResumeAll+0x32>
    6bae:	67 c0       	rjmp	.+206    	; 0x6c7e <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    6bb0:	19 82       	std	Y+1, r1	; 0x01
    6bb2:	41 c0       	rjmp	.+130    	; 0x6c36 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    6bb4:	e0 91 41 08 	lds	r30, 0x0841
    6bb8:	f0 91 42 08 	lds	r31, 0x0842
    6bbc:	86 81       	ldd	r24, Z+6	; 0x06
    6bbe:	97 81       	ldd	r25, Z+7	; 0x07
    6bc0:	9c 83       	std	Y+4, r25	; 0x04
    6bc2:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    6bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    6bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    6bc8:	0c 96       	adiw	r24, 0x0c	; 12
    6bca:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    6bce:	8b 81       	ldd	r24, Y+3	; 0x03
    6bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    6bd2:	02 96       	adiw	r24, 0x02	; 2
    6bd4:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    6bd8:	eb 81       	ldd	r30, Y+3	; 0x03
    6bda:	fc 81       	ldd	r31, Y+4	; 0x04
    6bdc:	96 89       	ldd	r25, Z+22	; 0x16
    6bde:	80 91 e9 07 	lds	r24, 0x07E9
    6be2:	89 17       	cp	r24, r25
    6be4:	28 f4       	brcc	.+10     	; 0x6bf0 <xTaskResumeAll+0x72>
    6be6:	eb 81       	ldd	r30, Y+3	; 0x03
    6be8:	fc 81       	ldd	r31, Y+4	; 0x04
    6bea:	86 89       	ldd	r24, Z+22	; 0x16
    6bec:	80 93 e9 07 	sts	0x07E9, r24
    6bf0:	eb 81       	ldd	r30, Y+3	; 0x03
    6bf2:	fc 81       	ldd	r31, Y+4	; 0x04
    6bf4:	86 89       	ldd	r24, Z+22	; 0x16
    6bf6:	28 2f       	mov	r18, r24
    6bf8:	30 e0       	ldi	r19, 0x00	; 0
    6bfa:	c9 01       	movw	r24, r18
    6bfc:	88 0f       	add	r24, r24
    6bfe:	99 1f       	adc	r25, r25
    6c00:	88 0f       	add	r24, r24
    6c02:	99 1f       	adc	r25, r25
    6c04:	88 0f       	add	r24, r24
    6c06:	99 1f       	adc	r25, r25
    6c08:	82 0f       	add	r24, r18
    6c0a:	93 1f       	adc	r25, r19
    6c0c:	80 51       	subi	r24, 0x10	; 16
    6c0e:	98 4f       	sbci	r25, 0xF8	; 248
    6c10:	2b 81       	ldd	r18, Y+3	; 0x03
    6c12:	3c 81       	ldd	r19, Y+4	; 0x04
    6c14:	2e 5f       	subi	r18, 0xFE	; 254
    6c16:	3f 4f       	sbci	r19, 0xFF	; 255
    6c18:	b9 01       	movw	r22, r18
    6c1a:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6c1e:	eb 81       	ldd	r30, Y+3	; 0x03
    6c20:	fc 81       	ldd	r31, Y+4	; 0x04
    6c22:	96 89       	ldd	r25, Z+22	; 0x16
    6c24:	e0 91 e2 07 	lds	r30, 0x07E2
    6c28:	f0 91 e3 07 	lds	r31, 0x07E3
    6c2c:	86 89       	ldd	r24, Z+22	; 0x16
    6c2e:	98 17       	cp	r25, r24
    6c30:	10 f0       	brcs	.+4      	; 0x6c36 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    6c32:	81 e0       	ldi	r24, 0x01	; 1
    6c34:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    6c36:	80 91 3c 08 	lds	r24, 0x083C
    6c3a:	88 23       	and	r24, r24
    6c3c:	09 f0       	breq	.+2      	; 0x6c40 <xTaskResumeAll+0xc2>
    6c3e:	ba cf       	rjmp	.-140    	; 0x6bb4 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    6c40:	80 91 ec 07 	lds	r24, 0x07EC
    6c44:	88 23       	and	r24, r24
    6c46:	71 f0       	breq	.+28     	; 0x6c64 <xTaskResumeAll+0xe6>
    6c48:	07 c0       	rjmp	.+14     	; 0x6c58 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    6c4a:	0e 94 7e 36 	call	0x6cfc	; 0x6cfc <vTaskIncrementTick>
						--uxMissedTicks;
    6c4e:	80 91 ec 07 	lds	r24, 0x07EC
    6c52:	81 50       	subi	r24, 0x01	; 1
    6c54:	80 93 ec 07 	sts	0x07EC, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    6c58:	80 91 ec 07 	lds	r24, 0x07EC
    6c5c:	88 23       	and	r24, r24
    6c5e:	a9 f7       	brne	.-22     	; 0x6c4a <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    6c60:	81 e0       	ldi	r24, 0x01	; 1
    6c62:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    6c64:	89 81       	ldd	r24, Y+1	; 0x01
    6c66:	81 30       	cpi	r24, 0x01	; 1
    6c68:	21 f0       	breq	.+8      	; 0x6c72 <xTaskResumeAll+0xf4>
    6c6a:	80 91 ed 07 	lds	r24, 0x07ED
    6c6e:	81 30       	cpi	r24, 0x01	; 1
    6c70:	31 f4       	brne	.+12     	; 0x6c7e <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    6c72:	81 e0       	ldi	r24, 0x01	; 1
    6c74:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    6c76:	10 92 ed 07 	sts	0x07ED, r1
					portYIELD_WITHIN_API();
    6c7a:	0e 94 65 2c 	call	0x58ca	; 0x58ca <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    6c7e:	0f 90       	pop	r0
    6c80:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    6c82:	8a 81       	ldd	r24, Y+2	; 0x02
}
    6c84:	0f 90       	pop	r0
    6c86:	0f 90       	pop	r0
    6c88:	0f 90       	pop	r0
    6c8a:	0f 90       	pop	r0
    6c8c:	cf 91       	pop	r28
    6c8e:	df 91       	pop	r29
    6c90:	08 95       	ret

00006c92 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    6c92:	df 93       	push	r29
    6c94:	cf 93       	push	r28
    6c96:	00 d0       	rcall	.+0      	; 0x6c98 <xTaskGetTickCount+0x6>
    6c98:	cd b7       	in	r28, 0x3d	; 61
    6c9a:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    6c9c:	0f b6       	in	r0, 0x3f	; 63
    6c9e:	f8 94       	cli
    6ca0:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    6ca2:	80 91 e6 07 	lds	r24, 0x07E6
    6ca6:	90 91 e7 07 	lds	r25, 0x07E7
    6caa:	9a 83       	std	Y+2, r25	; 0x02
    6cac:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    6cae:	0f 90       	pop	r0
    6cb0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    6cb2:	89 81       	ldd	r24, Y+1	; 0x01
    6cb4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6cb6:	0f 90       	pop	r0
    6cb8:	0f 90       	pop	r0
    6cba:	cf 91       	pop	r28
    6cbc:	df 91       	pop	r29
    6cbe:	08 95       	ret

00006cc0 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    6cc0:	df 93       	push	r29
    6cc2:	cf 93       	push	r28
    6cc4:	00 d0       	rcall	.+0      	; 0x6cc6 <xTaskGetTickCountFromISR+0x6>
    6cc6:	0f 92       	push	r0
    6cc8:	cd b7       	in	r28, 0x3d	; 61
    6cca:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6ccc:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    6cce:	80 91 e6 07 	lds	r24, 0x07E6
    6cd2:	90 91 e7 07 	lds	r25, 0x07E7
    6cd6:	9b 83       	std	Y+3, r25	; 0x03
    6cd8:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6cda:	8a 81       	ldd	r24, Y+2	; 0x02
    6cdc:	9b 81       	ldd	r25, Y+3	; 0x03
}
    6cde:	0f 90       	pop	r0
    6ce0:	0f 90       	pop	r0
    6ce2:	0f 90       	pop	r0
    6ce4:	cf 91       	pop	r28
    6ce6:	df 91       	pop	r29
    6ce8:	08 95       	ret

00006cea <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    6cea:	df 93       	push	r29
    6cec:	cf 93       	push	r28
    6cee:	cd b7       	in	r28, 0x3d	; 61
    6cf0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    6cf2:	80 91 e5 07 	lds	r24, 0x07E5
}
    6cf6:	cf 91       	pop	r28
    6cf8:	df 91       	pop	r29
    6cfa:	08 95       	ret

00006cfc <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    6cfc:	df 93       	push	r29
    6cfe:	cf 93       	push	r28
    6d00:	00 d0       	rcall	.+0      	; 0x6d02 <vTaskIncrementTick+0x6>
    6d02:	00 d0       	rcall	.+0      	; 0x6d04 <vTaskIncrementTick+0x8>
    6d04:	00 d0       	rcall	.+0      	; 0x6d06 <vTaskIncrementTick+0xa>
    6d06:	cd b7       	in	r28, 0x3d	; 61
    6d08:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    6d0a:	80 91 eb 07 	lds	r24, 0x07EB
    6d0e:	88 23       	and	r24, r24
    6d10:	09 f0       	breq	.+2      	; 0x6d14 <vTaskIncrementTick+0x18>
    6d12:	bb c0       	rjmp	.+374    	; 0x6e8a <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    6d14:	80 91 e6 07 	lds	r24, 0x07E6
    6d18:	90 91 e7 07 	lds	r25, 0x07E7
    6d1c:	01 96       	adiw	r24, 0x01	; 1
    6d1e:	90 93 e7 07 	sts	0x07E7, r25
    6d22:	80 93 e6 07 	sts	0x07E6, r24
		if( xTickCount == ( portTickType ) 0U )
    6d26:	80 91 e6 07 	lds	r24, 0x07E6
    6d2a:	90 91 e7 07 	lds	r25, 0x07E7
    6d2e:	00 97       	sbiw	r24, 0x00	; 0
    6d30:	d1 f5       	brne	.+116    	; 0x6da6 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    6d32:	80 91 38 08 	lds	r24, 0x0838
    6d36:	90 91 39 08 	lds	r25, 0x0839
    6d3a:	9c 83       	std	Y+4, r25	; 0x04
    6d3c:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    6d3e:	80 91 3a 08 	lds	r24, 0x083A
    6d42:	90 91 3b 08 	lds	r25, 0x083B
    6d46:	90 93 39 08 	sts	0x0839, r25
    6d4a:	80 93 38 08 	sts	0x0838, r24
			pxOverflowDelayedTaskList = pxTemp;
    6d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    6d50:	9c 81       	ldd	r25, Y+4	; 0x04
    6d52:	90 93 3b 08 	sts	0x083B, r25
    6d56:	80 93 3a 08 	sts	0x083A, r24
			xNumOfOverflows++;
    6d5a:	80 91 ee 07 	lds	r24, 0x07EE
    6d5e:	8f 5f       	subi	r24, 0xFF	; 255
    6d60:	80 93 ee 07 	sts	0x07EE, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6d64:	e0 91 38 08 	lds	r30, 0x0838
    6d68:	f0 91 39 08 	lds	r31, 0x0839
    6d6c:	80 81       	ld	r24, Z
    6d6e:	88 23       	and	r24, r24
    6d70:	39 f4       	brne	.+14     	; 0x6d80 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    6d72:	8f ef       	ldi	r24, 0xFF	; 255
    6d74:	9f ef       	ldi	r25, 0xFF	; 255
    6d76:	90 93 71 01 	sts	0x0171, r25
    6d7a:	80 93 70 01 	sts	0x0170, r24
    6d7e:	13 c0       	rjmp	.+38     	; 0x6da6 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    6d80:	e0 91 38 08 	lds	r30, 0x0838
    6d84:	f0 91 39 08 	lds	r31, 0x0839
    6d88:	05 80       	ldd	r0, Z+5	; 0x05
    6d8a:	f6 81       	ldd	r31, Z+6	; 0x06
    6d8c:	e0 2d       	mov	r30, r0
    6d8e:	86 81       	ldd	r24, Z+6	; 0x06
    6d90:	97 81       	ldd	r25, Z+7	; 0x07
    6d92:	9e 83       	std	Y+6, r25	; 0x06
    6d94:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    6d96:	ed 81       	ldd	r30, Y+5	; 0x05
    6d98:	fe 81       	ldd	r31, Y+6	; 0x06
    6d9a:	82 81       	ldd	r24, Z+2	; 0x02
    6d9c:	93 81       	ldd	r25, Z+3	; 0x03
    6d9e:	90 93 71 01 	sts	0x0171, r25
    6da2:	80 93 70 01 	sts	0x0170, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    6da6:	20 91 e6 07 	lds	r18, 0x07E6
    6daa:	30 91 e7 07 	lds	r19, 0x07E7
    6dae:	80 91 70 01 	lds	r24, 0x0170
    6db2:	90 91 71 01 	lds	r25, 0x0171
    6db6:	28 17       	cp	r18, r24
    6db8:	39 07       	cpc	r19, r25
    6dba:	08 f4       	brcc	.+2      	; 0x6dbe <vTaskIncrementTick+0xc2>
    6dbc:	6b c0       	rjmp	.+214    	; 0x6e94 <vTaskIncrementTick+0x198>
    6dbe:	e0 91 38 08 	lds	r30, 0x0838
    6dc2:	f0 91 39 08 	lds	r31, 0x0839
    6dc6:	80 81       	ld	r24, Z
    6dc8:	88 23       	and	r24, r24
    6dca:	39 f4       	brne	.+14     	; 0x6dda <vTaskIncrementTick+0xde>
    6dcc:	8f ef       	ldi	r24, 0xFF	; 255
    6dce:	9f ef       	ldi	r25, 0xFF	; 255
    6dd0:	90 93 71 01 	sts	0x0171, r25
    6dd4:	80 93 70 01 	sts	0x0170, r24
    6dd8:	5d c0       	rjmp	.+186    	; 0x6e94 <vTaskIncrementTick+0x198>
    6dda:	e0 91 38 08 	lds	r30, 0x0838
    6dde:	f0 91 39 08 	lds	r31, 0x0839
    6de2:	05 80       	ldd	r0, Z+5	; 0x05
    6de4:	f6 81       	ldd	r31, Z+6	; 0x06
    6de6:	e0 2d       	mov	r30, r0
    6de8:	86 81       	ldd	r24, Z+6	; 0x06
    6dea:	97 81       	ldd	r25, Z+7	; 0x07
    6dec:	9e 83       	std	Y+6, r25	; 0x06
    6dee:	8d 83       	std	Y+5, r24	; 0x05
    6df0:	ed 81       	ldd	r30, Y+5	; 0x05
    6df2:	fe 81       	ldd	r31, Y+6	; 0x06
    6df4:	82 81       	ldd	r24, Z+2	; 0x02
    6df6:	93 81       	ldd	r25, Z+3	; 0x03
    6df8:	9a 83       	std	Y+2, r25	; 0x02
    6dfa:	89 83       	std	Y+1, r24	; 0x01
    6dfc:	20 91 e6 07 	lds	r18, 0x07E6
    6e00:	30 91 e7 07 	lds	r19, 0x07E7
    6e04:	89 81       	ldd	r24, Y+1	; 0x01
    6e06:	9a 81       	ldd	r25, Y+2	; 0x02
    6e08:	28 17       	cp	r18, r24
    6e0a:	39 07       	cpc	r19, r25
    6e0c:	38 f4       	brcc	.+14     	; 0x6e1c <vTaskIncrementTick+0x120>
    6e0e:	89 81       	ldd	r24, Y+1	; 0x01
    6e10:	9a 81       	ldd	r25, Y+2	; 0x02
    6e12:	90 93 71 01 	sts	0x0171, r25
    6e16:	80 93 70 01 	sts	0x0170, r24
    6e1a:	3c c0       	rjmp	.+120    	; 0x6e94 <vTaskIncrementTick+0x198>
    6e1c:	8d 81       	ldd	r24, Y+5	; 0x05
    6e1e:	9e 81       	ldd	r25, Y+6	; 0x06
    6e20:	02 96       	adiw	r24, 0x02	; 2
    6e22:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
    6e26:	ed 81       	ldd	r30, Y+5	; 0x05
    6e28:	fe 81       	ldd	r31, Y+6	; 0x06
    6e2a:	84 89       	ldd	r24, Z+20	; 0x14
    6e2c:	95 89       	ldd	r25, Z+21	; 0x15
    6e2e:	00 97       	sbiw	r24, 0x00	; 0
    6e30:	29 f0       	breq	.+10     	; 0x6e3c <vTaskIncrementTick+0x140>
    6e32:	8d 81       	ldd	r24, Y+5	; 0x05
    6e34:	9e 81       	ldd	r25, Y+6	; 0x06
    6e36:	0c 96       	adiw	r24, 0x0c	; 12
    6e38:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
    6e3c:	ed 81       	ldd	r30, Y+5	; 0x05
    6e3e:	fe 81       	ldd	r31, Y+6	; 0x06
    6e40:	96 89       	ldd	r25, Z+22	; 0x16
    6e42:	80 91 e9 07 	lds	r24, 0x07E9
    6e46:	89 17       	cp	r24, r25
    6e48:	28 f4       	brcc	.+10     	; 0x6e54 <vTaskIncrementTick+0x158>
    6e4a:	ed 81       	ldd	r30, Y+5	; 0x05
    6e4c:	fe 81       	ldd	r31, Y+6	; 0x06
    6e4e:	86 89       	ldd	r24, Z+22	; 0x16
    6e50:	80 93 e9 07 	sts	0x07E9, r24
    6e54:	ed 81       	ldd	r30, Y+5	; 0x05
    6e56:	fe 81       	ldd	r31, Y+6	; 0x06
    6e58:	86 89       	ldd	r24, Z+22	; 0x16
    6e5a:	28 2f       	mov	r18, r24
    6e5c:	30 e0       	ldi	r19, 0x00	; 0
    6e5e:	c9 01       	movw	r24, r18
    6e60:	88 0f       	add	r24, r24
    6e62:	99 1f       	adc	r25, r25
    6e64:	88 0f       	add	r24, r24
    6e66:	99 1f       	adc	r25, r25
    6e68:	88 0f       	add	r24, r24
    6e6a:	99 1f       	adc	r25, r25
    6e6c:	82 0f       	add	r24, r18
    6e6e:	93 1f       	adc	r25, r19
    6e70:	ac 01       	movw	r20, r24
    6e72:	40 51       	subi	r20, 0x10	; 16
    6e74:	58 4f       	sbci	r21, 0xF8	; 248
    6e76:	8d 81       	ldd	r24, Y+5	; 0x05
    6e78:	9e 81       	ldd	r25, Y+6	; 0x06
    6e7a:	9c 01       	movw	r18, r24
    6e7c:	2e 5f       	subi	r18, 0xFE	; 254
    6e7e:	3f 4f       	sbci	r19, 0xFF	; 255
    6e80:	ca 01       	movw	r24, r20
    6e82:	b9 01       	movw	r22, r18
    6e84:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>
    6e88:	9a cf       	rjmp	.-204    	; 0x6dbe <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    6e8a:	80 91 ec 07 	lds	r24, 0x07EC
    6e8e:	8f 5f       	subi	r24, 0xFF	; 255
    6e90:	80 93 ec 07 	sts	0x07EC, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    6e94:	26 96       	adiw	r28, 0x06	; 6
    6e96:	0f b6       	in	r0, 0x3f	; 63
    6e98:	f8 94       	cli
    6e9a:	de bf       	out	0x3e, r29	; 62
    6e9c:	0f be       	out	0x3f, r0	; 63
    6e9e:	cd bf       	out	0x3d, r28	; 61
    6ea0:	cf 91       	pop	r28
    6ea2:	df 91       	pop	r29
    6ea4:	08 95       	ret

00006ea6 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    6ea6:	df 93       	push	r29
    6ea8:	cf 93       	push	r28
    6eaa:	00 d0       	rcall	.+0      	; 0x6eac <vTaskSwitchContext+0x6>
    6eac:	cd b7       	in	r28, 0x3d	; 61
    6eae:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    6eb0:	80 91 eb 07 	lds	r24, 0x07EB
    6eb4:	88 23       	and	r24, r24
    6eb6:	49 f0       	breq	.+18     	; 0x6eca <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    6eb8:	81 e0       	ldi	r24, 0x01	; 1
    6eba:	80 93 ed 07 	sts	0x07ED, r24
    6ebe:	54 c0       	rjmp	.+168    	; 0x6f68 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    6ec0:	80 91 e9 07 	lds	r24, 0x07E9
    6ec4:	81 50       	subi	r24, 0x01	; 1
    6ec6:	80 93 e9 07 	sts	0x07E9, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    6eca:	80 91 e9 07 	lds	r24, 0x07E9
    6ece:	28 2f       	mov	r18, r24
    6ed0:	30 e0       	ldi	r19, 0x00	; 0
    6ed2:	c9 01       	movw	r24, r18
    6ed4:	88 0f       	add	r24, r24
    6ed6:	99 1f       	adc	r25, r25
    6ed8:	88 0f       	add	r24, r24
    6eda:	99 1f       	adc	r25, r25
    6edc:	88 0f       	add	r24, r24
    6ede:	99 1f       	adc	r25, r25
    6ee0:	82 0f       	add	r24, r18
    6ee2:	93 1f       	adc	r25, r19
    6ee4:	fc 01       	movw	r30, r24
    6ee6:	e0 51       	subi	r30, 0x10	; 16
    6ee8:	f8 4f       	sbci	r31, 0xF8	; 248
    6eea:	80 81       	ld	r24, Z
    6eec:	88 23       	and	r24, r24
    6eee:	41 f3       	breq	.-48     	; 0x6ec0 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    6ef0:	80 91 e9 07 	lds	r24, 0x07E9
    6ef4:	28 2f       	mov	r18, r24
    6ef6:	30 e0       	ldi	r19, 0x00	; 0
    6ef8:	c9 01       	movw	r24, r18
    6efa:	88 0f       	add	r24, r24
    6efc:	99 1f       	adc	r25, r25
    6efe:	88 0f       	add	r24, r24
    6f00:	99 1f       	adc	r25, r25
    6f02:	88 0f       	add	r24, r24
    6f04:	99 1f       	adc	r25, r25
    6f06:	82 0f       	add	r24, r18
    6f08:	93 1f       	adc	r25, r19
    6f0a:	80 51       	subi	r24, 0x10	; 16
    6f0c:	98 4f       	sbci	r25, 0xF8	; 248
    6f0e:	9a 83       	std	Y+2, r25	; 0x02
    6f10:	89 83       	std	Y+1, r24	; 0x01
    6f12:	e9 81       	ldd	r30, Y+1	; 0x01
    6f14:	fa 81       	ldd	r31, Y+2	; 0x02
    6f16:	01 80       	ldd	r0, Z+1	; 0x01
    6f18:	f2 81       	ldd	r31, Z+2	; 0x02
    6f1a:	e0 2d       	mov	r30, r0
    6f1c:	82 81       	ldd	r24, Z+2	; 0x02
    6f1e:	93 81       	ldd	r25, Z+3	; 0x03
    6f20:	e9 81       	ldd	r30, Y+1	; 0x01
    6f22:	fa 81       	ldd	r31, Y+2	; 0x02
    6f24:	92 83       	std	Z+2, r25	; 0x02
    6f26:	81 83       	std	Z+1, r24	; 0x01
    6f28:	e9 81       	ldd	r30, Y+1	; 0x01
    6f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    6f2c:	21 81       	ldd	r18, Z+1	; 0x01
    6f2e:	32 81       	ldd	r19, Z+2	; 0x02
    6f30:	89 81       	ldd	r24, Y+1	; 0x01
    6f32:	9a 81       	ldd	r25, Y+2	; 0x02
    6f34:	03 96       	adiw	r24, 0x03	; 3
    6f36:	28 17       	cp	r18, r24
    6f38:	39 07       	cpc	r19, r25
    6f3a:	59 f4       	brne	.+22     	; 0x6f52 <vTaskSwitchContext+0xac>
    6f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    6f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    6f40:	01 80       	ldd	r0, Z+1	; 0x01
    6f42:	f2 81       	ldd	r31, Z+2	; 0x02
    6f44:	e0 2d       	mov	r30, r0
    6f46:	82 81       	ldd	r24, Z+2	; 0x02
    6f48:	93 81       	ldd	r25, Z+3	; 0x03
    6f4a:	e9 81       	ldd	r30, Y+1	; 0x01
    6f4c:	fa 81       	ldd	r31, Y+2	; 0x02
    6f4e:	92 83       	std	Z+2, r25	; 0x02
    6f50:	81 83       	std	Z+1, r24	; 0x01
    6f52:	e9 81       	ldd	r30, Y+1	; 0x01
    6f54:	fa 81       	ldd	r31, Y+2	; 0x02
    6f56:	01 80       	ldd	r0, Z+1	; 0x01
    6f58:	f2 81       	ldd	r31, Z+2	; 0x02
    6f5a:	e0 2d       	mov	r30, r0
    6f5c:	86 81       	ldd	r24, Z+6	; 0x06
    6f5e:	97 81       	ldd	r25, Z+7	; 0x07
    6f60:	90 93 e3 07 	sts	0x07E3, r25
    6f64:	80 93 e2 07 	sts	0x07E2, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    6f68:	0f 90       	pop	r0
    6f6a:	0f 90       	pop	r0
    6f6c:	cf 91       	pop	r28
    6f6e:	df 91       	pop	r29
    6f70:	08 95       	ret

00006f72 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    6f72:	df 93       	push	r29
    6f74:	cf 93       	push	r28
    6f76:	00 d0       	rcall	.+0      	; 0x6f78 <vTaskPlaceOnEventList+0x6>
    6f78:	00 d0       	rcall	.+0      	; 0x6f7a <vTaskPlaceOnEventList+0x8>
    6f7a:	00 d0       	rcall	.+0      	; 0x6f7c <vTaskPlaceOnEventList+0xa>
    6f7c:	cd b7       	in	r28, 0x3d	; 61
    6f7e:	de b7       	in	r29, 0x3e	; 62
    6f80:	9c 83       	std	Y+4, r25	; 0x04
    6f82:	8b 83       	std	Y+3, r24	; 0x03
    6f84:	7e 83       	std	Y+6, r23	; 0x06
    6f86:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    6f88:	4b 81       	ldd	r20, Y+3	; 0x03
    6f8a:	5c 81       	ldd	r21, Y+4	; 0x04
    6f8c:	80 91 e2 07 	lds	r24, 0x07E2
    6f90:	90 91 e3 07 	lds	r25, 0x07E3
    6f94:	9c 01       	movw	r18, r24
    6f96:	24 5f       	subi	r18, 0xF4	; 244
    6f98:	3f 4f       	sbci	r19, 0xFF	; 255
    6f9a:	ca 01       	movw	r24, r20
    6f9c:	b9 01       	movw	r22, r18
    6f9e:	0e 94 f1 29 	call	0x53e2	; 0x53e2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    6fa2:	80 91 e2 07 	lds	r24, 0x07E2
    6fa6:	90 91 e3 07 	lds	r25, 0x07E3
    6faa:	02 96       	adiw	r24, 0x02	; 2
    6fac:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    6fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    6fb2:	9e 81       	ldd	r25, Y+6	; 0x06
    6fb4:	2f ef       	ldi	r18, 0xFF	; 255
    6fb6:	8f 3f       	cpi	r24, 0xFF	; 255
    6fb8:	92 07       	cpc	r25, r18
    6fba:	69 f4       	brne	.+26     	; 0x6fd6 <vTaskPlaceOnEventList+0x64>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    6fbc:	80 91 e2 07 	lds	r24, 0x07E2
    6fc0:	90 91 e3 07 	lds	r25, 0x07E3
    6fc4:	9c 01       	movw	r18, r24
    6fc6:	2e 5f       	subi	r18, 0xFE	; 254
    6fc8:	3f 4f       	sbci	r19, 0xFF	; 255
    6fca:	8e e4       	ldi	r24, 0x4E	; 78
    6fcc:	98 e0       	ldi	r25, 0x08	; 8
    6fce:	b9 01       	movw	r22, r18
    6fd0:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>
    6fd4:	0e c0       	rjmp	.+28     	; 0x6ff2 <vTaskPlaceOnEventList+0x80>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    6fd6:	20 91 e6 07 	lds	r18, 0x07E6
    6fda:	30 91 e7 07 	lds	r19, 0x07E7
    6fde:	8d 81       	ldd	r24, Y+5	; 0x05
    6fe0:	9e 81       	ldd	r25, Y+6	; 0x06
    6fe2:	82 0f       	add	r24, r18
    6fe4:	93 1f       	adc	r25, r19
    6fe6:	9a 83       	std	Y+2, r25	; 0x02
    6fe8:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    6fea:	89 81       	ldd	r24, Y+1	; 0x01
    6fec:	9a 81       	ldd	r25, Y+2	; 0x02
    6fee:	0e 94 d4 39 	call	0x73a8	; 0x73a8 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    6ff2:	26 96       	adiw	r28, 0x06	; 6
    6ff4:	0f b6       	in	r0, 0x3f	; 63
    6ff6:	f8 94       	cli
    6ff8:	de bf       	out	0x3e, r29	; 62
    6ffa:	0f be       	out	0x3f, r0	; 63
    6ffc:	cd bf       	out	0x3d, r28	; 61
    6ffe:	cf 91       	pop	r28
    7000:	df 91       	pop	r29
    7002:	08 95       	ret

00007004 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    7004:	df 93       	push	r29
    7006:	cf 93       	push	r28
    7008:	00 d0       	rcall	.+0      	; 0x700a <xTaskRemoveFromEventList+0x6>
    700a:	00 d0       	rcall	.+0      	; 0x700c <xTaskRemoveFromEventList+0x8>
    700c:	0f 92       	push	r0
    700e:	cd b7       	in	r28, 0x3d	; 61
    7010:	de b7       	in	r29, 0x3e	; 62
    7012:	9d 83       	std	Y+5, r25	; 0x05
    7014:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    7016:	ec 81       	ldd	r30, Y+4	; 0x04
    7018:	fd 81       	ldd	r31, Y+5	; 0x05
    701a:	05 80       	ldd	r0, Z+5	; 0x05
    701c:	f6 81       	ldd	r31, Z+6	; 0x06
    701e:	e0 2d       	mov	r30, r0
    7020:	86 81       	ldd	r24, Z+6	; 0x06
    7022:	97 81       	ldd	r25, Z+7	; 0x07
    7024:	9b 83       	std	Y+3, r25	; 0x03
    7026:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    7028:	8a 81       	ldd	r24, Y+2	; 0x02
    702a:	9b 81       	ldd	r25, Y+3	; 0x03
    702c:	0c 96       	adiw	r24, 0x0c	; 12
    702e:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    7032:	80 91 eb 07 	lds	r24, 0x07EB
    7036:	88 23       	and	r24, r24
    7038:	61 f5       	brne	.+88     	; 0x7092 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    703a:	8a 81       	ldd	r24, Y+2	; 0x02
    703c:	9b 81       	ldd	r25, Y+3	; 0x03
    703e:	02 96       	adiw	r24, 0x02	; 2
    7040:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    7044:	ea 81       	ldd	r30, Y+2	; 0x02
    7046:	fb 81       	ldd	r31, Y+3	; 0x03
    7048:	96 89       	ldd	r25, Z+22	; 0x16
    704a:	80 91 e9 07 	lds	r24, 0x07E9
    704e:	89 17       	cp	r24, r25
    7050:	28 f4       	brcc	.+10     	; 0x705c <xTaskRemoveFromEventList+0x58>
    7052:	ea 81       	ldd	r30, Y+2	; 0x02
    7054:	fb 81       	ldd	r31, Y+3	; 0x03
    7056:	86 89       	ldd	r24, Z+22	; 0x16
    7058:	80 93 e9 07 	sts	0x07E9, r24
    705c:	ea 81       	ldd	r30, Y+2	; 0x02
    705e:	fb 81       	ldd	r31, Y+3	; 0x03
    7060:	86 89       	ldd	r24, Z+22	; 0x16
    7062:	28 2f       	mov	r18, r24
    7064:	30 e0       	ldi	r19, 0x00	; 0
    7066:	c9 01       	movw	r24, r18
    7068:	88 0f       	add	r24, r24
    706a:	99 1f       	adc	r25, r25
    706c:	88 0f       	add	r24, r24
    706e:	99 1f       	adc	r25, r25
    7070:	88 0f       	add	r24, r24
    7072:	99 1f       	adc	r25, r25
    7074:	82 0f       	add	r24, r18
    7076:	93 1f       	adc	r25, r19
    7078:	ac 01       	movw	r20, r24
    707a:	40 51       	subi	r20, 0x10	; 16
    707c:	58 4f       	sbci	r21, 0xF8	; 248
    707e:	8a 81       	ldd	r24, Y+2	; 0x02
    7080:	9b 81       	ldd	r25, Y+3	; 0x03
    7082:	9c 01       	movw	r18, r24
    7084:	2e 5f       	subi	r18, 0xFE	; 254
    7086:	3f 4f       	sbci	r19, 0xFF	; 255
    7088:	ca 01       	movw	r24, r20
    708a:	b9 01       	movw	r22, r18
    708c:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>
    7090:	0a c0       	rjmp	.+20     	; 0x70a6 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    7092:	8a 81       	ldd	r24, Y+2	; 0x02
    7094:	9b 81       	ldd	r25, Y+3	; 0x03
    7096:	9c 01       	movw	r18, r24
    7098:	24 5f       	subi	r18, 0xF4	; 244
    709a:	3f 4f       	sbci	r19, 0xFF	; 255
    709c:	8c e3       	ldi	r24, 0x3C	; 60
    709e:	98 e0       	ldi	r25, 0x08	; 8
    70a0:	b9 01       	movw	r22, r18
    70a2:	0e 94 a5 29 	call	0x534a	; 0x534a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    70a6:	ea 81       	ldd	r30, Y+2	; 0x02
    70a8:	fb 81       	ldd	r31, Y+3	; 0x03
    70aa:	96 89       	ldd	r25, Z+22	; 0x16
    70ac:	e0 91 e2 07 	lds	r30, 0x07E2
    70b0:	f0 91 e3 07 	lds	r31, 0x07E3
    70b4:	86 89       	ldd	r24, Z+22	; 0x16
    70b6:	98 17       	cp	r25, r24
    70b8:	18 f0       	brcs	.+6      	; 0x70c0 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    70ba:	81 e0       	ldi	r24, 0x01	; 1
    70bc:	89 83       	std	Y+1, r24	; 0x01
    70be:	01 c0       	rjmp	.+2      	; 0x70c2 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    70c0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    70c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    70c4:	0f 90       	pop	r0
    70c6:	0f 90       	pop	r0
    70c8:	0f 90       	pop	r0
    70ca:	0f 90       	pop	r0
    70cc:	0f 90       	pop	r0
    70ce:	cf 91       	pop	r28
    70d0:	df 91       	pop	r29
    70d2:	08 95       	ret

000070d4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    70d4:	df 93       	push	r29
    70d6:	cf 93       	push	r28
    70d8:	00 d0       	rcall	.+0      	; 0x70da <vTaskSetTimeOutState+0x6>
    70da:	cd b7       	in	r28, 0x3d	; 61
    70dc:	de b7       	in	r29, 0x3e	; 62
    70de:	9a 83       	std	Y+2, r25	; 0x02
    70e0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    70e2:	80 91 ee 07 	lds	r24, 0x07EE
    70e6:	e9 81       	ldd	r30, Y+1	; 0x01
    70e8:	fa 81       	ldd	r31, Y+2	; 0x02
    70ea:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    70ec:	80 91 e6 07 	lds	r24, 0x07E6
    70f0:	90 91 e7 07 	lds	r25, 0x07E7
    70f4:	e9 81       	ldd	r30, Y+1	; 0x01
    70f6:	fa 81       	ldd	r31, Y+2	; 0x02
    70f8:	92 83       	std	Z+2, r25	; 0x02
    70fa:	81 83       	std	Z+1, r24	; 0x01
}
    70fc:	0f 90       	pop	r0
    70fe:	0f 90       	pop	r0
    7100:	cf 91       	pop	r28
    7102:	df 91       	pop	r29
    7104:	08 95       	ret

00007106 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    7106:	df 93       	push	r29
    7108:	cf 93       	push	r28
    710a:	00 d0       	rcall	.+0      	; 0x710c <xTaskCheckForTimeOut+0x6>
    710c:	00 d0       	rcall	.+0      	; 0x710e <xTaskCheckForTimeOut+0x8>
    710e:	0f 92       	push	r0
    7110:	cd b7       	in	r28, 0x3d	; 61
    7112:	de b7       	in	r29, 0x3e	; 62
    7114:	9b 83       	std	Y+3, r25	; 0x03
    7116:	8a 83       	std	Y+2, r24	; 0x02
    7118:	7d 83       	std	Y+5, r23	; 0x05
    711a:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    711c:	0f b6       	in	r0, 0x3f	; 63
    711e:	f8 94       	cli
    7120:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    7122:	ec 81       	ldd	r30, Y+4	; 0x04
    7124:	fd 81       	ldd	r31, Y+5	; 0x05
    7126:	80 81       	ld	r24, Z
    7128:	91 81       	ldd	r25, Z+1	; 0x01
    712a:	2f ef       	ldi	r18, 0xFF	; 255
    712c:	8f 3f       	cpi	r24, 0xFF	; 255
    712e:	92 07       	cpc	r25, r18
    7130:	11 f4       	brne	.+4      	; 0x7136 <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    7132:	19 82       	std	Y+1, r1	; 0x01
    7134:	44 c0       	rjmp	.+136    	; 0x71be <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    7136:	ea 81       	ldd	r30, Y+2	; 0x02
    7138:	fb 81       	ldd	r31, Y+3	; 0x03
    713a:	90 81       	ld	r25, Z
    713c:	80 91 ee 07 	lds	r24, 0x07EE
    7140:	98 17       	cp	r25, r24
    7142:	71 f0       	breq	.+28     	; 0x7160 <xTaskCheckForTimeOut+0x5a>
    7144:	ea 81       	ldd	r30, Y+2	; 0x02
    7146:	fb 81       	ldd	r31, Y+3	; 0x03
    7148:	21 81       	ldd	r18, Z+1	; 0x01
    714a:	32 81       	ldd	r19, Z+2	; 0x02
    714c:	80 91 e6 07 	lds	r24, 0x07E6
    7150:	90 91 e7 07 	lds	r25, 0x07E7
    7154:	82 17       	cp	r24, r18
    7156:	93 07       	cpc	r25, r19
    7158:	18 f0       	brcs	.+6      	; 0x7160 <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    715a:	81 e0       	ldi	r24, 0x01	; 1
    715c:	89 83       	std	Y+1, r24	; 0x01
    715e:	2f c0       	rjmp	.+94     	; 0x71be <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    7160:	20 91 e6 07 	lds	r18, 0x07E6
    7164:	30 91 e7 07 	lds	r19, 0x07E7
    7168:	ea 81       	ldd	r30, Y+2	; 0x02
    716a:	fb 81       	ldd	r31, Y+3	; 0x03
    716c:	81 81       	ldd	r24, Z+1	; 0x01
    716e:	92 81       	ldd	r25, Z+2	; 0x02
    7170:	28 1b       	sub	r18, r24
    7172:	39 0b       	sbc	r19, r25
    7174:	ec 81       	ldd	r30, Y+4	; 0x04
    7176:	fd 81       	ldd	r31, Y+5	; 0x05
    7178:	80 81       	ld	r24, Z
    717a:	91 81       	ldd	r25, Z+1	; 0x01
    717c:	28 17       	cp	r18, r24
    717e:	39 07       	cpc	r19, r25
    7180:	e0 f4       	brcc	.+56     	; 0x71ba <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    7182:	ec 81       	ldd	r30, Y+4	; 0x04
    7184:	fd 81       	ldd	r31, Y+5	; 0x05
    7186:	40 81       	ld	r20, Z
    7188:	51 81       	ldd	r21, Z+1	; 0x01
    718a:	ea 81       	ldd	r30, Y+2	; 0x02
    718c:	fb 81       	ldd	r31, Y+3	; 0x03
    718e:	21 81       	ldd	r18, Z+1	; 0x01
    7190:	32 81       	ldd	r19, Z+2	; 0x02
    7192:	80 91 e6 07 	lds	r24, 0x07E6
    7196:	90 91 e7 07 	lds	r25, 0x07E7
    719a:	b9 01       	movw	r22, r18
    719c:	68 1b       	sub	r22, r24
    719e:	79 0b       	sbc	r23, r25
    71a0:	cb 01       	movw	r24, r22
    71a2:	84 0f       	add	r24, r20
    71a4:	95 1f       	adc	r25, r21
    71a6:	ec 81       	ldd	r30, Y+4	; 0x04
    71a8:	fd 81       	ldd	r31, Y+5	; 0x05
    71aa:	91 83       	std	Z+1, r25	; 0x01
    71ac:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    71ae:	8a 81       	ldd	r24, Y+2	; 0x02
    71b0:	9b 81       	ldd	r25, Y+3	; 0x03
    71b2:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    71b6:	19 82       	std	Y+1, r1	; 0x01
    71b8:	02 c0       	rjmp	.+4      	; 0x71be <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    71ba:	81 e0       	ldi	r24, 0x01	; 1
    71bc:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    71be:	0f 90       	pop	r0
    71c0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    71c2:	89 81       	ldd	r24, Y+1	; 0x01
}
    71c4:	0f 90       	pop	r0
    71c6:	0f 90       	pop	r0
    71c8:	0f 90       	pop	r0
    71ca:	0f 90       	pop	r0
    71cc:	0f 90       	pop	r0
    71ce:	cf 91       	pop	r28
    71d0:	df 91       	pop	r29
    71d2:	08 95       	ret

000071d4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    71d4:	df 93       	push	r29
    71d6:	cf 93       	push	r28
    71d8:	cd b7       	in	r28, 0x3d	; 61
    71da:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    71dc:	81 e0       	ldi	r24, 0x01	; 1
    71de:	80 93 ed 07 	sts	0x07ED, r24
}
    71e2:	cf 91       	pop	r28
    71e4:	df 91       	pop	r29
    71e6:	08 95       	ret

000071e8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    71e8:	df 93       	push	r29
    71ea:	cf 93       	push	r28
    71ec:	00 d0       	rcall	.+0      	; 0x71ee <prvIdleTask+0x6>
    71ee:	cd b7       	in	r28, 0x3d	; 61
    71f0:	de b7       	in	r29, 0x3e	; 62
    71f2:	9a 83       	std	Y+2, r25	; 0x02
    71f4:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    71f6:	0e 94 96 39 	call	0x732c	; 0x732c <prvCheckTasksWaitingTermination>
    71fa:	fd cf       	rjmp	.-6      	; 0x71f6 <prvIdleTask+0xe>

000071fc <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    71fc:	0f 93       	push	r16
    71fe:	1f 93       	push	r17
    7200:	df 93       	push	r29
    7202:	cf 93       	push	r28
    7204:	cd b7       	in	r28, 0x3d	; 61
    7206:	de b7       	in	r29, 0x3e	; 62
    7208:	29 97       	sbiw	r28, 0x09	; 9
    720a:	0f b6       	in	r0, 0x3f	; 63
    720c:	f8 94       	cli
    720e:	de bf       	out	0x3e, r29	; 62
    7210:	0f be       	out	0x3f, r0	; 63
    7212:	cd bf       	out	0x3d, r28	; 61
    7214:	9a 83       	std	Y+2, r25	; 0x02
    7216:	89 83       	std	Y+1, r24	; 0x01
    7218:	7c 83       	std	Y+4, r23	; 0x04
    721a:	6b 83       	std	Y+3, r22	; 0x03
    721c:	4d 83       	std	Y+5, r20	; 0x05
    721e:	3f 83       	std	Y+7, r19	; 0x07
    7220:	2e 83       	std	Y+6, r18	; 0x06
    7222:	19 87       	std	Y+9, r17	; 0x09
    7224:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    7226:	89 81       	ldd	r24, Y+1	; 0x01
    7228:	9a 81       	ldd	r25, Y+2	; 0x02
    722a:	49 96       	adiw	r24, 0x19	; 25
    722c:	2b 81       	ldd	r18, Y+3	; 0x03
    722e:	3c 81       	ldd	r19, Y+4	; 0x04
    7230:	b9 01       	movw	r22, r18
    7232:	48 e0       	ldi	r20, 0x08	; 8
    7234:	50 e0       	ldi	r21, 0x00	; 0
    7236:	0e 94 28 3b 	call	0x7650	; 0x7650 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    723a:	e9 81       	ldd	r30, Y+1	; 0x01
    723c:	fa 81       	ldd	r31, Y+2	; 0x02
    723e:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    7240:	8d 81       	ldd	r24, Y+5	; 0x05
    7242:	86 30       	cpi	r24, 0x06	; 6
    7244:	10 f0       	brcs	.+4      	; 0x724a <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    7246:	85 e0       	ldi	r24, 0x05	; 5
    7248:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    724a:	e9 81       	ldd	r30, Y+1	; 0x01
    724c:	fa 81       	ldd	r31, Y+2	; 0x02
    724e:	8d 81       	ldd	r24, Y+5	; 0x05
    7250:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    7252:	89 81       	ldd	r24, Y+1	; 0x01
    7254:	9a 81       	ldd	r25, Y+2	; 0x02
    7256:	02 96       	adiw	r24, 0x02	; 2
    7258:	0e 94 95 29 	call	0x532a	; 0x532a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    725c:	89 81       	ldd	r24, Y+1	; 0x01
    725e:	9a 81       	ldd	r25, Y+2	; 0x02
    7260:	0c 96       	adiw	r24, 0x0c	; 12
    7262:	0e 94 95 29 	call	0x532a	; 0x532a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    7266:	e9 81       	ldd	r30, Y+1	; 0x01
    7268:	fa 81       	ldd	r31, Y+2	; 0x02
    726a:	89 81       	ldd	r24, Y+1	; 0x01
    726c:	9a 81       	ldd	r25, Y+2	; 0x02
    726e:	91 87       	std	Z+9, r25	; 0x09
    7270:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    7272:	8d 81       	ldd	r24, Y+5	; 0x05
    7274:	28 2f       	mov	r18, r24
    7276:	30 e0       	ldi	r19, 0x00	; 0
    7278:	86 e0       	ldi	r24, 0x06	; 6
    727a:	90 e0       	ldi	r25, 0x00	; 0
    727c:	82 1b       	sub	r24, r18
    727e:	93 0b       	sbc	r25, r19
    7280:	e9 81       	ldd	r30, Y+1	; 0x01
    7282:	fa 81       	ldd	r31, Y+2	; 0x02
    7284:	95 87       	std	Z+13, r25	; 0x0d
    7286:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    7288:	e9 81       	ldd	r30, Y+1	; 0x01
    728a:	fa 81       	ldd	r31, Y+2	; 0x02
    728c:	89 81       	ldd	r24, Y+1	; 0x01
    728e:	9a 81       	ldd	r25, Y+2	; 0x02
    7290:	93 8b       	std	Z+19, r25	; 0x13
    7292:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    7294:	29 96       	adiw	r28, 0x09	; 9
    7296:	0f b6       	in	r0, 0x3f	; 63
    7298:	f8 94       	cli
    729a:	de bf       	out	0x3e, r29	; 62
    729c:	0f be       	out	0x3f, r0	; 63
    729e:	cd bf       	out	0x3d, r28	; 61
    72a0:	cf 91       	pop	r28
    72a2:	df 91       	pop	r29
    72a4:	1f 91       	pop	r17
    72a6:	0f 91       	pop	r16
    72a8:	08 95       	ret

000072aa <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    72aa:	df 93       	push	r29
    72ac:	cf 93       	push	r28
    72ae:	0f 92       	push	r0
    72b0:	cd b7       	in	r28, 0x3d	; 61
    72b2:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    72b4:	19 82       	std	Y+1, r1	; 0x01
    72b6:	13 c0       	rjmp	.+38     	; 0x72de <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    72b8:	89 81       	ldd	r24, Y+1	; 0x01
    72ba:	28 2f       	mov	r18, r24
    72bc:	30 e0       	ldi	r19, 0x00	; 0
    72be:	c9 01       	movw	r24, r18
    72c0:	88 0f       	add	r24, r24
    72c2:	99 1f       	adc	r25, r25
    72c4:	88 0f       	add	r24, r24
    72c6:	99 1f       	adc	r25, r25
    72c8:	88 0f       	add	r24, r24
    72ca:	99 1f       	adc	r25, r25
    72cc:	82 0f       	add	r24, r18
    72ce:	93 1f       	adc	r25, r19
    72d0:	80 51       	subi	r24, 0x10	; 16
    72d2:	98 4f       	sbci	r25, 0xF8	; 248
    72d4:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    72d8:	89 81       	ldd	r24, Y+1	; 0x01
    72da:	8f 5f       	subi	r24, 0xFF	; 255
    72dc:	89 83       	std	Y+1, r24	; 0x01
    72de:	89 81       	ldd	r24, Y+1	; 0x01
    72e0:	86 30       	cpi	r24, 0x06	; 6
    72e2:	50 f3       	brcs	.-44     	; 0x72b8 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    72e4:	86 e2       	ldi	r24, 0x26	; 38
    72e6:	98 e0       	ldi	r25, 0x08	; 8
    72e8:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    72ec:	8f e2       	ldi	r24, 0x2F	; 47
    72ee:	98 e0       	ldi	r25, 0x08	; 8
    72f0:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    72f4:	8c e3       	ldi	r24, 0x3C	; 60
    72f6:	98 e0       	ldi	r25, 0x08	; 8
    72f8:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    72fc:	85 e4       	ldi	r24, 0x45	; 69
    72fe:	98 e0       	ldi	r25, 0x08	; 8
    7300:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    7304:	8e e4       	ldi	r24, 0x4E	; 78
    7306:	98 e0       	ldi	r25, 0x08	; 8
    7308:	0e 94 6b 29 	call	0x52d6	; 0x52d6 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    730c:	86 e2       	ldi	r24, 0x26	; 38
    730e:	98 e0       	ldi	r25, 0x08	; 8
    7310:	90 93 39 08 	sts	0x0839, r25
    7314:	80 93 38 08 	sts	0x0838, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    7318:	8f e2       	ldi	r24, 0x2F	; 47
    731a:	98 e0       	ldi	r25, 0x08	; 8
    731c:	90 93 3b 08 	sts	0x083B, r25
    7320:	80 93 3a 08 	sts	0x083A, r24
}
    7324:	0f 90       	pop	r0
    7326:	cf 91       	pop	r28
    7328:	df 91       	pop	r29
    732a:	08 95       	ret

0000732c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    732c:	df 93       	push	r29
    732e:	cf 93       	push	r28
    7330:	00 d0       	rcall	.+0      	; 0x7332 <prvCheckTasksWaitingTermination+0x6>
    7332:	0f 92       	push	r0
    7334:	cd b7       	in	r28, 0x3d	; 61
    7336:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    7338:	80 91 e4 07 	lds	r24, 0x07E4
    733c:	88 23       	and	r24, r24
    733e:	71 f1       	breq	.+92     	; 0x739c <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    7340:	0e 94 b3 35 	call	0x6b66	; 0x6b66 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    7344:	80 91 45 08 	lds	r24, 0x0845
    7348:	1b 82       	std	Y+3, r1	; 0x03
    734a:	88 23       	and	r24, r24
    734c:	11 f4       	brne	.+4      	; 0x7352 <prvCheckTasksWaitingTermination+0x26>
    734e:	81 e0       	ldi	r24, 0x01	; 1
    7350:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    7352:	0e 94 bf 35 	call	0x6b7e	; 0x6b7e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    7356:	8b 81       	ldd	r24, Y+3	; 0x03
    7358:	88 23       	and	r24, r24
    735a:	01 f5       	brne	.+64     	; 0x739c <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    735c:	0f b6       	in	r0, 0x3f	; 63
    735e:	f8 94       	cli
    7360:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    7362:	e0 91 4a 08 	lds	r30, 0x084A
    7366:	f0 91 4b 08 	lds	r31, 0x084B
    736a:	86 81       	ldd	r24, Z+6	; 0x06
    736c:	97 81       	ldd	r25, Z+7	; 0x07
    736e:	9a 83       	std	Y+2, r25	; 0x02
    7370:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    7372:	89 81       	ldd	r24, Y+1	; 0x01
    7374:	9a 81       	ldd	r25, Y+2	; 0x02
    7376:	02 96       	adiw	r24, 0x02	; 2
    7378:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <vListRemove>
					--uxCurrentNumberOfTasks;
    737c:	80 91 e5 07 	lds	r24, 0x07E5
    7380:	81 50       	subi	r24, 0x01	; 1
    7382:	80 93 e5 07 	sts	0x07E5, r24
					--uxTasksDeleted;
    7386:	80 91 e4 07 	lds	r24, 0x07E4
    738a:	81 50       	subi	r24, 0x01	; 1
    738c:	80 93 e4 07 	sts	0x07E4, r24
				}
				taskEXIT_CRITICAL();
    7390:	0f 90       	pop	r0
    7392:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    7394:	89 81       	ldd	r24, Y+1	; 0x01
    7396:	9a 81       	ldd	r25, Y+2	; 0x02
    7398:	0e 94 6d 3a 	call	0x74da	; 0x74da <prvDeleteTCB>
			}
		}
	}
	#endif
}
    739c:	0f 90       	pop	r0
    739e:	0f 90       	pop	r0
    73a0:	0f 90       	pop	r0
    73a2:	cf 91       	pop	r28
    73a4:	df 91       	pop	r29
    73a6:	08 95       	ret

000073a8 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    73a8:	df 93       	push	r29
    73aa:	cf 93       	push	r28
    73ac:	00 d0       	rcall	.+0      	; 0x73ae <prvAddCurrentTaskToDelayedList+0x6>
    73ae:	cd b7       	in	r28, 0x3d	; 61
    73b0:	de b7       	in	r29, 0x3e	; 62
    73b2:	9a 83       	std	Y+2, r25	; 0x02
    73b4:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    73b6:	e0 91 e2 07 	lds	r30, 0x07E2
    73ba:	f0 91 e3 07 	lds	r31, 0x07E3
    73be:	89 81       	ldd	r24, Y+1	; 0x01
    73c0:	9a 81       	ldd	r25, Y+2	; 0x02
    73c2:	93 83       	std	Z+3, r25	; 0x03
    73c4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    73c6:	20 91 e6 07 	lds	r18, 0x07E6
    73ca:	30 91 e7 07 	lds	r19, 0x07E7
    73ce:	89 81       	ldd	r24, Y+1	; 0x01
    73d0:	9a 81       	ldd	r25, Y+2	; 0x02
    73d2:	82 17       	cp	r24, r18
    73d4:	93 07       	cpc	r25, r19
    73d6:	70 f4       	brcc	.+28     	; 0x73f4 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    73d8:	80 91 3a 08 	lds	r24, 0x083A
    73dc:	90 91 3b 08 	lds	r25, 0x083B
    73e0:	20 91 e2 07 	lds	r18, 0x07E2
    73e4:	30 91 e3 07 	lds	r19, 0x07E3
    73e8:	2e 5f       	subi	r18, 0xFE	; 254
    73ea:	3f 4f       	sbci	r19, 0xFF	; 255
    73ec:	b9 01       	movw	r22, r18
    73ee:	0e 94 f1 29 	call	0x53e2	; 0x53e2 <vListInsert>
    73f2:	1e c0       	rjmp	.+60     	; 0x7430 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    73f4:	40 91 38 08 	lds	r20, 0x0838
    73f8:	50 91 39 08 	lds	r21, 0x0839
    73fc:	80 91 e2 07 	lds	r24, 0x07E2
    7400:	90 91 e3 07 	lds	r25, 0x07E3
    7404:	9c 01       	movw	r18, r24
    7406:	2e 5f       	subi	r18, 0xFE	; 254
    7408:	3f 4f       	sbci	r19, 0xFF	; 255
    740a:	ca 01       	movw	r24, r20
    740c:	b9 01       	movw	r22, r18
    740e:	0e 94 f1 29 	call	0x53e2	; 0x53e2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    7412:	20 91 70 01 	lds	r18, 0x0170
    7416:	30 91 71 01 	lds	r19, 0x0171
    741a:	89 81       	ldd	r24, Y+1	; 0x01
    741c:	9a 81       	ldd	r25, Y+2	; 0x02
    741e:	82 17       	cp	r24, r18
    7420:	93 07       	cpc	r25, r19
    7422:	30 f4       	brcc	.+12     	; 0x7430 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    7424:	89 81       	ldd	r24, Y+1	; 0x01
    7426:	9a 81       	ldd	r25, Y+2	; 0x02
    7428:	90 93 71 01 	sts	0x0171, r25
    742c:	80 93 70 01 	sts	0x0170, r24
		}
	}
}
    7430:	0f 90       	pop	r0
    7432:	0f 90       	pop	r0
    7434:	cf 91       	pop	r28
    7436:	df 91       	pop	r29
    7438:	08 95       	ret

0000743a <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    743a:	df 93       	push	r29
    743c:	cf 93       	push	r28
    743e:	cd b7       	in	r28, 0x3d	; 61
    7440:	de b7       	in	r29, 0x3e	; 62
    7442:	28 97       	sbiw	r28, 0x08	; 8
    7444:	0f b6       	in	r0, 0x3f	; 63
    7446:	f8 94       	cli
    7448:	de bf       	out	0x3e, r29	; 62
    744a:	0f be       	out	0x3f, r0	; 63
    744c:	cd bf       	out	0x3d, r28	; 61
    744e:	9c 83       	std	Y+4, r25	; 0x04
    7450:	8b 83       	std	Y+3, r24	; 0x03
    7452:	7e 83       	std	Y+6, r23	; 0x06
    7454:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    7456:	81 e2       	ldi	r24, 0x21	; 33
    7458:	90 e0       	ldi	r25, 0x00	; 0
    745a:	0e 94 ff 28 	call	0x51fe	; 0x51fe <pvPortMalloc>
    745e:	9a 83       	std	Y+2, r25	; 0x02
    7460:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    7462:	89 81       	ldd	r24, Y+1	; 0x01
    7464:	9a 81       	ldd	r25, Y+2	; 0x02
    7466:	00 97       	sbiw	r24, 0x00	; 0
    7468:	69 f1       	breq	.+90     	; 0x74c4 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    746a:	8d 81       	ldd	r24, Y+5	; 0x05
    746c:	9e 81       	ldd	r25, Y+6	; 0x06
    746e:	00 97       	sbiw	r24, 0x00	; 0
    7470:	39 f4       	brne	.+14     	; 0x7480 <prvAllocateTCBAndStack+0x46>
    7472:	8b 81       	ldd	r24, Y+3	; 0x03
    7474:	9c 81       	ldd	r25, Y+4	; 0x04
    7476:	0e 94 ff 28 	call	0x51fe	; 0x51fe <pvPortMalloc>
    747a:	98 87       	std	Y+8, r25	; 0x08
    747c:	8f 83       	std	Y+7, r24	; 0x07
    747e:	04 c0       	rjmp	.+8      	; 0x7488 <prvAllocateTCBAndStack+0x4e>
    7480:	8d 81       	ldd	r24, Y+5	; 0x05
    7482:	9e 81       	ldd	r25, Y+6	; 0x06
    7484:	98 87       	std	Y+8, r25	; 0x08
    7486:	8f 83       	std	Y+7, r24	; 0x07
    7488:	e9 81       	ldd	r30, Y+1	; 0x01
    748a:	fa 81       	ldd	r31, Y+2	; 0x02
    748c:	8f 81       	ldd	r24, Y+7	; 0x07
    748e:	98 85       	ldd	r25, Y+8	; 0x08
    7490:	90 8f       	std	Z+24, r25	; 0x18
    7492:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    7494:	e9 81       	ldd	r30, Y+1	; 0x01
    7496:	fa 81       	ldd	r31, Y+2	; 0x02
    7498:	87 89       	ldd	r24, Z+23	; 0x17
    749a:	90 8d       	ldd	r25, Z+24	; 0x18
    749c:	00 97       	sbiw	r24, 0x00	; 0
    749e:	39 f4       	brne	.+14     	; 0x74ae <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    74a0:	89 81       	ldd	r24, Y+1	; 0x01
    74a2:	9a 81       	ldd	r25, Y+2	; 0x02
    74a4:	0e 94 45 29 	call	0x528a	; 0x528a <vPortFree>
			pxNewTCB = NULL;
    74a8:	1a 82       	std	Y+2, r1	; 0x02
    74aa:	19 82       	std	Y+1, r1	; 0x01
    74ac:	0b c0       	rjmp	.+22     	; 0x74c4 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    74ae:	e9 81       	ldd	r30, Y+1	; 0x01
    74b0:	fa 81       	ldd	r31, Y+2	; 0x02
    74b2:	87 89       	ldd	r24, Z+23	; 0x17
    74b4:	90 8d       	ldd	r25, Z+24	; 0x18
    74b6:	2b 81       	ldd	r18, Y+3	; 0x03
    74b8:	3c 81       	ldd	r19, Y+4	; 0x04
    74ba:	65 ea       	ldi	r22, 0xA5	; 165
    74bc:	70 e0       	ldi	r23, 0x00	; 0
    74be:	a9 01       	movw	r20, r18
    74c0:	0e 94 21 3b 	call	0x7642	; 0x7642 <memset>
		}
	}

	return pxNewTCB;
    74c4:	89 81       	ldd	r24, Y+1	; 0x01
    74c6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    74c8:	28 96       	adiw	r28, 0x08	; 8
    74ca:	0f b6       	in	r0, 0x3f	; 63
    74cc:	f8 94       	cli
    74ce:	de bf       	out	0x3e, r29	; 62
    74d0:	0f be       	out	0x3f, r0	; 63
    74d2:	cd bf       	out	0x3d, r28	; 61
    74d4:	cf 91       	pop	r28
    74d6:	df 91       	pop	r29
    74d8:	08 95       	ret

000074da <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    74da:	df 93       	push	r29
    74dc:	cf 93       	push	r28
    74de:	00 d0       	rcall	.+0      	; 0x74e0 <prvDeleteTCB+0x6>
    74e0:	cd b7       	in	r28, 0x3d	; 61
    74e2:	de b7       	in	r29, 0x3e	; 62
    74e4:	9a 83       	std	Y+2, r25	; 0x02
    74e6:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    74e8:	e9 81       	ldd	r30, Y+1	; 0x01
    74ea:	fa 81       	ldd	r31, Y+2	; 0x02
    74ec:	87 89       	ldd	r24, Z+23	; 0x17
    74ee:	90 8d       	ldd	r25, Z+24	; 0x18
    74f0:	0e 94 45 29 	call	0x528a	; 0x528a <vPortFree>
		vPortFree( pxTCB );
    74f4:	89 81       	ldd	r24, Y+1	; 0x01
    74f6:	9a 81       	ldd	r25, Y+2	; 0x02
    74f8:	0e 94 45 29 	call	0x528a	; 0x528a <vPortFree>
	}
    74fc:	0f 90       	pop	r0
    74fe:	0f 90       	pop	r0
    7500:	cf 91       	pop	r28
    7502:	df 91       	pop	r29
    7504:	08 95       	ret

00007506 <main>:
#define F_CPU (16000000ULL)


u8 str[10];

int main(){
    7506:	df 93       	push	r29
    7508:	cf 93       	push	r28
    750a:	cd b7       	in	r28, 0x3d	; 61
    750c:	de b7       	in	r29, 0x3e	; 62
	/**** MCAL Initializations ****/

	/**** HAL Initializations ****/
	LCD_voidInit();
    750e:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <LCD_voidInit>

	/*** APP ***/
	sprintf(str, "%g", 123.456);
    7512:	8d b7       	in	r24, 0x3d	; 61
    7514:	9e b7       	in	r25, 0x3e	; 62
    7516:	08 97       	sbiw	r24, 0x08	; 8
    7518:	0f b6       	in	r0, 0x3f	; 63
    751a:	f8 94       	cli
    751c:	9e bf       	out	0x3e, r25	; 62
    751e:	0f be       	out	0x3f, r0	; 63
    7520:	8d bf       	out	0x3d, r24	; 61
    7522:	ed b7       	in	r30, 0x3d	; 61
    7524:	fe b7       	in	r31, 0x3e	; 62
    7526:	31 96       	adiw	r30, 0x01	; 1
    7528:	87 e5       	ldi	r24, 0x57	; 87
    752a:	98 e0       	ldi	r25, 0x08	; 8
    752c:	91 83       	std	Z+1, r25	; 0x01
    752e:	80 83       	st	Z, r24
    7530:	85 e6       	ldi	r24, 0x65	; 101
    7532:	90 e0       	ldi	r25, 0x00	; 0
    7534:	93 83       	std	Z+3, r25	; 0x03
    7536:	82 83       	std	Z+2, r24	; 0x02
    7538:	89 e7       	ldi	r24, 0x79	; 121
    753a:	99 ee       	ldi	r25, 0xE9	; 233
    753c:	a6 ef       	ldi	r26, 0xF6	; 246
    753e:	b2 e4       	ldi	r27, 0x42	; 66
    7540:	84 83       	std	Z+4, r24	; 0x04
    7542:	95 83       	std	Z+5, r25	; 0x05
    7544:	a6 83       	std	Z+6, r26	; 0x06
    7546:	b7 83       	std	Z+7, r27	; 0x07
    7548:	0e 94 37 3b 	call	0x766e	; 0x766e <sprintf>
    754c:	8d b7       	in	r24, 0x3d	; 61
    754e:	9e b7       	in	r25, 0x3e	; 62
    7550:	08 96       	adiw	r24, 0x08	; 8
    7552:	0f b6       	in	r0, 0x3f	; 63
    7554:	f8 94       	cli
    7556:	9e bf       	out	0x3e, r25	; 62
    7558:	0f be       	out	0x3f, r0	; 63
    755a:	8d bf       	out	0x3d, r24	; 61
	LCD_voidWriteString(str);
    755c:	87 e5       	ldi	r24, 0x57	; 87
    755e:	98 e0       	ldi	r25, 0x08	; 8
    7560:	0e 94 39 22 	call	0x4472	; 0x4472 <LCD_voidWriteString>
    7564:	ff cf       	rjmp	.-2      	; 0x7564 <main+0x5e>

00007566 <__udivmodqi4>:
    7566:	99 1b       	sub	r25, r25
    7568:	79 e0       	ldi	r23, 0x09	; 9
    756a:	04 c0       	rjmp	.+8      	; 0x7574 <__udivmodqi4_ep>

0000756c <__udivmodqi4_loop>:
    756c:	99 1f       	adc	r25, r25
    756e:	96 17       	cp	r25, r22
    7570:	08 f0       	brcs	.+2      	; 0x7574 <__udivmodqi4_ep>
    7572:	96 1b       	sub	r25, r22

00007574 <__udivmodqi4_ep>:
    7574:	88 1f       	adc	r24, r24
    7576:	7a 95       	dec	r23
    7578:	c9 f7       	brne	.-14     	; 0x756c <__udivmodqi4_loop>
    757a:	80 95       	com	r24
    757c:	08 95       	ret

0000757e <__udivmodsi4>:
    757e:	a1 e2       	ldi	r26, 0x21	; 33
    7580:	1a 2e       	mov	r1, r26
    7582:	aa 1b       	sub	r26, r26
    7584:	bb 1b       	sub	r27, r27
    7586:	fd 01       	movw	r30, r26
    7588:	0d c0       	rjmp	.+26     	; 0x75a4 <__udivmodsi4_ep>

0000758a <__udivmodsi4_loop>:
    758a:	aa 1f       	adc	r26, r26
    758c:	bb 1f       	adc	r27, r27
    758e:	ee 1f       	adc	r30, r30
    7590:	ff 1f       	adc	r31, r31
    7592:	a2 17       	cp	r26, r18
    7594:	b3 07       	cpc	r27, r19
    7596:	e4 07       	cpc	r30, r20
    7598:	f5 07       	cpc	r31, r21
    759a:	20 f0       	brcs	.+8      	; 0x75a4 <__udivmodsi4_ep>
    759c:	a2 1b       	sub	r26, r18
    759e:	b3 0b       	sbc	r27, r19
    75a0:	e4 0b       	sbc	r30, r20
    75a2:	f5 0b       	sbc	r31, r21

000075a4 <__udivmodsi4_ep>:
    75a4:	66 1f       	adc	r22, r22
    75a6:	77 1f       	adc	r23, r23
    75a8:	88 1f       	adc	r24, r24
    75aa:	99 1f       	adc	r25, r25
    75ac:	1a 94       	dec	r1
    75ae:	69 f7       	brne	.-38     	; 0x758a <__udivmodsi4_loop>
    75b0:	60 95       	com	r22
    75b2:	70 95       	com	r23
    75b4:	80 95       	com	r24
    75b6:	90 95       	com	r25
    75b8:	9b 01       	movw	r18, r22
    75ba:	ac 01       	movw	r20, r24
    75bc:	bd 01       	movw	r22, r26
    75be:	cf 01       	movw	r24, r30
    75c0:	08 95       	ret

000075c2 <__prologue_saves__>:
    75c2:	2f 92       	push	r2
    75c4:	3f 92       	push	r3
    75c6:	4f 92       	push	r4
    75c8:	5f 92       	push	r5
    75ca:	6f 92       	push	r6
    75cc:	7f 92       	push	r7
    75ce:	8f 92       	push	r8
    75d0:	9f 92       	push	r9
    75d2:	af 92       	push	r10
    75d4:	bf 92       	push	r11
    75d6:	cf 92       	push	r12
    75d8:	df 92       	push	r13
    75da:	ef 92       	push	r14
    75dc:	ff 92       	push	r15
    75de:	0f 93       	push	r16
    75e0:	1f 93       	push	r17
    75e2:	cf 93       	push	r28
    75e4:	df 93       	push	r29
    75e6:	cd b7       	in	r28, 0x3d	; 61
    75e8:	de b7       	in	r29, 0x3e	; 62
    75ea:	ca 1b       	sub	r28, r26
    75ec:	db 0b       	sbc	r29, r27
    75ee:	0f b6       	in	r0, 0x3f	; 63
    75f0:	f8 94       	cli
    75f2:	de bf       	out	0x3e, r29	; 62
    75f4:	0f be       	out	0x3f, r0	; 63
    75f6:	cd bf       	out	0x3d, r28	; 61
    75f8:	09 94       	ijmp

000075fa <__epilogue_restores__>:
    75fa:	2a 88       	ldd	r2, Y+18	; 0x12
    75fc:	39 88       	ldd	r3, Y+17	; 0x11
    75fe:	48 88       	ldd	r4, Y+16	; 0x10
    7600:	5f 84       	ldd	r5, Y+15	; 0x0f
    7602:	6e 84       	ldd	r6, Y+14	; 0x0e
    7604:	7d 84       	ldd	r7, Y+13	; 0x0d
    7606:	8c 84       	ldd	r8, Y+12	; 0x0c
    7608:	9b 84       	ldd	r9, Y+11	; 0x0b
    760a:	aa 84       	ldd	r10, Y+10	; 0x0a
    760c:	b9 84       	ldd	r11, Y+9	; 0x09
    760e:	c8 84       	ldd	r12, Y+8	; 0x08
    7610:	df 80       	ldd	r13, Y+7	; 0x07
    7612:	ee 80       	ldd	r14, Y+6	; 0x06
    7614:	fd 80       	ldd	r15, Y+5	; 0x05
    7616:	0c 81       	ldd	r16, Y+4	; 0x04
    7618:	1b 81       	ldd	r17, Y+3	; 0x03
    761a:	aa 81       	ldd	r26, Y+2	; 0x02
    761c:	b9 81       	ldd	r27, Y+1	; 0x01
    761e:	ce 0f       	add	r28, r30
    7620:	d1 1d       	adc	r29, r1
    7622:	0f b6       	in	r0, 0x3f	; 63
    7624:	f8 94       	cli
    7626:	de bf       	out	0x3e, r29	; 62
    7628:	0f be       	out	0x3f, r0	; 63
    762a:	cd bf       	out	0x3d, r28	; 61
    762c:	ed 01       	movw	r28, r26
    762e:	08 95       	ret

00007630 <memcpy>:
    7630:	fb 01       	movw	r30, r22
    7632:	dc 01       	movw	r26, r24
    7634:	02 c0       	rjmp	.+4      	; 0x763a <memcpy+0xa>
    7636:	01 90       	ld	r0, Z+
    7638:	0d 92       	st	X+, r0
    763a:	41 50       	subi	r20, 0x01	; 1
    763c:	50 40       	sbci	r21, 0x00	; 0
    763e:	d8 f7       	brcc	.-10     	; 0x7636 <memcpy+0x6>
    7640:	08 95       	ret

00007642 <memset>:
    7642:	dc 01       	movw	r26, r24
    7644:	01 c0       	rjmp	.+2      	; 0x7648 <memset+0x6>
    7646:	6d 93       	st	X+, r22
    7648:	41 50       	subi	r20, 0x01	; 1
    764a:	50 40       	sbci	r21, 0x00	; 0
    764c:	e0 f7       	brcc	.-8      	; 0x7646 <memset+0x4>
    764e:	08 95       	ret

00007650 <strncpy>:
    7650:	fb 01       	movw	r30, r22
    7652:	dc 01       	movw	r26, r24
    7654:	41 50       	subi	r20, 0x01	; 1
    7656:	50 40       	sbci	r21, 0x00	; 0
    7658:	48 f0       	brcs	.+18     	; 0x766c <strncpy+0x1c>
    765a:	01 90       	ld	r0, Z+
    765c:	0d 92       	st	X+, r0
    765e:	00 20       	and	r0, r0
    7660:	c9 f7       	brne	.-14     	; 0x7654 <strncpy+0x4>
    7662:	01 c0       	rjmp	.+2      	; 0x7666 <strncpy+0x16>
    7664:	1d 92       	st	X+, r1
    7666:	41 50       	subi	r20, 0x01	; 1
    7668:	50 40       	sbci	r21, 0x00	; 0
    766a:	e0 f7       	brcc	.-8      	; 0x7664 <strncpy+0x14>
    766c:	08 95       	ret

0000766e <sprintf>:
    766e:	ae e0       	ldi	r26, 0x0E	; 14
    7670:	b0 e0       	ldi	r27, 0x00	; 0
    7672:	ed e3       	ldi	r30, 0x3D	; 61
    7674:	fb e3       	ldi	r31, 0x3B	; 59
    7676:	0c 94 ef 3a 	jmp	0x75de	; 0x75de <__prologue_saves__+0x1c>
    767a:	0d 89       	ldd	r16, Y+21	; 0x15
    767c:	1e 89       	ldd	r17, Y+22	; 0x16
    767e:	86 e0       	ldi	r24, 0x06	; 6
    7680:	8c 83       	std	Y+4, r24	; 0x04
    7682:	1a 83       	std	Y+2, r17	; 0x02
    7684:	09 83       	std	Y+1, r16	; 0x01
    7686:	8f ef       	ldi	r24, 0xFF	; 255
    7688:	9f e7       	ldi	r25, 0x7F	; 127
    768a:	9e 83       	std	Y+6, r25	; 0x06
    768c:	8d 83       	std	Y+5, r24	; 0x05
    768e:	9e 01       	movw	r18, r28
    7690:	27 5e       	subi	r18, 0xE7	; 231
    7692:	3f 4f       	sbci	r19, 0xFF	; 255
    7694:	ce 01       	movw	r24, r28
    7696:	01 96       	adiw	r24, 0x01	; 1
    7698:	6f 89       	ldd	r22, Y+23	; 0x17
    769a:	78 8d       	ldd	r23, Y+24	; 0x18
    769c:	a9 01       	movw	r20, r18
    769e:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <vfprintf>
    76a2:	2f 81       	ldd	r18, Y+7	; 0x07
    76a4:	38 85       	ldd	r19, Y+8	; 0x08
    76a6:	02 0f       	add	r16, r18
    76a8:	13 1f       	adc	r17, r19
    76aa:	f8 01       	movw	r30, r16
    76ac:	10 82       	st	Z, r1
    76ae:	2e 96       	adiw	r28, 0x0e	; 14
    76b0:	e4 e0       	ldi	r30, 0x04	; 4
    76b2:	0c 94 0b 3b 	jmp	0x7616	; 0x7616 <__epilogue_restores__+0x1c>

000076b6 <vfprintf>:
    76b6:	ab e0       	ldi	r26, 0x0B	; 11
    76b8:	b0 e0       	ldi	r27, 0x00	; 0
    76ba:	e1 e6       	ldi	r30, 0x61	; 97
    76bc:	fb e3       	ldi	r31, 0x3B	; 59
    76be:	0c 94 e1 3a 	jmp	0x75c2	; 0x75c2 <__prologue_saves__>
    76c2:	3c 01       	movw	r6, r24
    76c4:	2b 01       	movw	r4, r22
    76c6:	5a 01       	movw	r10, r20
    76c8:	fc 01       	movw	r30, r24
    76ca:	17 82       	std	Z+7, r1	; 0x07
    76cc:	16 82       	std	Z+6, r1	; 0x06
    76ce:	83 81       	ldd	r24, Z+3	; 0x03
    76d0:	81 fd       	sbrc	r24, 1
    76d2:	03 c0       	rjmp	.+6      	; 0x76da <vfprintf+0x24>
    76d4:	6f ef       	ldi	r22, 0xFF	; 255
    76d6:	7f ef       	ldi	r23, 0xFF	; 255
    76d8:	c6 c1       	rjmp	.+908    	; 0x7a66 <vfprintf+0x3b0>
    76da:	9a e0       	ldi	r25, 0x0A	; 10
    76dc:	89 2e       	mov	r8, r25
    76de:	1e 01       	movw	r2, r28
    76e0:	08 94       	sec
    76e2:	21 1c       	adc	r2, r1
    76e4:	31 1c       	adc	r3, r1
    76e6:	f3 01       	movw	r30, r6
    76e8:	23 81       	ldd	r18, Z+3	; 0x03
    76ea:	f2 01       	movw	r30, r4
    76ec:	23 fd       	sbrc	r18, 3
    76ee:	85 91       	lpm	r24, Z+
    76f0:	23 ff       	sbrs	r18, 3
    76f2:	81 91       	ld	r24, Z+
    76f4:	2f 01       	movw	r4, r30
    76f6:	88 23       	and	r24, r24
    76f8:	09 f4       	brne	.+2      	; 0x76fc <vfprintf+0x46>
    76fa:	b2 c1       	rjmp	.+868    	; 0x7a60 <vfprintf+0x3aa>
    76fc:	85 32       	cpi	r24, 0x25	; 37
    76fe:	39 f4       	brne	.+14     	; 0x770e <vfprintf+0x58>
    7700:	23 fd       	sbrc	r18, 3
    7702:	85 91       	lpm	r24, Z+
    7704:	23 ff       	sbrs	r18, 3
    7706:	81 91       	ld	r24, Z+
    7708:	2f 01       	movw	r4, r30
    770a:	85 32       	cpi	r24, 0x25	; 37
    770c:	29 f4       	brne	.+10     	; 0x7718 <vfprintf+0x62>
    770e:	90 e0       	ldi	r25, 0x00	; 0
    7710:	b3 01       	movw	r22, r6
    7712:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <fputc>
    7716:	e7 cf       	rjmp	.-50     	; 0x76e6 <vfprintf+0x30>
    7718:	98 2f       	mov	r25, r24
    771a:	ff 24       	eor	r15, r15
    771c:	ee 24       	eor	r14, r14
    771e:	99 24       	eor	r9, r9
    7720:	ff e1       	ldi	r31, 0x1F	; 31
    7722:	ff 15       	cp	r31, r15
    7724:	d0 f0       	brcs	.+52     	; 0x775a <vfprintf+0xa4>
    7726:	9b 32       	cpi	r25, 0x2B	; 43
    7728:	69 f0       	breq	.+26     	; 0x7744 <vfprintf+0x8e>
    772a:	9c 32       	cpi	r25, 0x2C	; 44
    772c:	28 f4       	brcc	.+10     	; 0x7738 <vfprintf+0x82>
    772e:	90 32       	cpi	r25, 0x20	; 32
    7730:	59 f0       	breq	.+22     	; 0x7748 <vfprintf+0x92>
    7732:	93 32       	cpi	r25, 0x23	; 35
    7734:	91 f4       	brne	.+36     	; 0x775a <vfprintf+0xa4>
    7736:	0e c0       	rjmp	.+28     	; 0x7754 <vfprintf+0x9e>
    7738:	9d 32       	cpi	r25, 0x2D	; 45
    773a:	49 f0       	breq	.+18     	; 0x774e <vfprintf+0x98>
    773c:	90 33       	cpi	r25, 0x30	; 48
    773e:	69 f4       	brne	.+26     	; 0x775a <vfprintf+0xa4>
    7740:	41 e0       	ldi	r20, 0x01	; 1
    7742:	24 c0       	rjmp	.+72     	; 0x778c <vfprintf+0xd6>
    7744:	52 e0       	ldi	r21, 0x02	; 2
    7746:	f5 2a       	or	r15, r21
    7748:	84 e0       	ldi	r24, 0x04	; 4
    774a:	f8 2a       	or	r15, r24
    774c:	28 c0       	rjmp	.+80     	; 0x779e <vfprintf+0xe8>
    774e:	98 e0       	ldi	r25, 0x08	; 8
    7750:	f9 2a       	or	r15, r25
    7752:	25 c0       	rjmp	.+74     	; 0x779e <vfprintf+0xe8>
    7754:	e0 e1       	ldi	r30, 0x10	; 16
    7756:	fe 2a       	or	r15, r30
    7758:	22 c0       	rjmp	.+68     	; 0x779e <vfprintf+0xe8>
    775a:	f7 fc       	sbrc	r15, 7
    775c:	29 c0       	rjmp	.+82     	; 0x77b0 <vfprintf+0xfa>
    775e:	89 2f       	mov	r24, r25
    7760:	80 53       	subi	r24, 0x30	; 48
    7762:	8a 30       	cpi	r24, 0x0A	; 10
    7764:	70 f4       	brcc	.+28     	; 0x7782 <vfprintf+0xcc>
    7766:	f6 fe       	sbrs	r15, 6
    7768:	05 c0       	rjmp	.+10     	; 0x7774 <vfprintf+0xbe>
    776a:	98 9c       	mul	r9, r8
    776c:	90 2c       	mov	r9, r0
    776e:	11 24       	eor	r1, r1
    7770:	98 0e       	add	r9, r24
    7772:	15 c0       	rjmp	.+42     	; 0x779e <vfprintf+0xe8>
    7774:	e8 9c       	mul	r14, r8
    7776:	e0 2c       	mov	r14, r0
    7778:	11 24       	eor	r1, r1
    777a:	e8 0e       	add	r14, r24
    777c:	f0 e2       	ldi	r31, 0x20	; 32
    777e:	ff 2a       	or	r15, r31
    7780:	0e c0       	rjmp	.+28     	; 0x779e <vfprintf+0xe8>
    7782:	9e 32       	cpi	r25, 0x2E	; 46
    7784:	29 f4       	brne	.+10     	; 0x7790 <vfprintf+0xda>
    7786:	f6 fc       	sbrc	r15, 6
    7788:	6b c1       	rjmp	.+726    	; 0x7a60 <vfprintf+0x3aa>
    778a:	40 e4       	ldi	r20, 0x40	; 64
    778c:	f4 2a       	or	r15, r20
    778e:	07 c0       	rjmp	.+14     	; 0x779e <vfprintf+0xe8>
    7790:	9c 36       	cpi	r25, 0x6C	; 108
    7792:	19 f4       	brne	.+6      	; 0x779a <vfprintf+0xe4>
    7794:	50 e8       	ldi	r21, 0x80	; 128
    7796:	f5 2a       	or	r15, r21
    7798:	02 c0       	rjmp	.+4      	; 0x779e <vfprintf+0xe8>
    779a:	98 36       	cpi	r25, 0x68	; 104
    779c:	49 f4       	brne	.+18     	; 0x77b0 <vfprintf+0xfa>
    779e:	f2 01       	movw	r30, r4
    77a0:	23 fd       	sbrc	r18, 3
    77a2:	95 91       	lpm	r25, Z+
    77a4:	23 ff       	sbrs	r18, 3
    77a6:	91 91       	ld	r25, Z+
    77a8:	2f 01       	movw	r4, r30
    77aa:	99 23       	and	r25, r25
    77ac:	09 f0       	breq	.+2      	; 0x77b0 <vfprintf+0xfa>
    77ae:	b8 cf       	rjmp	.-144    	; 0x7720 <vfprintf+0x6a>
    77b0:	89 2f       	mov	r24, r25
    77b2:	85 54       	subi	r24, 0x45	; 69
    77b4:	83 30       	cpi	r24, 0x03	; 3
    77b6:	18 f0       	brcs	.+6      	; 0x77be <vfprintf+0x108>
    77b8:	80 52       	subi	r24, 0x20	; 32
    77ba:	83 30       	cpi	r24, 0x03	; 3
    77bc:	38 f4       	brcc	.+14     	; 0x77cc <vfprintf+0x116>
    77be:	44 e0       	ldi	r20, 0x04	; 4
    77c0:	50 e0       	ldi	r21, 0x00	; 0
    77c2:	a4 0e       	add	r10, r20
    77c4:	b5 1e       	adc	r11, r21
    77c6:	5f e3       	ldi	r21, 0x3F	; 63
    77c8:	59 83       	std	Y+1, r21	; 0x01
    77ca:	0f c0       	rjmp	.+30     	; 0x77ea <vfprintf+0x134>
    77cc:	93 36       	cpi	r25, 0x63	; 99
    77ce:	31 f0       	breq	.+12     	; 0x77dc <vfprintf+0x126>
    77d0:	93 37       	cpi	r25, 0x73	; 115
    77d2:	79 f0       	breq	.+30     	; 0x77f2 <vfprintf+0x13c>
    77d4:	93 35       	cpi	r25, 0x53	; 83
    77d6:	09 f0       	breq	.+2      	; 0x77da <vfprintf+0x124>
    77d8:	56 c0       	rjmp	.+172    	; 0x7886 <vfprintf+0x1d0>
    77da:	20 c0       	rjmp	.+64     	; 0x781c <vfprintf+0x166>
    77dc:	f5 01       	movw	r30, r10
    77de:	80 81       	ld	r24, Z
    77e0:	89 83       	std	Y+1, r24	; 0x01
    77e2:	42 e0       	ldi	r20, 0x02	; 2
    77e4:	50 e0       	ldi	r21, 0x00	; 0
    77e6:	a4 0e       	add	r10, r20
    77e8:	b5 1e       	adc	r11, r21
    77ea:	61 01       	movw	r12, r2
    77ec:	01 e0       	ldi	r16, 0x01	; 1
    77ee:	10 e0       	ldi	r17, 0x00	; 0
    77f0:	12 c0       	rjmp	.+36     	; 0x7816 <vfprintf+0x160>
    77f2:	f5 01       	movw	r30, r10
    77f4:	c0 80       	ld	r12, Z
    77f6:	d1 80       	ldd	r13, Z+1	; 0x01
    77f8:	f6 fc       	sbrc	r15, 6
    77fa:	03 c0       	rjmp	.+6      	; 0x7802 <vfprintf+0x14c>
    77fc:	6f ef       	ldi	r22, 0xFF	; 255
    77fe:	7f ef       	ldi	r23, 0xFF	; 255
    7800:	02 c0       	rjmp	.+4      	; 0x7806 <vfprintf+0x150>
    7802:	69 2d       	mov	r22, r9
    7804:	70 e0       	ldi	r23, 0x00	; 0
    7806:	42 e0       	ldi	r20, 0x02	; 2
    7808:	50 e0       	ldi	r21, 0x00	; 0
    780a:	a4 0e       	add	r10, r20
    780c:	b5 1e       	adc	r11, r21
    780e:	c6 01       	movw	r24, r12
    7810:	0e 94 43 3d 	call	0x7a86	; 0x7a86 <strnlen>
    7814:	8c 01       	movw	r16, r24
    7816:	5f e7       	ldi	r21, 0x7F	; 127
    7818:	f5 22       	and	r15, r21
    781a:	14 c0       	rjmp	.+40     	; 0x7844 <vfprintf+0x18e>
    781c:	f5 01       	movw	r30, r10
    781e:	c0 80       	ld	r12, Z
    7820:	d1 80       	ldd	r13, Z+1	; 0x01
    7822:	f6 fc       	sbrc	r15, 6
    7824:	03 c0       	rjmp	.+6      	; 0x782c <vfprintf+0x176>
    7826:	6f ef       	ldi	r22, 0xFF	; 255
    7828:	7f ef       	ldi	r23, 0xFF	; 255
    782a:	02 c0       	rjmp	.+4      	; 0x7830 <vfprintf+0x17a>
    782c:	69 2d       	mov	r22, r9
    782e:	70 e0       	ldi	r23, 0x00	; 0
    7830:	42 e0       	ldi	r20, 0x02	; 2
    7832:	50 e0       	ldi	r21, 0x00	; 0
    7834:	a4 0e       	add	r10, r20
    7836:	b5 1e       	adc	r11, r21
    7838:	c6 01       	movw	r24, r12
    783a:	0e 94 38 3d 	call	0x7a70	; 0x7a70 <strnlen_P>
    783e:	8c 01       	movw	r16, r24
    7840:	50 e8       	ldi	r21, 0x80	; 128
    7842:	f5 2a       	or	r15, r21
    7844:	f3 fe       	sbrs	r15, 3
    7846:	07 c0       	rjmp	.+14     	; 0x7856 <vfprintf+0x1a0>
    7848:	1a c0       	rjmp	.+52     	; 0x787e <vfprintf+0x1c8>
    784a:	80 e2       	ldi	r24, 0x20	; 32
    784c:	90 e0       	ldi	r25, 0x00	; 0
    784e:	b3 01       	movw	r22, r6
    7850:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <fputc>
    7854:	ea 94       	dec	r14
    7856:	8e 2d       	mov	r24, r14
    7858:	90 e0       	ldi	r25, 0x00	; 0
    785a:	08 17       	cp	r16, r24
    785c:	19 07       	cpc	r17, r25
    785e:	a8 f3       	brcs	.-22     	; 0x784a <vfprintf+0x194>
    7860:	0e c0       	rjmp	.+28     	; 0x787e <vfprintf+0x1c8>
    7862:	f6 01       	movw	r30, r12
    7864:	f7 fc       	sbrc	r15, 7
    7866:	85 91       	lpm	r24, Z+
    7868:	f7 fe       	sbrs	r15, 7
    786a:	81 91       	ld	r24, Z+
    786c:	6f 01       	movw	r12, r30
    786e:	90 e0       	ldi	r25, 0x00	; 0
    7870:	b3 01       	movw	r22, r6
    7872:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <fputc>
    7876:	e1 10       	cpse	r14, r1
    7878:	ea 94       	dec	r14
    787a:	01 50       	subi	r16, 0x01	; 1
    787c:	10 40       	sbci	r17, 0x00	; 0
    787e:	01 15       	cp	r16, r1
    7880:	11 05       	cpc	r17, r1
    7882:	79 f7       	brne	.-34     	; 0x7862 <vfprintf+0x1ac>
    7884:	ea c0       	rjmp	.+468    	; 0x7a5a <vfprintf+0x3a4>
    7886:	94 36       	cpi	r25, 0x64	; 100
    7888:	11 f0       	breq	.+4      	; 0x788e <vfprintf+0x1d8>
    788a:	99 36       	cpi	r25, 0x69	; 105
    788c:	69 f5       	brne	.+90     	; 0x78e8 <vfprintf+0x232>
    788e:	f7 fe       	sbrs	r15, 7
    7890:	08 c0       	rjmp	.+16     	; 0x78a2 <vfprintf+0x1ec>
    7892:	f5 01       	movw	r30, r10
    7894:	20 81       	ld	r18, Z
    7896:	31 81       	ldd	r19, Z+1	; 0x01
    7898:	42 81       	ldd	r20, Z+2	; 0x02
    789a:	53 81       	ldd	r21, Z+3	; 0x03
    789c:	84 e0       	ldi	r24, 0x04	; 4
    789e:	90 e0       	ldi	r25, 0x00	; 0
    78a0:	0a c0       	rjmp	.+20     	; 0x78b6 <vfprintf+0x200>
    78a2:	f5 01       	movw	r30, r10
    78a4:	80 81       	ld	r24, Z
    78a6:	91 81       	ldd	r25, Z+1	; 0x01
    78a8:	9c 01       	movw	r18, r24
    78aa:	44 27       	eor	r20, r20
    78ac:	37 fd       	sbrc	r19, 7
    78ae:	40 95       	com	r20
    78b0:	54 2f       	mov	r21, r20
    78b2:	82 e0       	ldi	r24, 0x02	; 2
    78b4:	90 e0       	ldi	r25, 0x00	; 0
    78b6:	a8 0e       	add	r10, r24
    78b8:	b9 1e       	adc	r11, r25
    78ba:	9f e6       	ldi	r25, 0x6F	; 111
    78bc:	f9 22       	and	r15, r25
    78be:	57 ff       	sbrs	r21, 7
    78c0:	09 c0       	rjmp	.+18     	; 0x78d4 <vfprintf+0x21e>
    78c2:	50 95       	com	r21
    78c4:	40 95       	com	r20
    78c6:	30 95       	com	r19
    78c8:	21 95       	neg	r18
    78ca:	3f 4f       	sbci	r19, 0xFF	; 255
    78cc:	4f 4f       	sbci	r20, 0xFF	; 255
    78ce:	5f 4f       	sbci	r21, 0xFF	; 255
    78d0:	e0 e8       	ldi	r30, 0x80	; 128
    78d2:	fe 2a       	or	r15, r30
    78d4:	ca 01       	movw	r24, r20
    78d6:	b9 01       	movw	r22, r18
    78d8:	a1 01       	movw	r20, r2
    78da:	2a e0       	ldi	r18, 0x0A	; 10
    78dc:	30 e0       	ldi	r19, 0x00	; 0
    78de:	0e 94 7a 3d 	call	0x7af4	; 0x7af4 <__ultoa_invert>
    78e2:	d8 2e       	mov	r13, r24
    78e4:	d2 18       	sub	r13, r2
    78e6:	40 c0       	rjmp	.+128    	; 0x7968 <vfprintf+0x2b2>
    78e8:	95 37       	cpi	r25, 0x75	; 117
    78ea:	29 f4       	brne	.+10     	; 0x78f6 <vfprintf+0x240>
    78ec:	1f 2d       	mov	r17, r15
    78ee:	1f 7e       	andi	r17, 0xEF	; 239
    78f0:	2a e0       	ldi	r18, 0x0A	; 10
    78f2:	30 e0       	ldi	r19, 0x00	; 0
    78f4:	1d c0       	rjmp	.+58     	; 0x7930 <vfprintf+0x27a>
    78f6:	1f 2d       	mov	r17, r15
    78f8:	19 7f       	andi	r17, 0xF9	; 249
    78fa:	9f 36       	cpi	r25, 0x6F	; 111
    78fc:	61 f0       	breq	.+24     	; 0x7916 <vfprintf+0x260>
    78fe:	90 37       	cpi	r25, 0x70	; 112
    7900:	20 f4       	brcc	.+8      	; 0x790a <vfprintf+0x254>
    7902:	98 35       	cpi	r25, 0x58	; 88
    7904:	09 f0       	breq	.+2      	; 0x7908 <vfprintf+0x252>
    7906:	ac c0       	rjmp	.+344    	; 0x7a60 <vfprintf+0x3aa>
    7908:	0f c0       	rjmp	.+30     	; 0x7928 <vfprintf+0x272>
    790a:	90 37       	cpi	r25, 0x70	; 112
    790c:	39 f0       	breq	.+14     	; 0x791c <vfprintf+0x266>
    790e:	98 37       	cpi	r25, 0x78	; 120
    7910:	09 f0       	breq	.+2      	; 0x7914 <vfprintf+0x25e>
    7912:	a6 c0       	rjmp	.+332    	; 0x7a60 <vfprintf+0x3aa>
    7914:	04 c0       	rjmp	.+8      	; 0x791e <vfprintf+0x268>
    7916:	28 e0       	ldi	r18, 0x08	; 8
    7918:	30 e0       	ldi	r19, 0x00	; 0
    791a:	0a c0       	rjmp	.+20     	; 0x7930 <vfprintf+0x27a>
    791c:	10 61       	ori	r17, 0x10	; 16
    791e:	14 fd       	sbrc	r17, 4
    7920:	14 60       	ori	r17, 0x04	; 4
    7922:	20 e1       	ldi	r18, 0x10	; 16
    7924:	30 e0       	ldi	r19, 0x00	; 0
    7926:	04 c0       	rjmp	.+8      	; 0x7930 <vfprintf+0x27a>
    7928:	14 fd       	sbrc	r17, 4
    792a:	16 60       	ori	r17, 0x06	; 6
    792c:	20 e1       	ldi	r18, 0x10	; 16
    792e:	32 e0       	ldi	r19, 0x02	; 2
    7930:	17 ff       	sbrs	r17, 7
    7932:	08 c0       	rjmp	.+16     	; 0x7944 <vfprintf+0x28e>
    7934:	f5 01       	movw	r30, r10
    7936:	60 81       	ld	r22, Z
    7938:	71 81       	ldd	r23, Z+1	; 0x01
    793a:	82 81       	ldd	r24, Z+2	; 0x02
    793c:	93 81       	ldd	r25, Z+3	; 0x03
    793e:	44 e0       	ldi	r20, 0x04	; 4
    7940:	50 e0       	ldi	r21, 0x00	; 0
    7942:	08 c0       	rjmp	.+16     	; 0x7954 <vfprintf+0x29e>
    7944:	f5 01       	movw	r30, r10
    7946:	80 81       	ld	r24, Z
    7948:	91 81       	ldd	r25, Z+1	; 0x01
    794a:	bc 01       	movw	r22, r24
    794c:	80 e0       	ldi	r24, 0x00	; 0
    794e:	90 e0       	ldi	r25, 0x00	; 0
    7950:	42 e0       	ldi	r20, 0x02	; 2
    7952:	50 e0       	ldi	r21, 0x00	; 0
    7954:	a4 0e       	add	r10, r20
    7956:	b5 1e       	adc	r11, r21
    7958:	a1 01       	movw	r20, r2
    795a:	0e 94 7a 3d 	call	0x7af4	; 0x7af4 <__ultoa_invert>
    795e:	d8 2e       	mov	r13, r24
    7960:	d2 18       	sub	r13, r2
    7962:	8f e7       	ldi	r24, 0x7F	; 127
    7964:	f8 2e       	mov	r15, r24
    7966:	f1 22       	and	r15, r17
    7968:	f6 fe       	sbrs	r15, 6
    796a:	0b c0       	rjmp	.+22     	; 0x7982 <vfprintf+0x2cc>
    796c:	5e ef       	ldi	r21, 0xFE	; 254
    796e:	f5 22       	and	r15, r21
    7970:	d9 14       	cp	r13, r9
    7972:	38 f4       	brcc	.+14     	; 0x7982 <vfprintf+0x2cc>
    7974:	f4 fe       	sbrs	r15, 4
    7976:	07 c0       	rjmp	.+14     	; 0x7986 <vfprintf+0x2d0>
    7978:	f2 fc       	sbrc	r15, 2
    797a:	05 c0       	rjmp	.+10     	; 0x7986 <vfprintf+0x2d0>
    797c:	8f ee       	ldi	r24, 0xEF	; 239
    797e:	f8 22       	and	r15, r24
    7980:	02 c0       	rjmp	.+4      	; 0x7986 <vfprintf+0x2d0>
    7982:	1d 2d       	mov	r17, r13
    7984:	01 c0       	rjmp	.+2      	; 0x7988 <vfprintf+0x2d2>
    7986:	19 2d       	mov	r17, r9
    7988:	f4 fe       	sbrs	r15, 4
    798a:	0d c0       	rjmp	.+26     	; 0x79a6 <vfprintf+0x2f0>
    798c:	fe 01       	movw	r30, r28
    798e:	ed 0d       	add	r30, r13
    7990:	f1 1d       	adc	r31, r1
    7992:	80 81       	ld	r24, Z
    7994:	80 33       	cpi	r24, 0x30	; 48
    7996:	19 f4       	brne	.+6      	; 0x799e <vfprintf+0x2e8>
    7998:	99 ee       	ldi	r25, 0xE9	; 233
    799a:	f9 22       	and	r15, r25
    799c:	08 c0       	rjmp	.+16     	; 0x79ae <vfprintf+0x2f8>
    799e:	1f 5f       	subi	r17, 0xFF	; 255
    79a0:	f2 fe       	sbrs	r15, 2
    79a2:	05 c0       	rjmp	.+10     	; 0x79ae <vfprintf+0x2f8>
    79a4:	03 c0       	rjmp	.+6      	; 0x79ac <vfprintf+0x2f6>
    79a6:	8f 2d       	mov	r24, r15
    79a8:	86 78       	andi	r24, 0x86	; 134
    79aa:	09 f0       	breq	.+2      	; 0x79ae <vfprintf+0x2f8>
    79ac:	1f 5f       	subi	r17, 0xFF	; 255
    79ae:	0f 2d       	mov	r16, r15
    79b0:	f3 fc       	sbrc	r15, 3
    79b2:	14 c0       	rjmp	.+40     	; 0x79dc <vfprintf+0x326>
    79b4:	f0 fe       	sbrs	r15, 0
    79b6:	0f c0       	rjmp	.+30     	; 0x79d6 <vfprintf+0x320>
    79b8:	1e 15       	cp	r17, r14
    79ba:	10 f0       	brcs	.+4      	; 0x79c0 <vfprintf+0x30a>
    79bc:	9d 2c       	mov	r9, r13
    79be:	0b c0       	rjmp	.+22     	; 0x79d6 <vfprintf+0x320>
    79c0:	9d 2c       	mov	r9, r13
    79c2:	9e 0c       	add	r9, r14
    79c4:	91 1a       	sub	r9, r17
    79c6:	1e 2d       	mov	r17, r14
    79c8:	06 c0       	rjmp	.+12     	; 0x79d6 <vfprintf+0x320>
    79ca:	80 e2       	ldi	r24, 0x20	; 32
    79cc:	90 e0       	ldi	r25, 0x00	; 0
    79ce:	b3 01       	movw	r22, r6
    79d0:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <fputc>
    79d4:	1f 5f       	subi	r17, 0xFF	; 255
    79d6:	1e 15       	cp	r17, r14
    79d8:	c0 f3       	brcs	.-16     	; 0x79ca <vfprintf+0x314>
    79da:	04 c0       	rjmp	.+8      	; 0x79e4 <vfprintf+0x32e>
    79dc:	1e 15       	cp	r17, r14
    79de:	10 f4       	brcc	.+4      	; 0x79e4 <vfprintf+0x32e>
    79e0:	e1 1a       	sub	r14, r17
    79e2:	01 c0       	rjmp	.+2      	; 0x79e6 <vfprintf+0x330>
    79e4:	ee 24       	eor	r14, r14
    79e6:	04 ff       	sbrs	r16, 4
    79e8:	0f c0       	rjmp	.+30     	; 0x7a08 <vfprintf+0x352>
    79ea:	80 e3       	ldi	r24, 0x30	; 48
    79ec:	90 e0       	ldi	r25, 0x00	; 0
    79ee:	b3 01       	movw	r22, r6
    79f0:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <fputc>
    79f4:	02 ff       	sbrs	r16, 2
    79f6:	1d c0       	rjmp	.+58     	; 0x7a32 <vfprintf+0x37c>
    79f8:	01 fd       	sbrc	r16, 1
    79fa:	03 c0       	rjmp	.+6      	; 0x7a02 <vfprintf+0x34c>
    79fc:	88 e7       	ldi	r24, 0x78	; 120
    79fe:	90 e0       	ldi	r25, 0x00	; 0
    7a00:	0e c0       	rjmp	.+28     	; 0x7a1e <vfprintf+0x368>
    7a02:	88 e5       	ldi	r24, 0x58	; 88
    7a04:	90 e0       	ldi	r25, 0x00	; 0
    7a06:	0b c0       	rjmp	.+22     	; 0x7a1e <vfprintf+0x368>
    7a08:	80 2f       	mov	r24, r16
    7a0a:	86 78       	andi	r24, 0x86	; 134
    7a0c:	91 f0       	breq	.+36     	; 0x7a32 <vfprintf+0x37c>
    7a0e:	01 ff       	sbrs	r16, 1
    7a10:	02 c0       	rjmp	.+4      	; 0x7a16 <vfprintf+0x360>
    7a12:	8b e2       	ldi	r24, 0x2B	; 43
    7a14:	01 c0       	rjmp	.+2      	; 0x7a18 <vfprintf+0x362>
    7a16:	80 e2       	ldi	r24, 0x20	; 32
    7a18:	f7 fc       	sbrc	r15, 7
    7a1a:	8d e2       	ldi	r24, 0x2D	; 45
    7a1c:	90 e0       	ldi	r25, 0x00	; 0
    7a1e:	b3 01       	movw	r22, r6
    7a20:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <fputc>
    7a24:	06 c0       	rjmp	.+12     	; 0x7a32 <vfprintf+0x37c>
    7a26:	80 e3       	ldi	r24, 0x30	; 48
    7a28:	90 e0       	ldi	r25, 0x00	; 0
    7a2a:	b3 01       	movw	r22, r6
    7a2c:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <fputc>
    7a30:	9a 94       	dec	r9
    7a32:	d9 14       	cp	r13, r9
    7a34:	c0 f3       	brcs	.-16     	; 0x7a26 <vfprintf+0x370>
    7a36:	da 94       	dec	r13
    7a38:	f1 01       	movw	r30, r2
    7a3a:	ed 0d       	add	r30, r13
    7a3c:	f1 1d       	adc	r31, r1
    7a3e:	80 81       	ld	r24, Z
    7a40:	90 e0       	ldi	r25, 0x00	; 0
    7a42:	b3 01       	movw	r22, r6
    7a44:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <fputc>
    7a48:	dd 20       	and	r13, r13
    7a4a:	a9 f7       	brne	.-22     	; 0x7a36 <vfprintf+0x380>
    7a4c:	06 c0       	rjmp	.+12     	; 0x7a5a <vfprintf+0x3a4>
    7a4e:	80 e2       	ldi	r24, 0x20	; 32
    7a50:	90 e0       	ldi	r25, 0x00	; 0
    7a52:	b3 01       	movw	r22, r6
    7a54:	0e 94 4e 3d 	call	0x7a9c	; 0x7a9c <fputc>
    7a58:	ea 94       	dec	r14
    7a5a:	ee 20       	and	r14, r14
    7a5c:	c1 f7       	brne	.-16     	; 0x7a4e <vfprintf+0x398>
    7a5e:	43 ce       	rjmp	.-890    	; 0x76e6 <vfprintf+0x30>
    7a60:	f3 01       	movw	r30, r6
    7a62:	66 81       	ldd	r22, Z+6	; 0x06
    7a64:	77 81       	ldd	r23, Z+7	; 0x07
    7a66:	cb 01       	movw	r24, r22
    7a68:	2b 96       	adiw	r28, 0x0b	; 11
    7a6a:	e2 e1       	ldi	r30, 0x12	; 18
    7a6c:	0c 94 fd 3a 	jmp	0x75fa	; 0x75fa <__epilogue_restores__>

00007a70 <strnlen_P>:
    7a70:	fc 01       	movw	r30, r24
    7a72:	05 90       	lpm	r0, Z+
    7a74:	61 50       	subi	r22, 0x01	; 1
    7a76:	70 40       	sbci	r23, 0x00	; 0
    7a78:	01 10       	cpse	r0, r1
    7a7a:	d8 f7       	brcc	.-10     	; 0x7a72 <strnlen_P+0x2>
    7a7c:	80 95       	com	r24
    7a7e:	90 95       	com	r25
    7a80:	8e 0f       	add	r24, r30
    7a82:	9f 1f       	adc	r25, r31
    7a84:	08 95       	ret

00007a86 <strnlen>:
    7a86:	fc 01       	movw	r30, r24
    7a88:	61 50       	subi	r22, 0x01	; 1
    7a8a:	70 40       	sbci	r23, 0x00	; 0
    7a8c:	01 90       	ld	r0, Z+
    7a8e:	01 10       	cpse	r0, r1
    7a90:	d8 f7       	brcc	.-10     	; 0x7a88 <strnlen+0x2>
    7a92:	80 95       	com	r24
    7a94:	90 95       	com	r25
    7a96:	8e 0f       	add	r24, r30
    7a98:	9f 1f       	adc	r25, r31
    7a9a:	08 95       	ret

00007a9c <fputc>:
    7a9c:	0f 93       	push	r16
    7a9e:	1f 93       	push	r17
    7aa0:	cf 93       	push	r28
    7aa2:	df 93       	push	r29
    7aa4:	8c 01       	movw	r16, r24
    7aa6:	eb 01       	movw	r28, r22
    7aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    7aaa:	81 ff       	sbrs	r24, 1
    7aac:	1b c0       	rjmp	.+54     	; 0x7ae4 <fputc+0x48>
    7aae:	82 ff       	sbrs	r24, 2
    7ab0:	0d c0       	rjmp	.+26     	; 0x7acc <fputc+0x30>
    7ab2:	2e 81       	ldd	r18, Y+6	; 0x06
    7ab4:	3f 81       	ldd	r19, Y+7	; 0x07
    7ab6:	8c 81       	ldd	r24, Y+4	; 0x04
    7ab8:	9d 81       	ldd	r25, Y+5	; 0x05
    7aba:	28 17       	cp	r18, r24
    7abc:	39 07       	cpc	r19, r25
    7abe:	64 f4       	brge	.+24     	; 0x7ad8 <fputc+0x3c>
    7ac0:	e8 81       	ld	r30, Y
    7ac2:	f9 81       	ldd	r31, Y+1	; 0x01
    7ac4:	01 93       	st	Z+, r16
    7ac6:	f9 83       	std	Y+1, r31	; 0x01
    7ac8:	e8 83       	st	Y, r30
    7aca:	06 c0       	rjmp	.+12     	; 0x7ad8 <fputc+0x3c>
    7acc:	e8 85       	ldd	r30, Y+8	; 0x08
    7ace:	f9 85       	ldd	r31, Y+9	; 0x09
    7ad0:	80 2f       	mov	r24, r16
    7ad2:	09 95       	icall
    7ad4:	89 2b       	or	r24, r25
    7ad6:	31 f4       	brne	.+12     	; 0x7ae4 <fputc+0x48>
    7ad8:	8e 81       	ldd	r24, Y+6	; 0x06
    7ada:	9f 81       	ldd	r25, Y+7	; 0x07
    7adc:	01 96       	adiw	r24, 0x01	; 1
    7ade:	9f 83       	std	Y+7, r25	; 0x07
    7ae0:	8e 83       	std	Y+6, r24	; 0x06
    7ae2:	02 c0       	rjmp	.+4      	; 0x7ae8 <fputc+0x4c>
    7ae4:	0f ef       	ldi	r16, 0xFF	; 255
    7ae6:	1f ef       	ldi	r17, 0xFF	; 255
    7ae8:	c8 01       	movw	r24, r16
    7aea:	df 91       	pop	r29
    7aec:	cf 91       	pop	r28
    7aee:	1f 91       	pop	r17
    7af0:	0f 91       	pop	r16
    7af2:	08 95       	ret

00007af4 <__ultoa_invert>:
    7af4:	fa 01       	movw	r30, r20
    7af6:	aa 27       	eor	r26, r26
    7af8:	28 30       	cpi	r18, 0x08	; 8
    7afa:	51 f1       	breq	.+84     	; 0x7b50 <__ultoa_invert+0x5c>
    7afc:	20 31       	cpi	r18, 0x10	; 16
    7afe:	81 f1       	breq	.+96     	; 0x7b60 <__ultoa_invert+0x6c>
    7b00:	e8 94       	clt
    7b02:	6f 93       	push	r22
    7b04:	6e 7f       	andi	r22, 0xFE	; 254
    7b06:	6e 5f       	subi	r22, 0xFE	; 254
    7b08:	7f 4f       	sbci	r23, 0xFF	; 255
    7b0a:	8f 4f       	sbci	r24, 0xFF	; 255
    7b0c:	9f 4f       	sbci	r25, 0xFF	; 255
    7b0e:	af 4f       	sbci	r26, 0xFF	; 255
    7b10:	b1 e0       	ldi	r27, 0x01	; 1
    7b12:	3e d0       	rcall	.+124    	; 0x7b90 <__ultoa_invert+0x9c>
    7b14:	b4 e0       	ldi	r27, 0x04	; 4
    7b16:	3c d0       	rcall	.+120    	; 0x7b90 <__ultoa_invert+0x9c>
    7b18:	67 0f       	add	r22, r23
    7b1a:	78 1f       	adc	r23, r24
    7b1c:	89 1f       	adc	r24, r25
    7b1e:	9a 1f       	adc	r25, r26
    7b20:	a1 1d       	adc	r26, r1
    7b22:	68 0f       	add	r22, r24
    7b24:	79 1f       	adc	r23, r25
    7b26:	8a 1f       	adc	r24, r26
    7b28:	91 1d       	adc	r25, r1
    7b2a:	a1 1d       	adc	r26, r1
    7b2c:	6a 0f       	add	r22, r26
    7b2e:	71 1d       	adc	r23, r1
    7b30:	81 1d       	adc	r24, r1
    7b32:	91 1d       	adc	r25, r1
    7b34:	a1 1d       	adc	r26, r1
    7b36:	20 d0       	rcall	.+64     	; 0x7b78 <__ultoa_invert+0x84>
    7b38:	09 f4       	brne	.+2      	; 0x7b3c <__ultoa_invert+0x48>
    7b3a:	68 94       	set
    7b3c:	3f 91       	pop	r19
    7b3e:	2a e0       	ldi	r18, 0x0A	; 10
    7b40:	26 9f       	mul	r18, r22
    7b42:	11 24       	eor	r1, r1
    7b44:	30 19       	sub	r19, r0
    7b46:	30 5d       	subi	r19, 0xD0	; 208
    7b48:	31 93       	st	Z+, r19
    7b4a:	de f6       	brtc	.-74     	; 0x7b02 <__ultoa_invert+0xe>
    7b4c:	cf 01       	movw	r24, r30
    7b4e:	08 95       	ret
    7b50:	46 2f       	mov	r20, r22
    7b52:	47 70       	andi	r20, 0x07	; 7
    7b54:	40 5d       	subi	r20, 0xD0	; 208
    7b56:	41 93       	st	Z+, r20
    7b58:	b3 e0       	ldi	r27, 0x03	; 3
    7b5a:	0f d0       	rcall	.+30     	; 0x7b7a <__ultoa_invert+0x86>
    7b5c:	c9 f7       	brne	.-14     	; 0x7b50 <__ultoa_invert+0x5c>
    7b5e:	f6 cf       	rjmp	.-20     	; 0x7b4c <__ultoa_invert+0x58>
    7b60:	46 2f       	mov	r20, r22
    7b62:	4f 70       	andi	r20, 0x0F	; 15
    7b64:	40 5d       	subi	r20, 0xD0	; 208
    7b66:	4a 33       	cpi	r20, 0x3A	; 58
    7b68:	18 f0       	brcs	.+6      	; 0x7b70 <__ultoa_invert+0x7c>
    7b6a:	49 5d       	subi	r20, 0xD9	; 217
    7b6c:	31 fd       	sbrc	r19, 1
    7b6e:	40 52       	subi	r20, 0x20	; 32
    7b70:	41 93       	st	Z+, r20
    7b72:	02 d0       	rcall	.+4      	; 0x7b78 <__ultoa_invert+0x84>
    7b74:	a9 f7       	brne	.-22     	; 0x7b60 <__ultoa_invert+0x6c>
    7b76:	ea cf       	rjmp	.-44     	; 0x7b4c <__ultoa_invert+0x58>
    7b78:	b4 e0       	ldi	r27, 0x04	; 4
    7b7a:	a6 95       	lsr	r26
    7b7c:	97 95       	ror	r25
    7b7e:	87 95       	ror	r24
    7b80:	77 95       	ror	r23
    7b82:	67 95       	ror	r22
    7b84:	ba 95       	dec	r27
    7b86:	c9 f7       	brne	.-14     	; 0x7b7a <__ultoa_invert+0x86>
    7b88:	00 97       	sbiw	r24, 0x00	; 0
    7b8a:	61 05       	cpc	r22, r1
    7b8c:	71 05       	cpc	r23, r1
    7b8e:	08 95       	ret
    7b90:	9b 01       	movw	r18, r22
    7b92:	ac 01       	movw	r20, r24
    7b94:	0a 2e       	mov	r0, r26
    7b96:	06 94       	lsr	r0
    7b98:	57 95       	ror	r21
    7b9a:	47 95       	ror	r20
    7b9c:	37 95       	ror	r19
    7b9e:	27 95       	ror	r18
    7ba0:	ba 95       	dec	r27
    7ba2:	c9 f7       	brne	.-14     	; 0x7b96 <__ultoa_invert+0xa2>
    7ba4:	62 0f       	add	r22, r18
    7ba6:	73 1f       	adc	r23, r19
    7ba8:	84 1f       	adc	r24, r20
    7baa:	95 1f       	adc	r25, r21
    7bac:	a0 1d       	adc	r26, r0
    7bae:	08 95       	ret

00007bb0 <_exit>:
    7bb0:	f8 94       	cli

00007bb2 <__stop_program>:
    7bb2:	ff cf       	rjmp	.-2      	; 0x7bb2 <__stop_program>
